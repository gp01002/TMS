<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>è‰¾æŸåœ‹éš›èŠ³ç™‚ - VR æŒ‰æ‘©æ•™å­¸ (Quest 3 æ¥µç°¡ç‰ˆ)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/webxr/XRControllerModelFactory.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/webxr/XRHandModelFactory.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: #1a1a1a;
            overflow: hidden;
            touch-action: none;
        }
        
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        .top-bar {
            position: absolute; top: 0; left: 0; width: 100%;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            padding: 15px 25px; color: white; display: flex; justify-content: space-between;
            align-items: center; pointer-events: auto;
        }

        .side-menu {
            position: absolute; left: 20px; top: 80px; width: 300px;
            background: rgba(30, 30, 30, 0.95); backdrop-filter: blur(10px);
            border-radius: 15px; padding: 15px; border: 1px solid rgba(255,255,255,0.1);
            pointer-events: auto; max-height: calc(100vh - 120px); overflow-y: auto;
            transform: translateX(-360px); transition: transform 0.3s ease; z-index: 20;
        }
        .side-menu.show { transform: translateX(0); }
        
        .menu-title { 
            color: #8ec5fc; font-size: 14px; margin-bottom: 10px; font-weight: bold; 
            letter-spacing: 1px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; 
            cursor: pointer;
        }
        
        .phase-btn {
            display: block; width: 100%; padding: 12px; margin-bottom: 8px;
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px; color: #ccc; text-align: left; cursor: pointer;
            transition: all 0.2s; font-size: 14px;
        }
        .phase-btn:hover { background: rgba(255,255,255,0.1); }
        .phase-btn.active { 
            background: linear-gradient(90deg, #667eea, #764ba2); 
            color: white; border: none; box-shadow: 0 4px 12px rgba(118, 75, 162, 0.4);
        }

        .pose-section { display: block; background: rgba(102, 126, 234, 0.2); padding: 12px; border-radius: 8px; margin-bottom: 15px; border: 1px solid rgba(102, 126, 234, 0.3); }
        .pose-label { font-size: 11px; color: #8ec5fc; display: flex; justify-content: space-between; margin-bottom: 3px; }
        .pose-input { width: 100%; cursor: pointer; accent-color: #667eea; height: 20px; }
        .pose-btn {
            padding: 8px 12px; margin: 4px 2px; background: rgba(102, 126, 234, 0.3);
            border: 1px solid rgba(102, 126, 234, 0.5); border-radius: 6px;
            color: #8ec5fc; font-size: 11px; cursor: pointer; transition: all 0.2s;
        }
        .pose-btn:hover { background: rgba(102, 126, 234, 0.5); }
        .pose-btn.active { background: #667eea; color: white; }

        .action-card {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(30, 30, 30, 0.95); backdrop-filter: blur(10px);
            padding: 20px 30px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center; width: 90%; max-width: 500px;
            pointer-events: auto; transition: all 0.3s ease;
            display: flex; flex-direction: column; align-items: center;
        }
        
        .instruction-title { color: #8ec5fc; font-size: 12px; font-weight: bold; margin-bottom: 5px; text-transform: uppercase; }
        .instruction-text { color: #fff; font-size: 20px; font-weight: bold; margin-bottom: 8px; }
        .instruction-note { color: #aaa; font-size: 14px; margin-bottom: 15px; line-height: 1.5; }

        .nav-btn {
            background: #444; color: white; border: none; padding: 8px 16px;
            border-radius: 20px; cursor: pointer; margin: 0 5px; font-weight: bold;
            font-size: 14px; display: inline-flex; align-items: center; gap: 5px;
        }
        .nav-btn:hover { background: #555; }
        .nav-btn.primary { background: #667eea; }
        
        .lock-btn { background: #444; border: 1px solid #666; }
        .lock-btn.locked { background: #ff6b6b; border: 1px solid #ff4444; }

        .gesture-hint {
            position: absolute; background: rgba(102, 126, 234, 0.9); color: white;
            padding: 8px 16px; border-radius: 20px; font-weight: bold;
            font-size: 14px; pointer-events: none; opacity: 0; transition: opacity 0.3s;
            transform: translate(-50%, -100%); white-space: nowrap; z-index: 100;
        }
        
        .action-label {
             position: absolute; background: rgba(0,0,0,0.7); color: #FFD700;
             padding: 6px 10px; border-radius: 6px; font-size: 14px; pointer-events: none;
             white-space: nowrap; z-index: 99; display: none;
        }

        .welcome-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(20, 20, 20, 0.95); z-index: 1000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; text-align: center; padding: 20px;
        }
        .main-title {
            font-size: 40px; font-weight: bold; color: #8ec5fc; 
            margin-bottom: 10px; letter-spacing: 2px;
        }
        .start-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white; border: none; padding: 15px 50px;
            font-size: 20px; border-radius: 50px; margin-top: 30px;
            cursor: pointer; box-shadow: 0 0 20px rgba(118, 75, 162, 0.6);
        }
        .loading-spinner {
            border: 4px solid rgba(255,255,255,0.1); border-left-color: #667eea;
            border-radius: 50%; width: 40px; height: 40px;
            animation: spin 1s linear infinite; margin-top: 20px; display: none;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        .vr-status {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0,0,0,0.9); padding: 15px 20px;
            border-radius: 15px; color: #fff;
            font-size: 14px; display: none;
            border: 2px solid #00ff00;
            box-shadow: 0 0 20px rgba(0,255,0,0.5);
            font-family: 'Courier New', monospace;
            min-width: 250px;
        }
        .vr-status.active { display: block; }
        .vr-status-line { 
            margin: 5px 0; 
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .vr-status-line:last-child { border-bottom: none; }
    </style>
</head>
<body>

    <div class="welcome-overlay" id="welcome">
        <div class="main-title">è‰¾æŸåœ‹éš›èŠ³ç™‚</div>
        <h1 style="font-size: 28px; margin-bottom: 10px;">ğŸ¤² VR ç‘å…¸æŒ‰æ‘©æ•™å­¸</h1>
        <p style="color: #00ff00; font-size: 20px; font-weight: bold;">Quest 3 æ¥µç°¡ç‰ˆ v1.0</p>
        <p style="color: #8ec5fc; font-size: 14px; margin-top:10px;">âœ¨ ç§»é™¤è¡çªç‰¹æ€§ + æ ¸å¿ƒæ‰‹éƒ¨è¿½è¹¤</p>
        
        <div style="margin-top: 30px; background: rgba(0,255,0,0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(0,255,0,0.3); max-width: 600px;">
            <p style="color: #00ff00; font-weight: bold; font-size: 16px; margin-bottom: 15px;">ğŸ”§ Quest 3 å¿«é€Ÿè¨­å®š</p>
            <div style="text-align: left; color: #ccc; line-height: 2;">
                <p>1ï¸âƒ£ Quest è¨­å®š â†’ <span style="color:#00ff00">å‹•ä½œ</span> â†’ æ‰‹éƒ¨è¿½è¹¤ â†’ <span style="color:#00ff00">é–‹å•Ÿ</span></p>
                <p>2ï¸âƒ£ ä½¿ç”¨ <span style="color:#00ff00">Quest Browser</span>ï¼ˆå…§å»ºç€è¦½å™¨ï¼‰</p>
                <p>3ï¸âƒ£ ç¢ºèªç¶²å€æ˜¯ <span style="color:#00ff00">https://</span></p>
                <p>4ï¸âƒ£ é»æ“Šä¸‹æ–¹æŒ‰éˆ•é€²å…¥ VR</p>
                <p>5ï¸âƒ£ å…è¨± VR æ¬Šé™</p>
            </div>
        </div>
        
        <button class="start-btn" onclick="initApp()">é€²å…¥æ•™å®¤</button>
        <div class="loading-spinner" id="spinner"></div>
        
        <p style="margin-top: 20px; color: #ff6b6b; font-size: 12px;">
            âš ï¸ å¦‚æœå‡ºç¾ã€Œä¸æ”¯æ´ VRã€ï¼Œè«‹ä½¿ç”¨ Quest å…§å»ºç€è¦½å™¨
        </p>
    </div>

    <div id="canvas-container" style="width:100vw; height:100vh;"></div>
    
    <div class="ui-layer" id="ui" style="display:none;">
        <div class="top-bar">
            <div style="font-weight: bold; font-size: 18px; display:flex; align-items:center; gap:10px;">
                <span style="font-size:24px;" id="current-tool-icon">ğŸ¤š</span>
                <span id="phase-title">éšæ®µä¸€ï¼šæº–å‚™èˆ‡èµ·å§‹</span>
            </div>
            
            <div style="display:flex; gap:10px;">
                <button class="nav-btn lock-btn" id="lock-btn" onclick="toggleCameraLock()">ğŸ”“ è¦–è§’</button>
                <button class="nav-btn" onclick="toggleMenu()">â˜°</button>
            </div>
        </div>

        <div class="vr-status" id="vr-status">
            <div style="font-weight: bold; color: #00ff00; margin-bottom: 10px; font-size: 16px;">ğŸ” VR è¨ºæ–·</div>
            <div class="vr-status-line">ğŸ‘‹ æ‰‹éƒ¨: <span id="hand-track-status" style="color: #ffff00;">ç­‰å¾…ä¸­...</span></div>
            <div class="vr-status-line">ğŸ“ ä½ç½®: <span id="position-status">-</span></div>
            <div class="vr-status-line">ğŸ¯ è·é›¢: <span id="distance-status">-</span></div>
        </div>

        <div class="side-menu" id="side-menu">
            <div class="pose-section" id="pose-panel">
                <div class="menu-title">
                    ğŸ¦´ è…¿éƒ¨å§¿å‹¢ <span id="bone-status">(åµæ¸¬ä¸­)</span>
                </div>
                
                <div style="margin-bottom:8px;">
                    <button class="pose-btn active" id="btn-pose-flat" onclick="applyPose('flat')">å¹³èºº</button>
                    <button class="pose-btn" id="btn-pose-leftRaised" onclick="applyPose('leftRaised')">å·¦è…¿æŠ¬èµ·</button>
                    <button class="pose-btn" id="btn-pose-rightRaised" onclick="applyPose('rightRaised')">å³è…¿æŠ¬èµ·</button>
                </div>
                
                <div class="adjust-row">
                    <div class="pose-label"><span>å·¦å¤§è…¿</span> <span id="val-left-thigh">0Â°</span></div>
                    <input type="range" class="pose-input" id="range-left-thigh" min="-90" max="45" step="1" value="0" oninput="onSliderChange()">
                </div>
            </div>
            
            <div class="menu-title">ç™‚ç¨‹éšæ®µé¸å–®</div>
            <button class="phase-btn active" onclick="setPhase(1)" id="p1">1. æº–å‚™èˆ‡èµ·å§‹</button>
            <button class="phase-btn" onclick="setPhase(2)" id="p2">2. å·¦è…¿æŒ‰æ‘©</button>
            <button class="phase-btn" onclick="setPhase(3)" id="p3">3. å³è…¿æŒ‰æ‘©</button>
            <button class="phase-btn" onclick="setPhase(4)" id="p4">4. çµå°¾å®‰æ’«</button>
            
            <div class="menu-title" style="margin-top:20px;">ä¸€èˆ¬è¨­å®š</div>
            <button class="phase-btn" onclick="resetCam()">ğŸ”„ é‡ç½®è¦–è§’</button>
            <button class="phase-btn" onclick="toggleModel()">ğŸ‘¤ åˆ‡æ›æ¨¡ç‰¹å…’</button>
        </div>

        <div class="gesture-hint" id="gesture-hint">ğŸ‘† æŒ‰ä½ä¸¦æ‹–æ›³</div>
        <div class="action-label" id="action-label">è·Ÿéš¨æ‰‹éƒ¨</div>

        <div class="action-card">
            <div class="instruction-title">STEP <span id="step-num">1.1</span></div>
            <div class="instruction-text" id="action-text">è¼‰å…¥ä¸­...</div>
            <div class="instruction-note" id="action-note">è·Ÿéš¨æ‰‹éƒ¨æŒ‡å¼•æ“ä½œ</div>
            
            <div style="display:flex; justify-content: center; gap:10px;">
                <button class="nav-btn" onclick="prevStep()">ä¸Šä¸€æ­¥</button>
                <button class="nav-btn primary" onclick="forceComplete()">è·³é</button>
            </div>
        </div>
    </div>

    <script>
        const BASE_URL = "https://gp01002.github.io/TMS/";

        const MODEL_CONFIG = {
            male: { pos: { x: 0.1, y: 2.2, z: 0 }, scale: 1.0, rot: { x: -1.57, y: 0, z: 1.57 } },
            female: { pos: { x: 0.1, y: 2.18, z: 0 }, scale: 1.0, rot: { x: -1.57, y: 0, z: 1.57 } }
        };
        
        const LEFT_LEG_Z = 0.12;  
        const RIGHT_LEG_Z = -0.12;
        
        const COORDS = {
            THIGH_ROOT: -3.3, THIGH_MID: -2.4, KNEE: -1.5, CALF_MID: -0.7, ANKLE: 0.1, FOOT: 0.3            
        };

        const learningData = {
            1: [
                { id: "1.1", text: "æ¯›å·¾ç®¡ç†", note: "é»æ“Šæ¯›å·¾", type: "click", tool: "towel", icon: "â¬œ", pos: {x: COORDS.THIGH_ROOT, y: -0.25, z: 0} }, 
                { id: "1.2", text: "ä¸Šæ²¹", note: "åœç•™2ç§’", type: "press", tool: "oil", icon: "ğŸ§´", pos: {x: COORDS.KNEE, y: 0.2, z: 0}, duration: 2 },
                { id: "1.3", text: "é–‹å ´å®‰æ’«", note: "è…³è¸æ»‘åˆ°å¤§è…¿", type: "drag", tool: "hand", icon: "âœ¨", start: {x: COORDS.FOOT, y: -0.35, z: LEFT_LEG_Z}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: LEFT_LEG_Z} },
            ],
            2: [
                { id: "2.1", text: "å¤§è…¿é•·æ¨", note: "è†è“‹å¾€ä¸Š", type: "drag", tool: "hand", icon: "ğŸ‘", start: {x: COORDS.KNEE, y: -0.25, z: LEFT_LEG_Z}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: LEFT_LEG_Z} },
            ],
            3: [
                { id: "3.1", text: "å³è…¿é•·æ¨", note: "è†è“‹å¾€ä¸Š", type: "drag", tool: "hand", icon: "ğŸ‘", start: {x: COORDS.KNEE, y: -0.25, z: RIGHT_LEG_Z}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: RIGHT_LEG_Z} },
            ],
            4: [
                { id: "4.1", text: "é›™è…¿å®‰æ’«", note: "è…³è¸åˆ°å¤§è…¿", type: "drag", tool: "hand", icon: "âœ¨", start: {x: COORDS.FOOT, y: -0.35, z: 0}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: 0} },
            ]
        };

        let scene, camera, renderer, controls, model;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let interactables = []; 
        let currentPhase = 1, currentStepIndex = 0;
        let isDragging = false, isCameraLocked = false; 
        let ghostHand, tweenAnim, activeModelType = 'male';
        
        let modelPos = { ...MODEL_CONFIG.male.pos };
        let modelRot = { ...MODEL_CONFIG.male.rot };
        let modelScale = MODEL_CONFIG.male.scale;

        let bones = { leftUpLeg: null, leftLeg: null, rightUpLeg: null, rightLeg: null };
        let poseControls = { leftThigh: 0, leftKnee: 0, leftAnkle: 45, rightThigh: 0, rightKnee: 0, rightAnkle: 45 };
        const POSES = {
            flat: { leftThigh: 0, leftKnee: 0, leftAnkle: 45, rightThigh: 0, rightKnee: 0, rightAnkle: 45 },
            leftRaised: { leftThigh: -45, leftKnee: -90, leftAnkle: 45, rightThigh: 0, rightKnee: 0, rightAnkle: 45 },
            rightRaised: { leftThigh: 0, leftKnee: 0, leftAnkle: 45, rightThigh: -45, rightKnee: -90, rightAnkle: 45 }
        };

        // ========== VR è®Šæ•¸ ==========
        let vrControllers = [];
        let vrHands = [];
        let vrHandData = [];
        let handModelFactory, controllerModelFactory;
        let dolly;
        let vrHitStatus = { 
            isTouchingStart: false, 
            touchStartTime: 0,
            activeHand: null
        };
        let vrDebugText = null;
        let isStepCompleting = false;

        // VR è¨­å®šï¼ˆæ¥µç°¡åŒ–ï¼‰
        const VR_CONFIG = {
            DETECTION_RADIUS: 0.30,        // 30cm è¶…å¤§ç¯„åœ
            PRESS_DURATION: 0.5,
            HAND_INDICATOR_SIZE: 0.10,     // 10cm è¶…å¤§çƒ
            HAPTIC_INTENSITY: 1.0,
            HAPTIC_DURATION: 200
        };

        function safeSetText(id, text) { const el = document.getElementById(id); if (el) el.innerText = text; }

        function initApp() {
            document.getElementById('spinner').style.display = 'block';
            document.querySelector('.start-btn').style.display = 'none';
            setTimeout(initThreeJS, 100);
        }

        // ========== æ¥µç°¡ VRButtonï¼ˆç§»é™¤æ‰€æœ‰å¯èƒ½é€ æˆå•é¡Œçš„ç‰¹æ€§ï¼‰==========
        function createVRButton(renderer) {
            const button = document.createElement('button');
            button.style.position = 'absolute';
            button.style.bottom = '20px';
            button.style.padding = '18px 36px';
            button.style.border = '3px solid #00ff00';
            button.style.borderRadius = '15px';
            button.style.background = 'rgba(0,0,0,0.9)';
            button.style.color = '#00ff00';
            button.style.font = 'bold 22px "Courier New", monospace';
            button.style.cursor = 'pointer';
            button.style.left = 'calc(50% - 120px)';
            button.style.width = '240px';
            button.style.boxShadow = '0 0 30px rgba(0,255,0,0.8)';
            button.style.zIndex = '999';
            button.style.display = 'none';
            button.style.transition = 'all 0.3s';

            button.onmouseover = () => { 
                button.style.background = 'rgba(0,255,0,0.2)'; 
                button.style.transform = 'scale(1.05)';
            };
            button.onmouseout = () => { 
                button.style.background = 'rgba(0,0,0,0.9)'; 
                button.style.transform = 'scale(1)';
            };

            function showEnterVR() {
                let currentSession = null;
                
                async function onSessionStarted(session) {
                    console.log("âœ… ========== VR Session å•Ÿå‹•æˆåŠŸ ==========");
                    
                    session.addEventListener('end', onSessionEnded);
                    await renderer.xr.setSession(session);
                    button.textContent = 'ğŸšª é€€å‡º VR';
                    button.style.borderColor = '#ff6b6b';
                    button.style.color = '#ff6b6b';
                    button.style.boxShadow = '0 0 30px rgba(255,107,107,0.8)';
                    currentSession = session;
                    
                    document.getElementById('vr-status').classList.add('active');
                    safeSetText('hand-track-status', 'æ­£åœ¨é€£æ¥...');
                    
                    console.log("ğŸ“‹ Session è³‡è¨Š:");
                    console.log("  - inputSources:", session.inputSources.length);
                    console.log("  - renderState:", session.renderState);
                }

                function onSessionEnded() {
                    console.log("ğŸšª VR Session çµæŸ");
                    currentSession.removeEventListener('end', onSessionEnded);
                    button.textContent = 'ğŸ¥½ é€²å…¥ VR';
                    button.style.borderColor = '#00ff00';
                    button.style.color = '#00ff00';
                    button.style.boxShadow = '0 0 30px rgba(0,255,0,0.8)';
                    currentSession = null;
                    document.getElementById('vr-status').classList.remove('active');
                }

                button.style.display = '';
                button.innerHTML = 'ğŸ¥½ é€²å…¥ VR';

                button.onclick = function() {
                    if (currentSession === null) {
                        console.log("ğŸš€ ========== é–‹å§‹å•Ÿå‹• VR ==========");
                        console.log("ğŸ“± User Agent:", navigator.userAgent);
                        console.log("ğŸŒ URL:", window.location.href);
                        console.log("ğŸ”’ isSecureContext:", window.isSecureContext);
                        
                        // ğŸ”¥ æ¥µç°¡åŒ–é…ç½®ï¼šåªè¦æ±‚æœ€åŸºæœ¬çš„ç‰¹æ€§
                        const sessionInit = { 
                            optionalFeatures: [ 
                                'local-floor',
                                'hand-tracking'
                                // ç§»é™¤ 'bounded-floor', 'layers' ç­‰å¯èƒ½é€ æˆå•é¡Œçš„ç‰¹æ€§
                            ] 
                        };
                        
                        console.log("ğŸ“‹ Session é…ç½®:", sessionInit);
                        console.log("â³ æ­£åœ¨è«‹æ±‚ VR Session...");
                        
                        navigator.xr.requestSession('immersive-vr', sessionInit)
                            .then(session => {
                                console.log("âœ… requestSession æˆåŠŸ");
                                onSessionStarted(session);
                            })
                            .catch((err) => {
                                console.error("âŒ ========== VR å•Ÿå‹•å¤±æ•— ==========");
                                console.error("éŒ¯èª¤é¡å‹:", err.name);
                                console.error("éŒ¯èª¤è¨Šæ¯:", err.message);
                                console.error("å®Œæ•´éŒ¯èª¤:", err);
                                
                                let errorMsg = "âŒ VR å•Ÿå‹•å¤±æ•—\n\n";
                                
                                if (err.name === 'NotSupportedError') {
                                    errorMsg += "åŸå› ï¼šç€è¦½å™¨ä¸æ”¯æ´æ­¤åŠŸèƒ½\n\n";
                                    errorMsg += "è§£æ±ºæ–¹æ³•ï¼š\n";
                                    errorMsg += "1. ä½¿ç”¨ Quest Browserï¼ˆå…§å»ºç€è¦½å™¨ï¼‰\n";
                                    errorMsg += "2. æ›´æ–° Quest ç³»çµ±åˆ°æœ€æ–°ç‰ˆæœ¬\n";
                                } else if (err.name === 'NotAllowedError') {
                                    errorMsg += "åŸå› ï¼šæ¬Šé™è¢«æ‹’çµ•\n\n";
                                    errorMsg += "è§£æ±ºæ–¹æ³•ï¼š\n";
                                    errorMsg += "1. é‡æ–°æ•´ç†é é¢\n";
                                    errorMsg += "2. å…è¨± VR æ¬Šé™\n";
                                } else if (err.name === 'SecurityError') {
                                    errorMsg += "åŸå› ï¼šéœ€è¦ HTTPS\n\n";
                                    errorMsg += "ç•¶å‰ç¶²å€: " + window.location.protocol + "\n";
                                } else {
                                    errorMsg += "éŒ¯èª¤: " + err.message + "\n\n";
                                    errorMsg += "è«‹æª¢æŸ¥ï¼š\n";
                                    errorMsg += "1. Quest è¨­å®š â†’ å‹•ä½œ â†’ æ‰‹éƒ¨è¿½è¹¤\n";
                                    errorMsg += "2. ä½¿ç”¨ Quest å…§å»ºç€è¦½å™¨\n";
                                    errorMsg += "3. ç¢ºèªç¶²å€æ˜¯ https://\n";
                                }
                                
                                alert(errorMsg);
                            });
                    } else {
                        currentSession.end();
                    }
                };
            }

            // æª¢æŸ¥ WebXR æ”¯æ´
            if ('xr' in navigator) {
                console.log("âœ… navigator.xr å­˜åœ¨");
                
                if (!window.isSecureContext) {
                    console.error("âŒ ä¸æ˜¯å®‰å…¨ä¸Šä¸‹æ–‡ (éœ€è¦ HTTPS)");
                    button.style.display = '';
                    button.innerHTML = 'âš ï¸ éœ€è¦ HTTPS';
                    button.style.borderColor = '#ff6b6b';
                    button.style.color = '#ff6b6b';
                    button.onclick = () => {
                        alert("WebXR éœ€è¦ HTTPS\n\nç•¶å‰: " + window.location.protocol + "\nè«‹ä½¿ç”¨ https:// é–‹é ­çš„ç¶²å€");
                    };
                } else {
                    console.log("âœ… å®‰å…¨ä¸Šä¸‹æ–‡ç¢ºèª");
                    console.log("â³ æª¢æŸ¥ VR æ”¯æ´...");
                    
                    navigator.xr.isSessionSupported('immersive-vr')
                        .then(function(supported) {
                            console.log("ğŸ“Š VR æ”¯æ´æª¢æŸ¥çµæœ:", supported);
                            
                            if (supported) {
                                console.log("âœ… æ”¯æ´ immersive-vr");
                                showEnterVR();
                            } else {
                                console.error("âŒ ä¸æ”¯æ´ immersive-vr");
                                button.style.display = '';
                                button.innerHTML = 'âŒ ä¸æ”¯æ´ VR';
                                button.style.borderColor = '#888';
                                button.style.color = '#888';
                                button.style.cursor = 'not-allowed';
                            }
                        })
                        .catch(err => {
                            console.error("âŒ isSessionSupported å¤±æ•—:", err);
                            button.style.display = '';
                            button.innerHTML = 'â“ æª¢æŸ¥å¤±æ•—';
                            button.style.borderColor = '#ff6b6b';
                            button.style.color = '#ff6b6b';
                        });
                }
            } else {
                console.error("âŒ navigator.xr ä¸å­˜åœ¨");
                button.style.display = '';
                button.innerHTML = 'âŒ ä¸æ”¯æ´ WebXR';
                button.style.borderColor = '#888';
                button.style.color = '#888';
                button.style.cursor = 'not-allowed';
            }
            
            return button;
        }

        // ========== VR 3D ç‹€æ…‹é¢æ¿ ==========
        function createVRDebugText() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            function updateText(title, ...lines) {
                ctx.fillStyle = 'rgba(0,0,0,0.95)';
                ctx.fillRect(0, 0, 1024, 512);
                
                // ç¶ è‰²é‚Šæ¡†
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 6;
                ctx.strokeRect(3, 3, 1018, 506);
                
                // æ¨™é¡Œ
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 56px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText(title, 512, 80);
                
                // å…§å®¹
                ctx.fillStyle = 'white';
                ctx.font = '40px "Courier New"';
                ctx.textAlign = 'left';
                
                lines.forEach((line, i) => {
                    ctx.fillText(line, 50, 160 + i * 60);
                });
            }
            
            updateText(
                'ğŸ” Quest 3 æ‰‹éƒ¨è¨ºæ–·',
                'â³ æ­£åœ¨å•Ÿå‹•...',
                '',
                'è«‹å°‡é›™æ‰‹ä¼¸åˆ°é ­é¡¯å‰æ–¹',
                'ç­‰å¾…ç¶ è‰²ç™¼å…‰çƒå‡ºç¾'
            );
            
            const texture = new THREE.CanvasTexture(canvas);
            const mesh = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 1),
                new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    transparent: true, 
                    opacity: 0.95,
                    side: THREE.DoubleSide
                })
            );
            
            mesh.position.set(0, 1.0, -2.5);
            mesh.rotation.x = -0.15;
            
            dolly.add(mesh);
            
            return { mesh, ctx, texture, canvas, updateText };
        }

        function updateVRDebug(title, ...lines) {
            if (!vrDebugText) return;
            vrDebugText.updateText(title, ...lines);
            vrDebugText.texture.needsUpdate = true;
        }

        // ========== Three.js åˆå§‹åŒ– ==========
        function initThreeJS() {
            console.log("ğŸ¬ é–‹å§‹åˆå§‹åŒ– Three.js");
            
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 5, 15);
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            
            const spotLight = new THREE.SpotLight(0xffeeb1, 1.5);
            spotLight.position.set(2, 6, 2);
            scene.add(spotLight);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);
            camera.position.set(1.5, 2.5, 2.5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true; 
            container.appendChild(renderer.domElement);
            
            console.log("âœ… Three.js åŸºç¤è¨­ç½®å®Œæˆ");

            const vrButton = createVRButton(renderer);
            document.body.appendChild(vrButton);

            // VR Dolly
            dolly = new THREE.Group();
            dolly.position.set(1.5, 1.8, 2.0);
            dolly.rotation.y = -0.3;
            scene.add(dolly);
            dolly.add(camera);
            
            console.log("âœ… VR Dolly å‰µå»ºå®Œæˆ");
            
            vrDebugText = createVRDebugText();

            setupVRHands();

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxDistance = 6;
            controls.minDistance = 0.3; 
            
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onPointerDown);
            canvas.addEventListener('mousemove', onPointerMove);
            canvas.addEventListener('mouseup', onPointerUp);
            canvas.addEventListener('touchstart', onTouchStart, {passive: false});
            canvas.addEventListener('touchmove', onTouchMove, {passive: false});
            canvas.addEventListener('touchend', onPointerUp);
            window.addEventListener('resize', onWindowResize);

            // ä¸»å¾ªç’°
            renderer.setAnimationLoop(() => {
                if (renderer.xr.isPresenting) {
                    handleVRInteraction();
                    handleVRMovement();
                    updateVRStatus(); // æ›´æ–° VR ç‹€æ…‹é¡¯ç¤º
                } else {
                    controls.update();
                }

                interactables.forEach(obj => { if(obj.tick) obj.tick(); });
                
                if (ghostHand && ghostHand.visible && !renderer.xr.isPresenting) {
                    ghostHand.lookAt(camera.position);
                }
                
                renderer.render(scene, camera);
            });

            loadEnvironment();
            
            console.log("âœ… Three.js åˆå§‹åŒ–å®Œæˆ");
        }

        // ========== VR æ‰‹éƒ¨è¨­ç½®ï¼ˆæ¥µç°¡ç‰ˆï¼‰==========
        function setupVRHands() {
            console.log("ğŸ¤² ========== é–‹å§‹è¨­ç½® VR æ‰‹éƒ¨ ==========");
            
            if (typeof THREE.XRHandModelFactory === 'undefined') {
                console.error("âŒ XRHandModelFactory æœªå®šç¾©");
                return;
            }
            
            if (typeof THREE.XRControllerModelFactory === 'undefined') {
                console.error("âŒ XRControllerModelFactory æœªå®šç¾©");
                return;
            }

            handModelFactory = new THREE.XRHandModelFactory();
            controllerModelFactory = new THREE.XRControllerModelFactory();
            
            console.log("âœ… Model Factories å‰µå»ºæˆåŠŸ");

            for (let i = 0; i < 2; i++) {
                console.log(`\nğŸ”§ è¨­ç½®æ‰‹éƒ¨ ${i}...`);
                
                // æ§åˆ¶å™¨ï¼ˆå‚™ç”¨ï¼‰
                const controllerGrip = renderer.xr.getControllerGrip(i);
                const controllerModel = controllerModelFactory.createControllerModel(controllerGrip);
                controllerGrip.add(controllerModel);
                dolly.add(controllerGrip);

                const controller = renderer.xr.getController(i);
                dolly.add(controller);
                vrControllers.push(controller);
                
                console.log(`  âœ… æ§åˆ¶å™¨ ${i} è¨­ç½®å®Œæˆ`);

                // === æ‰‹éƒ¨è¿½è¹¤ ===
                const hand = renderer.xr.getHand(i);
                
                console.log(`  ğŸ¤² å‰µå»ºæ‰‹éƒ¨æ¨¡å‹ ${i} (spheres æ¨¡å¼)...`);
                
                try {
                    const handModel = handModelFactory.createHandModel(hand, "spheres");
                    hand.add(handModel);
                    console.log(`  âœ… æ‰‹éƒ¨æ¨¡å‹ ${i} å‰µå»ºæˆåŠŸ`);
                } catch (e) {
                    console.error(`  âŒ æ‰‹éƒ¨æ¨¡å‹ ${i} å‰µå»ºå¤±æ•—:`, e);
                }
                
                const handData = {
                    hand: hand,
                    handIndex: i,
                    handedness: null,
                    isTracking: false,
                    indexTip: null,
                    indicator: null
                };
                
                // ğŸ”¥ è¶…å¤§ç™¼å…‰æŒ‡ç¤ºå™¨
                const indicator = new THREE.Mesh(
                    new THREE.SphereGeometry(VR_CONFIG.HAND_INDICATOR_SIZE, 32, 32),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x00ff00, 
                        transparent: true, 
                        opacity: 0.9,
                        emissive: 0x00ff00,
                        emissiveIntensity: 2.0,
                        metalness: 0.5,
                        roughness: 0.3
                    })
                );
                indicator.visible = false;
                hand.add(indicator);
                handData.indicator = indicator;
                
                console.log(`  âœ… æŒ‡ç¤ºå™¨ ${i} å‰µå»ºå®Œæˆ (å¤§å°: ${VR_CONFIG.HAND_INDICATOR_SIZE})`);
                
                // é€£æ¥äº‹ä»¶
                hand.addEventListener('connected', (event) => {
                    const xrInputSource = event.data;
                    handData.handedness = xrInputSource.handedness;
                    handData.isTracking = true;
                    
                    console.log(`\nâœ… ========== ${handData.handedness.toUpperCase()} æ‰‹å·²é€£æ¥ ==========`);
                    console.log("  - Handedness:", xrInputSource.handedness);
                    console.log("  - Profiles:", xrInputSource.profiles);
                    console.log("  - Hand:", xrInputSource.hand);
                    
                    updateVRDebug(
                        `âœ… ${handData.handedness.toUpperCase()} æ‰‹å·²é€£æ¥ï¼`,
                        '',
                        'ğŸŸ¢ è¶…å¤§ç¶ è‰²çƒ = é£ŸæŒ‡å°–',
                        'ğŸ“ é è¿‘ç›®æ¨™ 30cm å…§è§¸ç™¼',
                        '',
                        'ğŸ‘† ä¼¸å‡ºé£ŸæŒ‡é–‹å§‹äº’å‹•'
                    );
                    
                    safeSetText('hand-track-status', `${handData.handedness} âœ…`);
                });
                
                hand.addEventListener('disconnected', () => {
                    handData.isTracking = false;
                    handData.indicator.visible = false;
                    
                    console.log(`âŒ ${handData.handedness} æ‰‹æ–·ç·š`);
                    
                    updateVRDebug(
                        'âŒ æ‰‹éƒ¨æ–·ç·š',
                        '',
                        'è«‹é‡æ–°å°‡æ‰‹ä¼¸åˆ°å‰æ–¹',
                        'ç¢ºä¿æ‰‹åœ¨è¦–é‡å…§'
                    );
                    
                    safeSetText('hand-track-status', 'æœªé€£æ¥');
                });
                
                vrHands.push(hand);
                vrHandData.push(handData);
                dolly.add(hand);
                
                console.log(`âœ… æ‰‹éƒ¨ ${i} å®Œæ•´è¨­ç½®å®Œæˆ`);
            }
            
            console.log("\nâœ… ========== VR æ‰‹éƒ¨è¨­ç½®å…¨éƒ¨å®Œæˆ ==========\n");
        }

        // ========== æ›´æ–° VR ç‹€æ…‹é¡¯ç¤º ==========
        function updateVRStatus() {
            vrHandData.forEach(handData => {
                if (!handData.isTracking) return;
                
                const hand = handData.hand;
                handData.indexTip = hand.joints['index-finger-tip'];
                
                if (handData.indexTip && handData.indicator) {
                    handData.indicator.position.copy(handData.indexTip.position);
                    handData.indicator.visible = true;
                    
                    // æ›´æ–°ç‹€æ…‹é¢æ¿
                    const worldPos = new THREE.Vector3();
                    handData.indexTip.getWorldPosition(worldPos);
                    
                    safeSetText('position-status', 
                        `(${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}, ${worldPos.z.toFixed(2)})`
                    );
                }
            });
        }

        // ========== VR äº’å‹•é‚è¼¯ ==========
        function handleVRInteraction() {
            if (!interactables.length || isStepCompleting) return;

            const step = learningData[currentPhase][currentStepIndex];
            const startObj = interactables.find(obj => obj.userData.isStart || (!obj.userData.isEnd && !obj.userData.isStart));
            const endObj = interactables.find(obj => obj.userData.isEnd);

            if (!startObj) return;

            vrHandData.forEach(handData => {
                if (!handData.isTracking || !handData.indexTip) return;

                const indexTipWorldPos = new THREE.Vector3();
                handData.indexTip.getWorldPosition(indexTipWorldPos);

                const distToStart = indexTipWorldPos.distanceTo(startObj.position);
                
                // æ›´æ–°è·é›¢é¡¯ç¤º
                safeSetText('distance-status', `${distToStart.toFixed(2)}m`);
                
                if (step.type === 'click') {
                    handleClickInteraction(distToStart, handData, startObj);
                } 
                else if (step.type === 'press') {
                    handlePressInteraction(distToStart, handData, startObj, step.duration || VR_CONFIG.PRESS_DURATION);
                } 
                else if (step.type === 'drag') {
                    handleDragInteraction(distToStart, indexTipWorldPos, handData, startObj, endObj);
                }
            });
        }

        function handleClickInteraction(distance, handData, targetObj) {
            if (distance < VR_CONFIG.DETECTION_RADIUS) {
                handData.indicator.material.color.set(0xff0000);
                handData.indicator.material.emissive.set(0xff0000);
                
                if (!vrHitStatus.touchStartTime) {
                    vrHitStatus.touchStartTime = Date.now();
                    vrHitStatus.activeHand = handData.handedness;
                    
                    triggerHaptic(handData);
                    playClickFeedback(targetObj);
                    
                    updateVRDebug(
                        `ğŸ”´ ${handData.handedness.toUpperCase()} è§¸ç¢°ä¸­`,
                        `ğŸ“ ${distance.toFixed(2)}m`,
                        '',
                        'ä¿æŒ 0.3 ç§’å®Œæˆ'
                    );
                } else {
                    const elapsed = (Date.now() - vrHitStatus.touchStartTime) / 1000;
                    if (elapsed >= 0.3) {
                        completeStepVR();
                        vrHitStatus.touchStartTime = 0;
                        vrHitStatus.activeHand = null;
                    }
                }
            } else {
                handData.indicator.material.color.set(0x00ff00);
                handData.indicator.material.emissive.set(0x00ff00);
                
                if (vrHitStatus.activeHand === handData.handedness) {
                    vrHitStatus.touchStartTime = 0;
                    vrHitStatus.activeHand = null;
                }
            }
        }

        function handlePressInteraction(distance, handData, targetObj, requiredDuration) {
            if (distance < VR_CONFIG.DETECTION_RADIUS) {
                handData.indicator.material.color.set(0xffff00);
                handData.indicator.material.emissive.set(0xffff00);
                
                if (!vrHitStatus.touchStartTime) {
                    vrHitStatus.touchStartTime = Date.now();
                    vrHitStatus.activeHand = handData.handedness;
                    triggerHaptic(handData, 0.5, 50);
                } else {
                    const elapsed = (Date.now() - vrHitStatus.touchStartTime) / 1000;
                    const progress = Math.min(elapsed / requiredDuration, 1);
                    
                    targetObj.scale.setScalar(1 + progress * 0.3);
                    
                    updateVRDebug(
                        `ğŸŸ¡ ${handData.handedness.toUpperCase()} æŒ‰å£“ä¸­`,
                        `â±ï¸ ${Math.floor(progress * 100)}%`,
                        `ğŸ“ ${distance.toFixed(2)}m`,
                        `â³ ${(requiredDuration - elapsed).toFixed(1)}ç§’`
                    );
                    
                    if (elapsed >= requiredDuration) {
                        completeStepVR();
                        vrHitStatus.touchStartTime = 0;
                        vrHitStatus.activeHand = null;
                    }
                }
            } else {
                handData.indicator.material.color.set(0x00ff00);
                handData.indicator.material.emissive.set(0x00ff00);
                
                if (vrHitStatus.activeHand === handData.handedness) {
                    vrHitStatus.touchStartTime = 0;
                    vrHitStatus.activeHand = null;
                    targetObj.scale.set(1, 1, 1);
                }
            }
        }

        function handleDragInteraction(distToStart, indexPos, handData, startObj, endObj) {
            if (!vrHitStatus.isTouchingStart) {
                if (distToStart < VR_CONFIG.DETECTION_RADIUS) {
                    vrHitStatus.isTouchingStart = true;
                    vrHitStatus.activeHand = handData.handedness;
                    handData.indicator.material.color.set(0xffff00);
                    handData.indicator.material.emissive.set(0xffff00);
                    
                    triggerHaptic(handData);
                    startObj.children[1].material.color.set(0xffff00);
                    
                    if (endObj) endObj.visible = true;
                    
                    updateVRDebug(
                        `ğŸŸ¡ ${handData.handedness.toUpperCase()} æŠ“å–æˆåŠŸ`,
                        '',
                        'æ‹–æ›³åˆ°è—è‰²çµ‚é»',
                        'ä¿æŒé£ŸæŒ‡æ¥è§¸'
                    );
                }
            } else if (vrHitStatus.activeHand === handData.handedness) {
                handData.indicator.material.color.set(0xffa500);
                handData.indicator.material.emissive.set(0xffa500);
                
                if (endObj) {
                    const distToEnd = indexPos.distanceTo(endObj.position);
                    const progress = 1 - Math.min(distToEnd / startObj.position.distanceTo(endObj.position), 1);
                    
                    startObj.children[1].material.opacity = 0.3 + progress * 0.7;
                    
                    updateVRDebug(
                        `ğŸŸ  ${handData.handedness.toUpperCase()} æ‹–æ›³ä¸­`,
                        `ğŸ“Š ${Math.floor(progress * 100)}%`,
                        `ğŸ“ è·çµ‚é»: ${distToEnd.toFixed(2)}m`,
                        `ğŸ¯ éœ€è¦: ${VR_CONFIG.DETECTION_RADIUS}m`
                    );
                    
                    if (distToEnd < VR_CONFIG.DETECTION_RADIUS) {
                        completeStepVR();
                        vrHitStatus.isTouchingStart = false;
                        vrHitStatus.activeHand = null;
                    }
                }
            }
        }

        function triggerHaptic(handData, intensity = VR_CONFIG.HAPTIC_INTENSITY, duration = VR_CONFIG.HAPTIC_DURATION) {
            vrControllers.forEach(controller => {
                if (controller.gamepad && controller.gamepad.hapticActuators && controller.gamepad.hapticActuators.length > 0) {
                    controller.gamepad.hapticActuators[0].pulse(intensity, duration);
                }
            });
        }

        function playClickFeedback(obj) {
            gsap.to(obj.scale, { 
                x: 1.5, y: 1.5, z: 1.5, 
                duration: 0.2, 
                yoyo: true, 
                repeat: 1
            });
        }

        function completeStepVR() {
            if (isStepCompleting) return;
            isStepCompleting = true;
            
            vrHandData.forEach(handData => {
                if (handData.isTracking) {
                    triggerHaptic(handData, 1.0, 300);
                }
            });
            
            interactables.forEach(obj => {
                gsap.to(obj.scale, { x: 0, y: 0, z: 0, duration: 0.4 });
            });
            
            updateVRDebug(
                'âœ… å®Œæˆï¼',
                'ğŸ‰ åšå¾—å¥½ï¼',
                '',
                'æº–å‚™ä¸‹ä¸€æ­¥...'
            );
            
            setTimeout(() => {
                nextStep();
                isStepCompleting = false;
            }, 1000);
        }

        function handleVRMovement() {
            if (!vrControllers || vrControllers.length === 0) return;

            const speed = 0.08;

            vrControllers.forEach((controller) => {
                if (controller.gamepad) {
                    const axes = controller.gamepad.axes;
                    if (axes && axes.length >= 4) {
                        const moveX = Math.abs(axes[2]) > 0.1 ? axes[2] : 0;
                        const moveZ = Math.abs(axes[3]) > 0.1 ? axes[3] : 0;
                        
                        if (moveX !== 0 || moveZ !== 0) {
                            const forward = new THREE.Vector3(0, 0, -1);
                            forward.applyQuaternion(dolly.quaternion);
                            forward.y = 0;
                            forward.normalize();
                            
                            const right = new THREE.Vector3(1, 0, 0);
                            right.applyQuaternion(dolly.quaternion);
                            right.y = 0;
                            right.normalize();
                            
                            dolly.position.addScaledVector(forward, moveZ * speed);
                            dolly.position.addScaledVector(right, moveX * speed);
                        }
                    }
                }
            });
        }

        // ========== æ¡Œé¢ç‰ˆäº’å‹•ï¼ˆä¿æŒä¸è®Šï¼‰==========
        function checkIntersection() {
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -model.position.y);
            const point = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, point);

            if (point && isDragging) {
                if (ghostHand) {
                    ghostHand.visible = true;
                    ghostHand.position.copy(point);
                    ghostHand.position.y += 0.2;
                    
                    const step = learningData[currentPhase][currentStepIndex];
                    if (step.type === 'drag') {
                        const endPos = new THREE.Vector3(
                            step.end.x + model.position.x,
                            step.end.y + model.position.y,
                            step.end.z + model.position.z
                        );
                        if (ghostHand.position.distanceTo(endPos) < 0.8) {
                            isDragging = false;
                            if (!isCameraLocked) controls.enabled = true;
                            setTimeout(() => { nextStep(); }, 500);
                        }
                    }
                }
            }

            const intersects = raycaster.intersectObjects(interactables, true);
            if (intersects.length > 0) {
                const step = learningData[currentPhase][currentStepIndex];
                if (isDragging && (step.type === 'press' || step.type === 'click')) {
                    isDragging = false;
                    const targetGroup = intersects[0].object.parent;
                    if (targetGroup) {
                        gsap.to(targetGroup.scale, { 
                            x: 1.5, y: 1.5, z: 1.5, 
                            duration: 0.2, 
                            yoyo: true, 
                            repeat: 1 
                        });
                    }
                    setTimeout(() => { nextStep(); }, 800);
                }
            }
        }

        // ========== ç’°å¢ƒèˆ‡æ¨¡å‹ï¼ˆä¿æŒä¸è®Šï¼‰==========
        function loadEnvironment() {
            const loader = new THREE.GLTFLoader();
            loader.load(BASE_URL + 'A01.glb', (gltf) => {
                const room = gltf.scene;
                room.scale.set(20, 20, 20);
                room.traverse(c => { if (c.isMesh) c.receiveShadow = true; });
                scene.add(room);
            });
            loadModel('male');
        }

        function toggleModel() {
            const newType = activeModelType === 'male' ? 'female' : 'male';
            loadModel(newType);
        }

        function loadModel(type) {
            if (model) scene.remove(model);
            
            activeModelType = type;
            const config = MODEL_CONFIG[type];
            modelPos = { ...config.pos };
            modelRot = { ...config.rot };
            modelScale = config.scale;

            const loader = new THREE.GLTFLoader();
            loader.load(BASE_URL + (type === 'male' ? 'B01.glb' : 'B02.glb'), (gltf) => {
                model = gltf.scene;
                model.position.set(modelPos.x, modelPos.y, modelPos.z);
                model.scale.set(modelScale, modelScale, modelScale);
                model.rotation.set(modelRot.x, modelRot.y, modelRot.z);
                
                model.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        child.frustumCulled = false;

                        if (child.material) {
                            child.material = new THREE.MeshStandardMaterial({
                                color: child.material.color,
                                map: child.material.map,
                                skinning: true
                            });
                        }
                    }
                });

                bones = {};
                model.traverse(child => {
                    if (child.isBone) {
                        const name = child.name.toLowerCase().replace(/[^a-z0-9]/g, '');
                        if (name.includes('left') && name.includes('thigh')) bones.leftUpLeg = child;
                        else if (name.includes('left') && name.includes('leg')) bones.leftLeg = child;
                        else if (name.includes('right') && name.includes('thigh')) bones.rightUpLeg = child;
                        else if (name.includes('right') && name.includes('leg')) bones.rightLeg = child;
                    }
                });

                if (Object.keys(bones).length > 0) {
                    safeSetText('bone-status', "(âœ…)");
                }

                scene.add(model);
                applyPose('flat');
                
                document.getElementById('welcome').style.display = 'none';
                document.getElementById('ui').style.display = 'block';
                createGhostHand();
                setPhase(1);
            });
        }

        // ========== å§¿å‹¢æ§åˆ¶ï¼ˆä¿æŒä¸è®Šï¼‰==========
        function onSliderChange() {
            const lThighEl = document.getElementById('range-left-thigh');
            if (!lThighEl) return;
            poseControls.leftThigh = parseFloat(lThighEl.value);
            updatePose();
            safeSetText('val-left-thigh', Math.round(poseControls.leftThigh) + 'Â°');
        }

        function updatePose() {
            if (bones.leftUpLeg) bones.leftUpLeg.rotation.x = THREE.MathUtils.degToRad(poseControls.leftThigh);
            if (bones.leftLeg) bones.leftLeg.rotation.x = THREE.MathUtils.degToRad(poseControls.leftKnee);
            if (bones.rightUpLeg) bones.rightUpLeg.rotation.x = THREE.MathUtils.degToRad(poseControls.rightThigh);
            if (bones.rightLeg) bones.rightLeg.rotation.x = THREE.MathUtils.degToRad(poseControls.rightKnee);
        }

        function applyPose(poseName) {
            const pose = POSES[poseName];
            if (!pose) return;
            
            document.querySelectorAll('.pose-btn').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`btn-pose-${poseName}`);
            if (activeBtn) activeBtn.classList.add('active');
            
            gsap.to(poseControls, {
                leftThigh: pose.leftThigh,
                leftKnee: pose.leftKnee,
                rightThigh: pose.rightThigh,
                rightKnee: pose.rightKnee,
                duration: 0.5,
                onUpdate: updatePose
            });
        }

        function toggleCameraLock() {
            if (renderer.xr.isPresenting) return;
            isCameraLocked = !isCameraLocked;
            controls.enabled = !isCameraLocked;
        }

        function toggleMenu() {
            const menu = document.getElementById('side-menu');
            if (menu) menu.classList.toggle('show');
        }

        // ========== æ•™å­¸æ­¥é©Ÿï¼ˆä¿æŒä¸è®Šï¼‰==========
        function setPhase(p) {
            currentPhase = p;
            currentStepIndex = 0;
            document.querySelectorAll('.phase-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('p' + p);
            if (btn) btn.classList.add('active');
            if (btn) safeSetText('phase-title', btn.innerText);
            setupStep();
        }

        function setupStep() {
            interactables.forEach(obj => scene.remove(obj));
            interactables = [];
            if (tweenAnim) tweenAnim.kill();
            if (ghostHand) ghostHand.visible = false;

            const step = learningData[currentPhase][currentStepIndex];
            safeSetText('step-num', step.id);
            safeSetText('action-text', step.text);
            safeSetText('action-note', step.note);
            safeSetText('current-tool-icon', step.icon);

            if (step.pose) applyPose(step.pose);
            else applyPose('flat');

            vrHitStatus = {
                isTouchingStart: false,
                touchStartTime: 0,
                activeHand: null
            };

            if (step.type === 'drag') {
                const startObj = createInteractable(step.start, 'ğŸŸ¢', 'start');
                startObj.userData.isStart = true;
                const endObj = createInteractable(step.end, 'ğŸ', 'end', true);
                endObj.userData.isEnd = true;
                showGhostGuide(step.start, step.end, true);
            } else {
                createInteractable(step.pos, step.icon, 'click');
                showGhostGuide(step.pos, step.pos, false);
            }
            
            updateVRDebug(
                `ğŸ“ ${step.text}`,
                step.note,
                '',
                'ğŸ¯ ä¼¸å‡ºé£ŸæŒ‡é–‹å§‹'
            );
        }

        function createInteractable(pos, icon, type, isHidden = false) {
            const group = new THREE.Group();
            group.position.set(
                pos.x + model.position.x,
                pos.y + model.position.y + 0.1,
                pos.z + model.position.z
            );

            const map = createEmojiTexture(icon);
            const iconMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(0.5, 0.5),
                new THREE.MeshBasicMaterial({ map: map, transparent: true, depthTest: false })
            );
            
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.22, 0.26, 32),
                new THREE.MeshBasicMaterial({
                    color: 0x667eea,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7,
                    depthTest: false
                })
            );
            
            const hitBox = new THREE.Mesh(
                new THREE.SphereGeometry(VR_CONFIG.DETECTION_RADIUS, 16, 16),
                new THREE.MeshBasicMaterial({ visible: false })
            );

            group.add(iconMesh);
            group.add(ring);
            group.add(hitBox);
            
            if (isHidden) group.visible = false;

            scene.add(group);
            interactables.push(group);

            gsap.to(iconMesh.scale, { x: 1.2, y: 1.2, duration: 0.8, yoyo: true, repeat: -1 });

            group.tick = () => {
                iconMesh.lookAt(camera.position);
                ring.lookAt(camera.position);
            };
            
            return group;
        }

        function createEmojiTexture(emoji) {
            const c = document.createElement('canvas');
            c.width = 128; c.height = 128;
            const ctx = c.getContext('2d');
            ctx.font = '100px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, 64, 64);
            return new THREE.CanvasTexture(c);
        }

        function createGhostHand() {
            const texture = createEmojiTexture('âœ‹');
            const geometry = new THREE.PlaneGeometry(0.5, 0.5);
            const material = new THREE.MeshBasicMaterial({
                map: texture, transparent: true, opacity: 0.8,
                depthTest: false, side: THREE.DoubleSide
            });
            ghostHand = new THREE.Mesh(geometry, material);
            ghostHand.renderOrder = 999;
            scene.add(ghostHand);
            ghostHand.visible = false;
        }

        function showGhostGuide(startRel, endRel, isMove) {
            if (!ghostHand) return;
            ghostHand.visible = true;
            const start = {
                x: startRel.x + model.position.x,
                y: startRel.y + model.position.y + 0.2,
                z: startRel.z + model.position.z
            };
            
            if (isMove) {
                const end = {
                    x: endRel.x + model.position.x,
                    y: endRel.y + model.position.y + 0.2,
                    z: endRel.z + model.position.z
                };
                ghostHand.position.set(start.x, start.y, start.z);
                tweenAnim = gsap.timeline({ repeat: -1, repeatDelay: 1 });
                tweenAnim.to(ghostHand.position, {
                    x: end.x, y: end.y, z: end.z,
                    duration: 1.5, ease: "power2.inOut"
                }).to(ghostHand.material, { opacity: 0, duration: 0.5 });
            } else {
                ghostHand.position.set(start.x, start.y + 0.2, start.z);
                tweenAnim = gsap.to(ghostHand.position, {
                    y: start.y, duration: 0.8, yoyo: true, repeat: -1
                });
            }
        }

        function nextStep() {
            const list = learningData[currentPhase];
            if (currentStepIndex < list.length - 1) {
                currentStepIndex++;
                setupStep();
            } else {
                if (renderer.xr.isPresenting) {
                    updateVRDebug(
                        `ğŸ‰ éšæ®µ ${currentPhase} å®Œæˆ`,
                        learningData[currentPhase + 1] ? 'é€²å…¥ä¸‹ä¸€éšæ®µ' : 'å®Œæˆæ‰€æœ‰ç™‚ç¨‹'
                    );
                }
                
                if (learningData[currentPhase + 1]) {
                    setTimeout(() => setPhase(currentPhase + 1), 2000);
                } else {
                    setTimeout(() => setPhase(1), 2000);
                }
            }
        }

        function prevStep() {
            if (currentStepIndex > 0) {
                currentStepIndex--;
                setupStep();
            }
        }

        function forceComplete() { nextStep(); }

        // ========== äº‹ä»¶è™•ç†ï¼ˆä¿æŒä¸è®Šï¼‰==========
        function onTouchStart(e) { e.preventDefault(); onPointerDown(e.touches[0]); }
        function onTouchMove(e) { e.preventDefault(); onPointerMove(e.touches[0]); }

        function onPointerDown(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(interactables, true);
            if (intersects.length > 0) {
                isDragging = true;
                controls.enabled = false;
                checkIntersection();
            } else {
                controls.enabled = true;
            }
        }

        function onPointerMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            if (isDragging) {
                raycaster.setFromCamera(mouse, camera);
                checkIntersection();
            }
        }

        function onPointerUp() {
            if (isDragging) {
                checkIntersection();
                isDragging = false;
                if (!isCameraLocked) controls.enabled = true;
                if (ghostHand) ghostHand.visible = false;
            }
        }

        function resetCam() {
            if (!renderer.xr.isPresenting) {
                controls.reset();
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
