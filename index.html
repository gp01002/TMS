<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>è‰¾æŸåœ‹éš›èŠ³ç™‚ - æ²‰æµ¸å¼ç‘å…¸æŒ‰æ‘© VR æ•™å­¸ (V10.0 å¢å¼·ç‰ˆ)</title>
    <!-- å¼•å…¥æ ¸å¿ƒåº« -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: #1a1a1a;
            overflow: hidden;
            touch-action: none;
        }
        
        /* --- UI å±¤ --- */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* é ‚éƒ¨è³‡è¨Šåˆ— */
        .top-bar {
            position: absolute; top: 0; left: 0; width: 100%;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            padding: 15px 25px; color: white; display: flex; justify-content: space-between;
            align-items: center; pointer-events: auto;
        }

        /* ğŸ†• é€²åº¦æ¢ */
        .progress-bar {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            width: 80%; max-width: 500px; height: 6px; background: rgba(255,255,255,0.1);
            border-radius: 10px; overflow: hidden; pointer-events: auto;
        }
        .progress-fill {
            height: 100%; background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%; transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(118, 75, 162, 0.6);
        }
        .progress-text {
            position: absolute; top: 70px; left: 50%; transform: translateX(-50%);
            color: #8ec5fc; font-size: 12px; text-align: center;
        }

        /* å·¦å´é¸å–® */
        .side-menu {
            position: absolute; left: 20px; top: 100px; width: 300px;
            background: rgba(30, 30, 30, 0.95); backdrop-filter: blur(10px);
            border-radius: 15px; padding: 15px; border: 1px solid rgba(255,255,255,0.1);
            pointer-events: auto; max-height: calc(100vh - 140px); overflow-y: auto;
            transform: translateX(-360px); transition: transform 0.3s ease; 
            z-index: 20;
        }
        .side-menu.show { transform: translateX(0); }
        
        .menu-title { 
            color: #8ec5fc; font-size: 14px; margin-bottom: 10px; font-weight: bold; 
            letter-spacing: 1px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; 
            cursor: pointer;
        }
        
        .phase-btn {
            display: block; width: 100%; padding: 12px; margin-bottom: 8px;
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px; color: #ccc; text-align: left; cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        .phase-btn:hover { background: rgba(255,255,255,0.1); }
        .phase-btn.active { 
            background: linear-gradient(90deg, #667eea, #764ba2); 
            color: white; border: none; box-shadow: 0 4px 12px rgba(118, 75, 162, 0.4);
        }

        /* å¾®èª¿æ»‘æ¡¿ */
        .debug-section { display: none; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; margin-bottom: 15px; }
        .adjust-row { margin-bottom: 12px; }
        .adjust-label { font-size: 12px; color: #ff6b6b; display: flex; justify-content: space-between; margin-bottom: 4px; font-weight: bold; }
        .adjust-input { width: 100%; cursor: pointer; accent-color: #ff6b6b; }
        
        /* éª¨éª¼æ§åˆ¶å€ */
        .pose-section { display: block; background: rgba(102, 126, 234, 0.2); padding: 12px; border-radius: 8px; margin-bottom: 15px; border: 1px solid rgba(102, 126, 234, 0.3); }
        .pose-label { font-size: 11px; color: #8ec5fc; display: flex; justify-content: space-between; margin-bottom: 3px; }
        .pose-input { width: 100%; cursor: pointer; accent-color: #667eea; height: 20px; }
        .pose-btn {
            padding: 8px 12px; margin: 4px 2px; background: rgba(102, 126, 234, 0.3);
            border: 1px solid rgba(102, 126, 234, 0.5); border-radius: 6px;
            color: #8ec5fc; font-size: 11px; cursor: pointer; transition: all 0.2s;
        }
        .pose-btn:hover { background: rgba(102, 126, 234, 0.5); }
        .pose-btn.active { background: #667eea; color: white; }

        /* åº•éƒ¨æ“ä½œå¡ç‰‡ */
        .action-card {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(30, 30, 30, 0.9); backdrop-filter: blur(10px);
            padding: 20px 30px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center; width: 90%; max-width: 500px;
            pointer-events: auto;
            transition: all 0.3s ease;
        }
        
        .instruction-title { color: #8ec5fc; font-size: 12px; font-weight: bold; margin-bottom: 5px; text-transform: uppercase; }
        .instruction-text { color: #fff; font-size: 20px; font-weight: bold; margin-bottom: 8px; }
        .instruction-note { color: #aaa; font-size: 14px; margin-bottom: 15px; line-height: 1.5; }

        .nav-btn {
            background: #444; color: white; border: none; padding: 8px 16px;
            border-radius: 20px; cursor: pointer; margin: 0 5px; font-weight: bold;
            font-size: 14px; display: inline-flex; align-items: center; gap: 5px;
        }
        .nav-btn:hover { background: #555; }
        .nav-btn.primary { background: #667eea; }
        
        .lock-btn { background: #444; border: 1px solid #666; }
        .lock-btn.locked {
            background: #ff6b6b; border: 1px solid #ff4444;
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
        }

        /* ğŸ†• æ‹–æ›³æç¤ºå¢å¼· */
        .gesture-hint {
            position: absolute;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 15px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            transform: translate(-50%, -100%);
            white-space: nowrap;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5); }
            50% { box-shadow: 0 4px 25px rgba(102, 126, 234, 0.8); }
        }
        
        /* å‹•ä½œèªªæ˜æ¨™ç±¤ */
        .action-label {
             position: absolute;
             background: rgba(0,0,0,0.8);
             color: #FFD700;
             padding: 6px 12px;
             border-radius: 6px;
             font-size: 13px;
             font-weight: bold;
             pointer-events: none;
             white-space: nowrap;
             z-index: 99;
             display: none;
             box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }

        /* æ­¡è¿/è¼‰å…¥é  */
        .welcome-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d1b3d 100%);
            z-index: 1000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white;
            text-align: center;
            padding: 20px;
        }
        .main-title {
            font-size: 40px; font-weight: bold; color: #8ec5fc; 
            margin-bottom: 10px; letter-spacing: 2px;
            text-shadow: 0 0 20px rgba(142, 197, 252, 0.5);
        }
        .start-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white; border: none; padding: 15px 50px;
            font-size: 20px; border-radius: 50px; margin-top: 30px;
            cursor: pointer; box-shadow: 0 0 30px rgba(118, 75, 162, 0.6);
            transition: all 0.3s;
        }
        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(118, 75, 162, 0.8);
        }
        .loading-spinner {
            border: 4px solid rgba(255,255,255,0.1); border-left-color: #667eea;
            border-radius: 50%; width: 40px; height: 40px;
            animation: spin 1s linear infinite; margin-top: 20px; display: none;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* ğŸ†• æˆåŠŸç‰¹æ•ˆ */
        .success-badge {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #11998e, #38ef7d);
            color: white;
            padding: 30px 50px;
            border-radius: 20px;
            font-size: 32px;
            font-weight: bold;
            pointer-events: none;
            z-index: 200;
            box-shadow: 0 10px 40px rgba(17, 153, 142, 0.6);
        }

        /* --- æ‰‹æ©Ÿç‰ˆ RWD å„ªåŒ– --- */
        @media (max-width: 768px) {
            .top-bar { padding: 10px 15px; }
            .top-bar span { font-size: 16px !important; }
            
            .progress-bar { top: 55px; width: 90%; }
            .progress-text { top: 65px; font-size: 11px; }
            
            .side-menu {
                width: 240px; 
                top: 80px;
                left: 10px;
                padding: 10px;
                max-height: calc(100vh - 200px);
            }
            .menu-title { font-size: 13px; }
            .phase-btn { padding: 10px; font-size: 13px; }
            
            .action-card {
                bottom: 20px;
                padding: 15px 20px;
                width: 95%;
            }
            .instruction-text { font-size: 18px; }
            .instruction-note { font-size: 13px; margin-bottom: 10px; }
            
            .nav-btn {
                padding: 6px 12px;
                font-size: 13px;
            }
        }
    </style>
</head>
<body>

    <div class="welcome-overlay" id="welcome">
        <div class="main-title">è‰¾æŸåœ‹éš›èŠ³ç™‚</div>
        <h1 style="font-size: 28px; margin-bottom: 10px;">ğŸ¤² å°ˆæ¥­èŠ³ç™‚ VR æ•™å­¸</h1>
        <p style="color: #aaa;">æ²‰æµ¸å¼äº’å‹•ç‰ˆ v10.0 (å¢å¼·ç‰ˆ)</p>
        <p style="color: #8ec5fc; margin-top: 10px; font-size: 14px;">âœ¨ æ–°å¢è»Œè·¡ç·šã€ç²’å­æ•ˆæœã€è§¸è¦ºåé¥‹</p>
        <button class="start-btn" onclick="initApp()">é–‹å§‹ç™‚ç¨‹</button>
        <div class="loading-spinner" id="spinner"></div>
    </div>

    <div id="canvas-container" style="width:100vw; height:100vh;"></div>

    <div class="ui-layer" id="ui" style="display:none;">
        <div class="top-bar">
            <div style="font-weight: bold; font-size: 18px; display:flex; align-items:center; gap:10px;">
                <span style="font-size:24px;" id="current-tool-icon">ğŸ¤š</span>
                <span id="phase-title">éšæ®µä¸€ï¼šæº–å‚™èˆ‡èµ·å§‹</span>
            </div>
            
            <div style="display:flex; gap:10px;">
                <button class="nav-btn lock-btn" id="lock-btn" onclick="toggleCameraLock()">ğŸ”“ é–å®šè¦–è§’</button>
                <button class="nav-btn" onclick="toggleMenu()">â˜°</button>
            </div>
        </div>

        <!-- ğŸ†• é€²åº¦æ¢ -->
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
        <div class="progress-text" id="progress-text">é€²åº¦: 0%</div>

        <div class="side-menu" id="side-menu">
            <div class="pose-section" id="pose-panel">
                <div class="menu-title" style="color:#8ec5fc; border-color:#8ec5fc;">
                    ğŸ¦´ è…¿éƒ¨å§¿å‹¢æ§åˆ¶ <span id="bone-status" style="font-size:10px; color:#aaa;">(åµæ¸¬ä¸­...)</span>
                </div>
                
                <div style="margin-bottom:8px;">
                    <button class="pose-btn" id="btn-pose-flat" onclick="applyPose('flat')">å¹³èºº</button>
                    <button class="pose-btn" id="btn-pose-leftRaised" onclick="applyPose('leftRaised')">å·¦è…¿æŠ¬èµ·</button>
                    <button class="pose-btn" id="btn-pose-rightRaised" onclick="applyPose('rightRaised')">å³è…¿æŠ¬èµ·</button>
                </div>
                
                <div class="adjust-row">
                    <div class="pose-label"><span>å·¦å¤§è…¿æŠ¬èµ·</span> <span id="val-left-thigh">0Â°</span></div>
                    <input type="range" class="pose-input" id="range-left-thigh" min="-90" max="45" step="1" value="0" oninput="onSliderChange()">
                </div>
            </div>
            
            <div id="structure-message" style="color: #f44336; font-size: 12px; margin-bottom: 10px; display: none;">
                âš ï¸ æ³¨æ„ï¼šæ­¤æ¨¡å‹ä¼¼ä¹æ²’æœ‰éª¨æ¶ï¼Œå§¿å‹¢æ§åˆ¶ç„¡æ³•ç”Ÿæ•ˆã€‚
            </div>

            <div class="menu-title" onclick="triggerDebugMode()">ç™‚ç¨‹éšæ®µé¸å–®</div>
            <button class="phase-btn active" onclick="setPhase(1)" id="p1">1. æº–å‚™èˆ‡èµ·å§‹å®‰æ’«</button>
            <button class="phase-btn" onclick="setPhase(2)" id="p2">2. å·¦è…¿æŒ‰æ‘©æ“ä½œ</button>
            <button class="phase-btn" onclick="setPhase(3)" id="p3">3. å³è…¿æŒ‰æ‘©æ“ä½œ</button>
            <button class="phase-btn" onclick="setPhase(4)" id="p4">4. çµå°¾èˆ‡å®‰æ’«</button>
            
            <div class="menu-title" style="margin-top:20px;">ä¸€èˆ¬è¨­å®š</div>
            <button class="phase-btn" onclick="resetCam()">ğŸ”„ é‡ç½®è¦–è§’</button>
            <button class="phase-btn" onclick="toggleModel()">ğŸ‘¤ åˆ‡æ›æ¨¡ç‰¹å…’</button>
            
            <div class="debug-section" id="debug-panel">
                 <div class="menu-title" style="color:#ff6b6b;">ğŸ”§ å·¥ç¨‹å¾®èª¿</div>
                 <div class="adjust-row">
                    <div class="adjust-label"><span>å‰å¾Œ (X)</span> <span id="val-x">0</span></div>
                    <input type="range" class="adjust-input" id="range-x" min="-5" max="5" step="0.05" oninput="updateModelPos()">
                 </div>
            </div>
        </div>

        <div class="gesture-hint" id="gesture-hint">ğŸ‘† æŒ‰ä½ä¸¦æ‹–æ›³</div>
        <div class="action-label" id="action-label">è·Ÿéš¨æ‰‹éƒ¨</div>

        <div class="action-card">
            <div class="instruction-title">STEP <span id="step-num">1.1</span></div>
            <div class="instruction-text" id="action-text">è¼‰å…¥ä¸­...</div>
            <div class="instruction-note" id="action-note">è·Ÿéš¨æ‰‹éƒ¨æŒ‡å¼•æ“ä½œ</div>
            
            <div style="display:flex; justify-content: center; gap:10px;">
                <button class="nav-btn" onclick="prevStep()">ä¸Šä¸€æ­¥</button>
                <button class="nav-btn primary" onclick="forceComplete()">è·³é</button>
            </div>
        </div>

        <!-- ğŸ†• æˆåŠŸç‰¹æ•ˆ -->
        <div class="success-badge" id="success-badge">å®Œæˆï¼âœ¨</div>
    </div>

    <script>
        const BASE_URL = "https://gp01002.github.io/TMS/";

        const MODEL_CONFIG = {
            male: { pos: { x: 0.1, y: 2.2, z: 0 }, scale: 1.0, rot: { x: -1.57, y: 0, z: 1.57 } },
            female: { pos: { x: 0.1, y: 2.18, z: 0 }, scale: 1.0, rot: { x: -1.57, y: 0, z: 1.57 } }
        };
        
        const LEFT_LEG_Z = 0.12;  
        const RIGHT_LEG_Z = -0.12;
        
        const COORDS = {
            THIGH_ROOT: -3.3, THIGH_MID: -2.4, KNEE: -1.5, CALF_MID: -0.7, ANKLE: 0.1, FOOT: 0.3            
        };

        let CONFIG = {
            MODEL_POS_DEFAULT: { ...MODEL_CONFIG.male.pos }, 
            MODEL_SCALE: MODEL_CONFIG.male.scale,
            MODEL_ROT_DEFAULT: { ...MODEL_CONFIG.male.rot }, 
            COORDS: COORDS,
            LEFT_LEG_Z: LEFT_LEG_Z,
            RIGHT_LEG_Z: RIGHT_LEG_Z
        };

        const learningData = {
            1: [
                { id: "1.1", text: "æ¯›å·¾ç®¡ç†èˆ‡é–‹å ´", note: "é»æ“Šå¤§è…¿æ ¹éƒ¨ï¼Œå°‡æ¯›å·¾æ²å¥½ã€‚", type: "click", tool: "towel", icon: "TOWEL_ICON", pos: {x: CONFIG.COORDS.THIGH_ROOT, y: -0.25, z: 0} },
                { id: "1.2", text: "å‡å‹»ä¸Šæ²¹", note: "æŒ‰å£“è†è“‹è™•ï¼Œå–æ²¹æº–å‚™ã€‚", type: "press", tool: "oil", icon: "ğŸ§´", pos: {x: CONFIG.COORDS.KNEE, y: 0.2, z: 0}, duration: 2 },
                { id: "1.3", text: "é–‹å ´å¤§å®‰æ’«", note: "æŒ‰ä½è…³åº•ï¼Œæ»‘å‹•è‡³å¤§è…¿æ ¹éƒ¨ã€‚", type: "drag", tool: "hand", icon: "âœ¨", start: {x: CONFIG.COORDS.FOOT, y: -0.35, z: CONFIG.LEFT_LEG_Z}, end: {x: CONFIG.COORDS.THIGH_ROOT, y: -0.2, z: CONFIG.LEFT_LEG_Z} },
                { id: "1.4", text: "å³è…³ä¿æš–", note: "é»æ“Šå³è†ï¼Œè“‹ä¸Šæ¯›å·¾ã€‚", type: "click", tool: "towel", icon: "TOWEL_ICON", pos: {x: CONFIG.COORDS.KNEE, y: -0.2, z: CONFIG.RIGHT_LEG_Z} }
            ],
            2: [
                { id: "2.1", text: "å¤§è…¿ï¼šæ‹‡æŒ‡ä½µæ’é•·æ¨", note: "å¾è†è“‹å¾Œæ–¹ï¼Œæ¨å‘å¤§è…¿æ ¹éƒ¨ã€‚", type: "drag", tool: "hand", icon: "ğŸ‘", start: {x: CONFIG.COORDS.KNEE, y: -0.25, z: CONFIG.LEFT_LEG_Z}, end: {x: CONFIG.COORDS.THIGH_ROOT, y: -0.2, z: CONFIG.LEFT_LEG_Z} },
                { id: "2.2", text: "åˆ†æ®µæ’¥æ", note: "åœ¨å¤§è…¿ä¸­æ®µé€²è¡Œæ’¥æå‹•ä½œã€‚", type: "drag", tool: "hand", icon: "ğŸ¤", start: {x: CONFIG.COORDS.THIGH_MID, y: -0.25, z: CONFIG.LEFT_LEG_Z}, end: {x: CONFIG.COORDS.THIGH_ROOT, y: -0.2, z: CONFIG.LEFT_LEG_Z} },
                { id: "2.3", text: "Så‹æŠ“æ", note: "ç”±å…§å´å‘å¤–å´æŠ“æã€‚", type: "drag", tool: "hand", icon: "ã€°ï¸", start: {x: CONFIG.COORDS.THIGH_MID, y: -0.2, z: CONFIG.LEFT_LEG_Z - 0.1}, end: {x: CONFIG.COORDS.THIGH_MID, y: -0.2, z: CONFIG.LEFT_LEG_Z + 0.1} },
                { id: "2.4", text: "å°è…¿ï¼šé•·æ¨è‡³å§”ä¸­ç©´", note: "å¾è…³è¸æ¨è‡³è†è“‹å¾Œæ–¹ã€‚", type: "drag", tool: "hand", icon: "ğŸ¦µ", start: {x: CONFIG.COORDS.ANKLE, y: -0.3, z: CONFIG.LEFT_LEG_Z}, end: {x: CONFIG.COORDS.KNEE, y: -0.25, z: CONFIG.LEFT_LEG_Z} },
                { id: "2.5", text: "ä¸‰ç·šå¼ç¶“çµ¡æŒ‰å£“", note: "æ²¿å°è…¿ä¸­ç·šæ»‘å‹•ã€‚", type: "drag", tool: "hand", icon: "ğŸ“Š", start: {x: CONFIG.COORDS.CALF_MID, y: -0.3, z: CONFIG.LEFT_LEG_Z - 0.05}, end: {x: CONFIG.COORDS.KNEE, y: -0.25, z: CONFIG.LEFT_LEG_Z - 0.05} },
                { id: "2.6", text: "æº–å‚™å§¿å‹¢ï¼šæŠ¬è…¿90åº¦", note: "é»æ“Šè…³è¸ï¼Œå°‡è…¿æŠ¬èµ·ã€‚", type: "click", tool: "hand", icon: "ğŸ¦¶", pos: {x: CONFIG.COORDS.FOOT, y: -0.3, z: CONFIG.LEFT_LEG_Z}, pose: "leftRaised" },
                { id: "2.7", text: "æ¹§æ³‰ç©´ç•«åœˆ", note: "æŒ‰å£“æ¹§æ³‰ç©´ä¸¦ç•«åœˆã€‚", type: "press", tool: "hand", icon: "â­•", pos: {x: CONFIG.COORDS.FOOT + 0.05, y: 0.2, z: CONFIG.LEFT_LEG_Z}, duration: 3, pose: "leftRaised" },
                { id: "2.8", text: "åŠæ¡æ‹³æ»‘æ¨", note: "å¾è…³è¸æ»‘å‘è…³è¶¾ã€‚", type: "drag", tool: "hand", icon: "ğŸ¤›", start: {x: CONFIG.COORDS.ANKLE, y: 0.2, z: CONFIG.LEFT_LEG_Z}, end: {x: CONFIG.COORDS.FOOT + 0.1, y: 0.2, z: CONFIG.LEFT_LEG_Z}, pose: "leftRaised" },
                { id: "2.9", text: "éœå¿ƒæŒ‰å£“ (10ç§’)", note: "æŒ‰ä½è…³å¿ƒï¼Œä¿æŒ 10 ç§’ã€‚", type: "press", tool: "hand", icon: "â±ï¸", pos: {x: CONFIG.COORDS.FOOT + 0.05, y: 0.2, z: CONFIG.LEFT_LEG_Z}, duration: 10, pose: "leftRaised" },
                { id: "2.10", text: "è“‹ä¸Šæ¯›å·¾", note: "é»æ“Šè†è“‹ï¼Œè“‹ä¸Šæ¯›å·¾ã€‚", type: "click", tool: "towel", icon: "TOWEL_ICON", pos: {x: CONFIG.COORDS.KNEE, y: -0.1, z: CONFIG.LEFT_LEG_Z}, pose: "flat" }
            ],
            3: [
                { id: "3.1", text: "å³è…¿ï¼šé–‹å§‹æµç¨‹", note: "é»æ“Šå³è…³è¸é–‹å§‹ã€‚", type: "click", tool: "hand", icon: "â–¶ï¸", pos: {x: CONFIG.COORDS.ANKLE, y: -0.3, z: CONFIG.RIGHT_LEG_Z} },
                { id: "3.2", text: "å³è…¿ï¼šé•·æ¨èˆ‡æŒ‰å£“", note: "æ¨¡æ“¬å³è…¿é•·æ¨å‹•ä½œã€‚", type: "drag", tool: "hand", icon: "ğŸ‘", start: {x: CONFIG.COORDS.KNEE, y: -0.25, z: CONFIG.RIGHT_LEG_Z}, end: {x: CONFIG.COORDS.THIGH_ROOT, y: -0.2, z: CONFIG.RIGHT_LEG_Z} },
                { id: "3.10", text: "è“‹ä¸Šæ¯›å·¾", note: "é»æ“Šå³è†ï¼Œå®Œæˆå³è…¿ã€‚", type: "click", tool: "towel", icon: "TOWEL_ICON", pos: {x: CONFIG.COORDS.KNEE, y: -0.1, z: CONFIG.RIGHT_LEG_Z}, pose: "flat" }
            ],
            4: [
                { id: "4.1", text: "æ•´åˆèˆ‡å®‰æ’«", note: "é›™æ‰‹å¾è…³åº•æ»‘è‡³å¤§è…¿ã€‚", type: "drag", tool: "hand", icon: "âœ¨", start: {x: CONFIG.COORDS.FOOT, y: -0.35, z: 0}, end: {x: CONFIG.COORDS.THIGH_ROOT, y: -0.2, z: 0} },
                { id: "4.2", text: "å®Œæˆç™‚ç¨‹", note: "é»æ“Šè“‹ä¸Šå¤§æ¯›å·¾ã€‚", type: "click", tool: "towel", icon: "ğŸ", pos: {x: CONFIG.COORDS.KNEE, y: -0.1, z: 0} }
            ]
        };

        let scene, camera, renderer, controls, model;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let interactables = []; 
        let currentPhase = 1;
        let currentStepIndex = 0;
        let isDragging = false;
        let isCameraLocked = false; 
        let ghostHand; 
        let tweenAnim;
        let activeModelType = 'male';
        let skeletonHelper;
        
        // ğŸ†• è»Œè·¡ç·šå’Œç²’å­ç³»çµ±
        let trailLine = null;
        let trailPoints = [];
        let particleSystem = null;

        let modelPos = { ...MODEL_CONFIG.male.pos };
        let modelRot = { ...MODEL_CONFIG.male.rot };
        let modelScale = MODEL_CONFIG.male.scale;
        let debugClickCount = 0;

        let bones = { leftUpLeg: null, leftLeg: null, rightUpLeg: null, rightLeg: null };
        let poseControls = { leftThigh: 0, leftKnee: 0, leftAnkle: 45, rightThigh: 0, rightKnee: 0, rightAnkle: 45 };
        const POSES = {
            flat: { leftThigh: 0, leftKnee: 0, leftAnkle: 45, rightThigh: 0, rightKnee: 0, rightAnkle: 45 },
            leftRaised: { leftThigh: -45, leftKnee: -90, leftAnkle: 45, rightThigh: 0, rightKnee: 0, rightAnkle: 45 },
            rightRaised: { leftThigh: 0, leftKnee: 0, leftAnkle: 45, rightThigh: -45, rightKnee: -90, rightAnkle: 45 }
        };

        // --- DOM Helpers ---
        function safeSetValue(id, value) { const el = document.getElementById(id); if (el) el.value = value; }
        function safeSetText(id, text) { const el = document.getElementById(id); if (el) el.innerText = text; }
        function safeGetFloat(id, defaultValue) { const el = document.getElementById(id); return el ? parseFloat(el.value) : defaultValue; }

        // ğŸ†• è§¸è¦ºåé¥‹ï¼ˆæŒ¯å‹•ï¼‰
        function hapticFeedback(pattern = [50]) {
            if (navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }

        // ğŸ†• é¡¯ç¤ºæˆåŠŸç‰¹æ•ˆ
        function showSuccessBadge() {
            const badge = document.getElementById('success-badge');
            if (!badge) return;
            
            gsap.to(badge, {
                scale: 1,
                duration: 0.3,
                ease: "back.out(2)",
                onComplete: () => {
                    setTimeout(() => {
                        gsap.to(badge, { scale: 0, duration: 0.2 });
                    }, 1000);
                }
            });
        }

        // ğŸ†• æ›´æ–°é€²åº¦æ¢
        function updateProgress() {
            const totalSteps = Object.values(learningData).reduce((sum, phase) => sum + phase.length, 0);
            let completedSteps = 0;
            
            for (let i = 1; i < currentPhase; i++) {
                completedSteps += learningData[i].length;
            }
            completedSteps += currentStepIndex;
            
            const percentage = Math.round((completedSteps / totalSteps) * 100);
            
            const fill = document.getElementById('progress-fill');
            const text = document.getElementById('progress-text');
            if (fill) fill.style.width = percentage + '%';
            if (text) text.innerText = `é€²åº¦: ${percentage}% (${completedSteps}/${totalSteps})`;
        }

        // ğŸ†• å‰µå»ºè»Œè·¡ç·š
        function createTrailLine() {
            if (trailLine) scene.remove(trailLine);
            
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.LineBasicMaterial({
                color: 0x667eea,
                linewidth: 3,
                transparent: true,
                opacity: 0.8
            });
            
            trailLine = new THREE.Line(geometry, material);
            trailLine.frustumCulled = false;
            scene.add(trailLine);
            trailPoints = [];
        }

        // ğŸ†• æ›´æ–°è»Œè·¡ç·š
        function updateTrailLine(position) {
            if (!trailLine) return;
            
            trailPoints.push(position.clone());
            
            // é™åˆ¶é»æ•¸é¿å…æ•ˆèƒ½å•é¡Œ
            if (trailPoints.length > 50) {
                trailPoints.shift();
            }
            
            const positions = new Float32Array(trailPoints.length * 3);
            trailPoints.forEach((point, i) => {
                positions[i * 3] = point.x;
                positions[i * 3 + 1] = point.y;
                positions[i * 3 + 2] = point.z;
            });
            
            trailLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            trailLine.geometry.attributes.position.needsUpdate = true;
        }

        // ğŸ†• æ¸…é™¤è»Œè·¡ç·š
        function clearTrailLine() {
            if (trailLine) {
                scene.remove(trailLine);
                trailLine = null;
                trailPoints = [];
            }
        }

        // ğŸ†• å‰µå»ºç²’å­æ•ˆæœ
        function createParticles(position) {
            const particleCount = 30;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                velocities.push({
                    x: (Math.random() - 0.5) * 0.05,
                    y: Math.random() * 0.08,
                    z: (Math.random() - 0.5) * 0.05
                });
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0x667eea,
                size: 0.05,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            // å‹•ç•«ç²’å­
            let frame = 0;
            const animate = () => {
                frame++;
                const positions = particleSystem.geometry.attributes.position.array;
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] += velocities[i].x;
                    positions[i * 3 + 1] += velocities[i].y;
                    positions[i * 3 + 2] += velocities[i].z;
                    velocities[i].y -= 0.002; // é‡åŠ›
                }
                
                particleSystem.geometry.attributes.position.needsUpdate = true;
                particleSystem.material.opacity -= 0.02;
                
                if (frame < 50 && particleSystem.material.opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    scene.remove(particleSystem);
                    particleSystem = null;
                }
            };
            animate();
        }

        function initApp() {
            document.getElementById('spinner').style.display = 'block';
            document.querySelector('.start-btn').style.display = 'none';
            setTimeout(initThreeJS, 100);
            
            safeSetValue('range-x', modelPos.x);
            updateDebugLabels();
        }
        
        function triggerDebugMode() {
            debugClickCount++;
            if(debugClickCount >= 5) {
                const panel = document.getElementById('debug-panel');
                if(panel) { panel.style.display = 'block'; alert("ğŸ”§ å·¥ç¨‹æ¨¡å¼å·²å•Ÿç”¨"); }
                debugClickCount = 0;
            }
        }

        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 5, 15);
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            
            const spotLight = new THREE.SpotLight(0xffeeb1, 1.5);
            spotLight.position.set(2, 6, 2);
            spotLight.castShadow = true;
            scene.add(spotLight);
            
            scene.add(new THREE.DirectionalLight(0xaaccff, 0.5));

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);
            camera.position.set(1.5, 2.5, 2.5);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 6;
            controls.minDistance = 0.3; 
            
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onPointerDown);
            canvas.addEventListener('mousemove', onPointerMove);
            canvas.addEventListener('mouseup', onPointerUp);
            canvas.addEventListener('touchstart', onTouchStart, {passive: false});
            canvas.addEventListener('touchmove', onTouchMove, {passive: false});
            canvas.addEventListener('touchend', onPointerUp);
            window.addEventListener('resize', onWindowResize);

            renderer.setAnimationLoop(() => {
                controls.update();
                interactables.forEach(obj => { if(obj.tick) obj.tick(); });
                
                if (ghostHand && ghostHand.visible) {
                    ghostHand.lookAt(camera.position);
                    const label = document.getElementById('action-label');
                    if(label) {
                        const vector = ghostHand.position.clone();
                        vector.y += 0.3;
                        vector.project(camera);
                        const x = (vector.x * .5 + .5) * window.innerWidth;
                        const y = (-(vector.y * .5) + .5) * window.innerHeight;
                        if(vector.z < 1 && x > 0 && x < window.innerWidth && y > 0 && y < window.innerHeight) {
                            label.style.display = 'block';
                            label.style.left = `${x}px`;
                            label.style.top = `${y}px`;
                            label.style.transform = 'translate(-50%, -50%)';
                        } else {
                            label.style.display = 'none';
                        }
                    }
                } else {
                    const label = document.getElementById('action-label');
                    if(label) label.style.display = 'none';
                }
                
                renderer.render(scene, camera);
            });

            loadEnvironment();
        }

        function loadEnvironment() {
            const loader = new THREE.GLTFLoader();
            loader.load(BASE_URL + 'A01.glb', (gltf) => {
                const room = gltf.scene;
                room.scale.set(20, 20, 20);
                room.traverse(c => { if(c.isMesh) c.receiveShadow = true; });
                scene.add(room);
            });
            loadModel('male');
        }

        function toggleModel() {
            const newType = activeModelType === 'male' ? 'female' : 'male';
            loadModel(newType);
        }

        function loadModel(type) {
            if(model) scene.remove(model);
            if(skeletonHelper) scene.remove(skeletonHelper);
            
            activeModelType = type;
            const config = MODEL_CONFIG[type];
            modelPos = { ...config.pos };
            modelRot = { ...config.rot };
            modelScale = config.scale;
            updateDebugLabels();

            const loader = new THREE.GLTFLoader();
            loader.load(BASE_URL + (type === 'male' ? 'B01.glb' : 'B02.glb'), (gltf) => {
                model = gltf.scene;
                model.position.set(modelPos.x, modelPos.y, modelPos.z);
                model.scale.set(modelScale, modelScale, modelScale);
                model.rotation.set(modelRot.x, modelRot.y, modelRot.z);
                
                model.traverse(child => {
                    if(child.isMesh) { 
                        child.castShadow = true; 
                        child.receiveShadow = true; 
                        if(child.material) {
                            child.material = new THREE.MeshStandardMaterial({
                                color: child.material.color, map: child.material.map, skinning: true, roughness: 0.5, metalness: 0.1
                            });
                        }
                    }
                });

                bones = {};
                const boneNames = { leftUpLeg: ['leftupleg'], leftLeg: ['leftleg'], rightUpLeg: ['rightupleg'], rightLeg: ['rightleg'] };
                model.traverse(child => {
                    if(child.isBone) {
                        const name = child.name.toLowerCase().replace(/[^a-z0-9]/g, '');
                        if(name.includes('left') && (name.includes('up') || name.includes('thigh'))) bones.leftUpLeg = child;
                        else if(name.includes('left') && (name.includes('leg') || name.includes('calf') || name.includes('shin'))) bones.leftLeg = child;
                        else if(name.includes('right') && (name.includes('up') || name.includes('thigh'))) bones.rightUpLeg = child;
                        else if(name.includes('right') && (name.includes('leg') || name.includes('calf') || name.includes('shin'))) bones.rightLeg = child;
                    }
                });

                if(Object.keys(bones).length > 0) {
                     document.getElementById('bone-status').innerText = "(âœ…)";
                     document.getElementById('pose-panel').style.display = "block";
                }

                scene.add(model);
                applyPose('flat'); 
                
                document.getElementById('welcome').style.display = 'none';
                document.getElementById('ui').style.display = 'block';
                createGhostHand();
                setPhase(1);
                updateProgress();
            });
        }
        
        function onSliderChange() {
            const lThighEl = document.getElementById('range-left-thigh');
            if (!lThighEl) return;
            poseControls.leftThigh = parseFloat(lThighEl.value);
            syncUIand3D();
        }

        function updatePose() {
            if (bones.leftUpLeg) bones.leftUpLeg.rotation.x = THREE.MathUtils.degToRad(poseControls.leftThigh);
        }

        function syncUIand3D() {
            updatePose();
            safeSetText('val-left-thigh', Math.round(poseControls.leftThigh) + 'Â°');
        }

        function applyPose(poseName) {
            const pose = POSES[poseName];
            if (!pose) return;
            
            document.querySelectorAll('.pose-btn').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`btn-pose-${poseName}`);
            if(activeBtn) activeBtn.classList.add('active');
            
            gsap.to(poseControls, {
                leftThigh: pose.leftThigh,
                leftKnee: pose.leftKnee,
                leftAnkle: pose.leftAnkle,
                rightThigh: pose.rightThigh,
                rightKnee: pose.rightKnee,
                rightAnkle: pose.rightAnkle,
                duration: 0.5,
                onUpdate: syncUIand3D 
            });
        }
        
        function updateModelPos() {
            modelPos.x = safeGetFloat('range-x', modelPos.x);
            if (model) { model.position.set(modelPos.x, modelPos.y, modelPos.z); setupStep(); }
        }

        function updateDebugLabels() { safeSetText('val-x', modelPos.x.toFixed(2)); }

        function toggleCameraLock() {
            isCameraLocked = !isCameraLocked;
            controls.enabled = !isCameraLocked;
            const btn = document.getElementById('lock-btn');
            if (isCameraLocked) { 
                btn.innerHTML = 'ğŸ”’'; 
                btn.classList.add('locked'); 
                showHint(window.innerWidth/2, 100, "è¦–è§’å·²å›ºå®š");
                hapticFeedback([50]);
            } 
            else { btn.innerHTML = 'ğŸ”“'; btn.classList.remove('locked'); }
        }

        function toggleMenu() {
            const menu = document.getElementById('side-menu');
            if(menu) menu.classList.toggle('show');
        }

        function createTowelTexture() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d'); ctx.fillStyle='#eee'; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }

        function createEmojiTexture(emoji) {
            const c = document.createElement('canvas'); c.width=128; c.height=128;
            const ctx = c.getContext('2d'); ctx.font='100px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(emoji,64,64);
            return new THREE.CanvasTexture(c);
        }

        function createInteractable(pos, icon, type, isHidden = false) {
            const group = new THREE.Group();
            group.position.set(pos.x + model.position.x, pos.y + model.position.y + 0.1, pos.z + model.position.z);

            const map = icon === 'TOWEL_ICON' ? createTowelTexture() : createEmojiTexture(icon);
            const iconMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 0.4), new THREE.MeshBasicMaterial({ map: map, transparent: true, depthTest: false }));
            iconMesh.userData = { isIcon: true };
            
            // ğŸ†• å¢å¼·å…‰ç’°æ•ˆæœ
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.18, 0.22, 32), 
                new THREE.MeshBasicMaterial({ 
                    color: 0x667eea, 
                    side: THREE.DoubleSide, 
                    transparent: true, 
                    opacity: 0.8, 
                    depthTest: false 
                })
            );
            
            const hitBox = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), new THREE.MeshBasicMaterial({ visible: false }));
            hitBox.userData = { isHitBox: true, type: type };

            group.add(iconMesh); group.add(ring); group.add(hitBox);
            if (isHidden) group.visible = false;

            scene.add(group);
            interactables.push(group);

            // ğŸ†• å¢å¼·å‹•ç•«æ•ˆæœ
            gsap.to(iconMesh.scale, { x: 1.3, y: 1.3, duration: 0.6, yoyo: true, repeat: -1, ease: "power1.inOut" });
            gsap.to(ring.scale, { x: 1.2, y: 1.2, duration: 1.2, yoyo: true, repeat: -1, ease: "sine.inOut" });
            if (icon === 'TOWEL_ICON') gsap.to(group.position, { y: group.position.y + 0.15, duration: 1, yoyo: true, repeat: -1 });

            group.tick = () => { iconMesh.lookAt(camera.position); ring.lookAt(camera.position); };
            return group;
        }

        function createGhostHand() {
            const texture = createEmojiTexture('âœ‹');
            const geometry = new THREE.PlaneGeometry(0.6, 0.6); // ğŸ†• ç¨å¾®æ”¾å¤§
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true, 
                opacity: 0.9, // ğŸ†• æé«˜ä¸é€æ˜åº¦
                depthTest: false, 
                side: THREE.DoubleSide 
            });
            ghostHand = new THREE.Mesh(geometry, material);
            ghostHand.renderOrder = 999;
            
            // ğŸ†• æ·»åŠ å…‰æšˆæ•ˆæœ
            const glowGeometry = new THREE.PlaneGeometry(0.8, 0.8);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x667eea,
                transparent: true,
                opacity: 0.3,
                depthTest: false,
                side: THREE.DoubleSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            ghostHand.add(glow);
            
            scene.add(ghostHand);
            ghostHand.visible = false;
        }

        function setPhase(p) {
            currentPhase = p; currentStepIndex = 0;
            document.querySelectorAll('.phase-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('p'+p);
            if(btn) btn.classList.add('active');
            if(btn) document.getElementById('phase-title').innerText = btn.innerText;
            setupStep();
            updateProgress();
        }

        function autoFocusCamera(step) {
            if (isCameraLocked) return;
            let targetPos = new THREE.Vector3();
            if (step.type === 'drag') {
                targetPos.set((step.start.x + step.end.x)/2 + model.position.x, (step.start.y + step.end.y)/2 + model.position.y, (step.start.z + step.end.z)/2 + model.position.z);
            } else if (step.pos) {
                targetPos.set(step.pos.x + model.position.x, step.pos.y + model.position.y, step.pos.z + model.position.z);
            } else { return; }
            gsap.to(controls.target, { x: targetPos.x, y: targetPos.y, z: targetPos.z, duration: 1.5, ease: "power2.inOut" });
        }

        function setupStep() {
            interactables.forEach(obj => scene.remove(obj));
            interactables = [];
            if(tweenAnim) tweenAnim.kill();
            if(ghostHand) ghostHand.visible = false;
            clearTrailLine(); // ğŸ†• æ¸…é™¤èˆŠè»Œè·¡

            const step = learningData[currentPhase][currentStepIndex];
            document.getElementById('step-num').innerText = step.id;
            document.getElementById('action-text').innerText = step.text;
            document.getElementById('action-note').innerText = step.note;
            document.getElementById('current-tool-icon').innerText = step.icon === 'TOWEL_ICON' ? 'â¬œ' : step.icon;
            
            const label = document.getElementById('action-label');
            if(step.type === 'drag') label.innerText = "æŒ‰ä½ä¸¦æ‹–æ›³ â¡";
            else if(step.type === 'click') label.innerText = "é»æ“Šé€™è£¡ ğŸ‘‡";
            else if(step.type === 'press') label.innerText = "é•·æŒ‰ â±ï¸";

            if (step.pose) applyPose(step.pose); else applyPose('flat');

            if (step.type === 'drag') {
                const startObj = createInteractable(step.start, 'ğŸŸ¢', 'start');
                startObj.userData.isStart = true;
                const endObj = createInteractable(step.end, 'ğŸ', 'end', true);
                endObj.userData.isEnd = true;
                showGhostGuide(step.start, step.end, true);
            } else {
                createInteractable(step.pos, step.icon, 'click');
                showGhostGuide(step.pos, step.pos, false);
            }
            autoFocusCamera(step);
            updateProgress();
        }

        function showGhostGuide(startRel, endRel, isMove) {
            if(!ghostHand) return;
            ghostHand.visible = true;
            ghostHand.material.opacity = 0.9;
            const start = { x: startRel.x + model.position.x, y: startRel.y + model.position.y + 0.2, z: startRel.z + model.position.z };
            
            if (isMove) {
                const end = { x: endRel.x + model.position.x, y: endRel.y + model.position.y + 0.2, z: endRel.z + model.position.z };
                ghostHand.position.set(start.x, start.y, start.z);
                tweenAnim = gsap.timeline({repeat: -1, repeatDelay: 1});
                tweenAnim.to(ghostHand.position, { x: end.x, y: end.y, z: end.z, duration: 1.5, ease: "power2.inOut" })
                         .to(ghostHand.material, { opacity: 0.3, duration: 0.5 })
                         .to(ghostHand.material, { opacity: 0.9, duration: 0.3 });
            } else {
                ghostHand.position.set(start.x, start.y + 0.2, start.z);
                tweenAnim = gsap.to(ghostHand.position, { y: start.y, duration: 0.8, yoyo: true, repeat: -1 });
            }
        }

        function onTouchStart(e) { e.preventDefault(); onPointerDown(e.touches[0]); }
        function onTouchMove(e) { e.preventDefault(); onPointerMove(e.touches[0]); }

        function onPointerDown(e) {
            updateMouse(e);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactables, true);

            if (intersects.length > 0) {
                let targetGroup = intersects[0].object;
                while(targetGroup.parent && targetGroup.parent.type !== 'Scene') targetGroup = targetGroup.parent;

                const step = learningData[currentPhase][currentStepIndex];

                if (step.type === 'drag' && targetGroup.userData.isStart) {
                    isDragging = true;
                    controls.enabled = false;
                    if(ghostHand) ghostHand.visible = false; 
                    const endObj = interactables.find(obj => obj.userData.isEnd);
                    if(endObj) endObj.visible = true;
                    
                    // ğŸ†• å‰µå»ºè»Œè·¡ç·š
                    createTrailLine();
                    
                    showHint(e.clientX, e.clientY, "æ»‘å‹•è‡³çµ‚é» ğŸ");
                    hapticFeedback([30]); // ğŸ†• è§¸è¦ºåé¥‹
                } 
                else if (step.type === 'press' || step.type === 'click') {
                    gsap.to(targetGroup.scale, {x: 1.5, y:1.5, z:1.5, duration: 0.2, yoyo: true, repeat: 1});
                    showHint(e.clientX, e.clientY, "å®Œæˆï¼âœ¨");
                    hapticFeedback([50, 50]); // ğŸ†• é›™é‡æŒ¯å‹•
                    
                    // ğŸ†• é¡¯ç¤ºç²’å­æ•ˆæœ
                    createParticles(targetGroup.position);
                    
                    setTimeout(() => { 
                        showSuccessBadge();
                        nextStep(); 
                    }, 1200);
                }
            }
        }

        function onPointerMove(e) {
            updateMouse(e);
            const hint = document.getElementById('gesture-hint');
            if(hint && hint.style.opacity == 1) {
                hint.style.left = e.clientX + 'px';
                hint.style.top = (e.clientY - 30) + 'px';
            }

            if (isDragging) {
                raycaster.setFromCamera(mouse, camera);
                // ä½¿ç”¨ Plane æ“´å¤§åˆ¤å®šå€åŸŸ
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -model.position.y);
                const point = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, point);
                
                if (point) {
                    if(ghostHand) {
                        ghostHand.visible = true;
                        ghostHand.position.copy(point);
                        ghostHand.position.y += 0.2;
                        
                        // ğŸ†• æ›´æ–°è»Œè·¡ç·š
                        updateTrailLine(ghostHand.position);
                        
                        const step = learningData[currentPhase][currentStepIndex];
                        const endPos = new THREE.Vector3(step.end.x + model.position.x, step.end.y + model.position.y, step.end.z + model.position.z);
                        
                        const distance = ghostHand.position.distanceTo(endPos);
                        
                        // ğŸ†• è·é›¢æç¤ºï¼ˆé¡è‰²æ¼¸è®Šï¼‰
                        if (distance < 1.0 && trailLine) {
                            const progress = Math.max(0, 1 - distance);
                            trailLine.material.color.setHex(progress > 0.7 ? 0x38ef7d : 0x667eea);
                        }
                        
                        // ğŸ†• æ”¾å¯¬åˆ¤å®šè·é›¢ (ç”± 0.6 æ”¹ç‚º 0.7)
                        if (distance < 0.7) {
                            isDragging = false;
                            if (!isCameraLocked) controls.enabled = true;
                            showHint(e.clientX, e.clientY, "å®Œç¾ï¼ğŸ‰");
                            hapticFeedback([100]); // ğŸ†• å¼·åŠ›æŒ¯å‹•
                            
                            // ğŸ†• é¡¯ç¤ºæˆåŠŸæ•ˆæœ
                            createParticles(endPos);
                            clearTrailLine();
                            
                            setTimeout(() => { 
                                showSuccessBadge();
                                nextStep(); 
                            }, 1200);
                        }
                    }
                }
            }
        }

        function onPointerUp() {
            // é›™é‡åˆ¤å®šï¼šç¢ºä¿åœ¨æ”¾é–‹æ™‚ä¹Ÿèƒ½æª¢æ¸¬æ˜¯å¦åˆ°é”çµ‚é»
            if (isDragging) {
                if(ghostHand && ghostHand.visible) {
                     const step = learningData[currentPhase][currentStepIndex];
                     const endPos = new THREE.Vector3(step.end.x + model.position.x, step.end.y + model.position.y, step.end.z + model.position.z);
                     if (ghostHand.position.distanceTo(endPos) < 0.9) { // ğŸ†• æ”¾é–‹æ™‚åˆ¤å®šæ›´å¯¬é¬†
                        isDragging = false;
                        if (!isCameraLocked) controls.enabled = true;
                        showHint(window.innerWidth/2, window.innerHeight/2, "å®Œç¾ï¼ğŸ‰");
                        hapticFeedback([100]);
                        
                        createParticles(endPos);
                        clearTrailLine();
                        
                        setTimeout(() => { 
                            showSuccessBadge();
                            nextStep(); 
                        }, 1200);
                        return;
                     }
                }

                isDragging = false;
                if (!isCameraLocked) controls.enabled = true;
                if(ghostHand) ghostHand.visible = false;
                const hint = document.getElementById('gesture-hint');
                if(hint) hint.style.opacity = 0;
                
                clearTrailLine(); // ğŸ†• æ¸…é™¤æœªå®Œæˆçš„è»Œè·¡
                
                const endObj = interactables.find(obj => obj.userData.isEnd);
                if(endObj) endObj.visible = false;
                
                const step = learningData[currentPhase][currentStepIndex];
                showGhostGuide(step.start, step.end, true);
            }
        }

        function nextStep() {
            const list = learningData[currentPhase];
            if (currentStepIndex < list.length - 1) {
                currentStepIndex++;
                setupStep();
            } else {
                hapticFeedback([200, 100, 200]); // ğŸ†• å®Œæˆéšæ®µæŒ¯å‹•
                alert(`ğŸ‰ éšæ®µ ${currentPhase} å®Œæˆï¼`);
                if (learningData[currentPhase + 1]) {
                    setPhase(currentPhase + 1);
                } else {
                    alert("ğŸ† æ­å–œå®Œæˆæ‰€æœ‰ç™‚ç¨‹ï¼");
                    updateProgress();
                }
            }
        }
        
        function prevStep() { 
            if (currentStepIndex > 0) { 
                currentStepIndex--; 
                setupStep(); 
            } else if (currentPhase > 1) {
                setPhase(currentPhase - 1);
                currentStepIndex = learningData[currentPhase].length - 1;
                setupStep();
            }
        }
        
        function forceComplete() { nextStep(); }
        function updateMouse(e) { mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1; }
        function showHint(x, y, msg) {
            const el = document.getElementById('gesture-hint');
            if(!el) return;
            el.innerText = msg; el.style.left = x + 'px'; el.style.top = (y - 30) + 'px'; el.style.opacity = 1;
            if(msg.includes("å®Œæˆ") || msg.includes("å®Œç¾")) setTimeout(() => el.style.opacity = 0, 1500);
        }
        function resetCam() { 
            controls.reset(); 
            hapticFeedback([50]);
        }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
    </script>
</body>
</html>
