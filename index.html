<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‰¾æŸåœ‹éš›èŠ³ç™‚ - VRç³»çµ± (æ•‘æ´ç‰ˆ)</title>
    <!-- å¼•å…¥ GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- å¼•å…¥ Three.js æ ¸å¿ƒèˆ‡å¤–æ› -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: #333; /* èƒŒæ™¯æ”¹æ·±è‰² */
            overflow: hidden;
        }
        .game-container { width: 100vw; height: 100vh; position: relative; }
        
        /* æ­¡è¿ç•«é¢ */
        .welcome-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000; transition: opacity 0.5s;
        }
        .welcome-screen.hidden { opacity: 0; pointer-events: none; }
        .enter-btn {
            background: white; color: #667eea; border: none; padding: 15px 40px; font-size: 20px;
            border-radius: 50px; cursor: pointer; font-weight: bold; margin-top: 20px;
        }

        /* ä»‹é¢å±¤ */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        .pointer-events-auto { pointer-events: auto; }

        .status-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(255,255,255,0.9); padding: 10px 30px; border-radius: 50px;
            font-weight: bold; color: #333;
        }

        .control-panel {
            position: absolute; left: 20px; top: 80px; width: 280px;
            background: rgba(255,255,255,0.9); border-radius: 15px; padding: 15px;
            max-height: 80vh; overflow-y: auto; pointer-events: auto;
        }
        
        .info-panel {
            position: absolute; right: 20px; top: 80px; width: 280px;
            background: rgba(255,255,255,0.9); border-radius: 15px; padding: 15px;
            pointer-events: auto;
        }

        .btn {
            display: block; width: 100%; padding: 10px; margin-bottom: 5px;
            border: 1px solid #ccc; background: white; border-radius: 8px; cursor: pointer;
        }
        .btn.active { background: #667eea; color: white; border-color: #667eea; }
        .btn:hover { transform: translateX(3px); }

        .debug-panel {
            position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.8);
            color: white; padding: 10px; border-radius: 5px; font-size: 12px; pointer-events: auto;
        }
        .debug-row { margin-bottom: 5px; }
        .debug-row input { width: 150px; }

        /* Loading */
        .loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 20px; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            pointer-events: none; display: none;
        }
        .loading.show { display: block; }

        /* Feedback */
        .feedback {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7); color: white; padding: 20px; border-radius: 10px;
            font-size: 24px; opacity: 0; pointer-events: none; transition: opacity 0.3s;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <!-- Canvas æ›è¼‰é» -->
        <div id="canvas-container" style="width:100%; height:100%; background:#000;"></div>

        <!-- æ­¡è¿é  -->
        <div class="welcome-screen" id="welcome-screen">
            <h1 style="color:white; margin-bottom:10px;">VR è™›æ“¬æ²»ç™‚ç³»çµ±</h1>
            <p style="color:white;">(æ•‘æ´æ¨¡å¼ï¼šå·²å•Ÿç”¨é ç«¯è³‡æº)</p>
            <button class="enter-btn" onclick="startGame()">é€²å…¥ç³»çµ±</button>
        </div>

        <!-- UI å±¤ -->
        <div class="ui-layer" id="ui-layer" style="display:none;">
            <div class="status-bar">ğŸ¥ è‰¾æŸåœ‹éš›é†«ç™‚ç©ºé–“ (A01)</div>

            <div class="control-panel">
                <h3>ğŸ‘¥ é¸æ“‡æ¨¡ç‰¹å…’</h3>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px; margin-bottom:15px;">
                    <button class="btn" onclick="loadModel('male')">ğŸ‘¨ ç”·æ€§</button>
                    <button class="btn" onclick="loadModel('female')">ğŸ‘© å¥³æ€§</button>
                </div>

                <h3>ğŸ–ï¸ æ²»ç™‚æ‰‹æ³•</h3>
                <button class="btn technique-btn" onclick="setTechnique(1)">æ¨æ’«æ³• Effleurage</button>
                <button class="btn technique-btn" onclick="setTechnique(2)">æ‰ææ³• Petrissage</button>
                <button class="btn technique-btn" onclick="setTechnique(3)">æ‘©æ“¦æ³• Friction</button>
                <button class="btn technique-btn" onclick="setTechnique(4)">å©æ“Šæ³• Tapotement</button>
            </div>

            <div class="info-panel">
                <h3>ğŸ“Š æ²»ç™‚ç‹€æ³</h3>
                <p>æŒ‰å£“æ¬¡æ•¸ï¼š<span id="hits">0</span></p>
                <p>æº–ç¢ºåº¦ï¼š<span id="acc">0%</span></p>
                <div style="background:#ddd; height:10px; border-radius:5px; margin-top:5px;">
                    <div id="progress-bar" style="background:#4CAF50; height:100%; width:0%; border-radius:5px;"></div>
                </div>
            </div>

            <!-- Debug é¢æ¿ï¼šå·²èª¿æ•´é è¨­å€¼è‡³ 3.0 -->
            <div class="debug-panel">
                <div style="margin-bottom:5px; color:#aaa;">ğŸ”§ æ¨¡ç‰¹å…’ä½ç½®å¾®èª¿</div>
                <div class="debug-row">Yè»¸é«˜åº¦: <span id="val-y">3.00</span></div>
                <!-- âœ¨ é€™è£¡å°‡é è¨­å€¼æ”¹ç‚º 3.00 -->
                <input type="range" id="range-y" min="-5" max="10" step="0.05" value="3.00" oninput="updateHeight(this.value)">
                <div style="margin-top:5px;">
                    <button style="padding:2px 5px;" onclick="resetCam()">é‡ç½®è¦–è§’</button>
                </div>
            </div>

            <div class="loading" id="loading-text">è¼‰å…¥ä¸­...</div>
            <div class="feedback" id="feedback-text"></div>
        </div>
    </div>

    <script>
        // è¨­å®š GitHub Pages çš„åŸºç¤è·¯å¾‘ï¼Œç¢ºä¿è·¨åŸŸä¹Ÿèƒ½è®€å–
        const BASE_URL = "https://gp01002.github.io/TMS/";

        // ğŸš¨ å…¨åŸŸéŒ¯èª¤æ””æˆª
        window.onerror = function(msg, url, line, col, error) {
            console.error("Global Error:", msg, error);
            // å¿½ç•¥æŸäº›éè‡´å‘½éŒ¯èª¤
            if (msg.includes("ResizeObserver")) return false;
            alert("âš ï¸ ç™¼ç”ŸéŒ¯èª¤ï¼š\n" + msg + "\nè«‹ç¢ºèªç¶²è·¯é€£ç·šæ˜¯å¦æ­£å¸¸ã€‚");
            return false;
        };

        let scene, camera, renderer, controls, model;
        let targets = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let activeTechnique = null;
        let score = { hits: 0, total: 0 };

        function startGame() {
            document.getElementById('welcome-screen').classList.add('hidden');
            document.getElementById('ui-layer').style.display = 'block';
            
            // å»¶é²ä¸€é»é»ç¢ºä¿ DOM æº–å‚™å¥½
            setTimeout(initThreeJS, 100);
        }

        function initThreeJS() {
            try {
                const container = document.getElementById('canvas-container');
                
                // 1. å»ºç«‹å ´æ™¯
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87ceeb); // å¤©è—è‰²èƒŒæ™¯
                
                // åŠ å…¥è¼”åŠ©ç¶²æ ¼ (åœ°æ¿)
                const grid = new THREE.GridHelper(20, 20);
                scene.add(grid);

                // 2. æ”å½±æ©Ÿ
                camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 100);
                camera.position.set(0, 5, 8); // å°‡æ”å½±æ©Ÿä¹Ÿç¨å¾®æ‹‰é«˜ä¸€é»ï¼Œæ–¹ä¾¿è§€çœ‹
                camera.lookAt(0, 0, 0);

                // 3. æ¸²æŸ“å™¨
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(renderer.domElement);

                // 4. æ§åˆ¶å™¨
                if (typeof THREE.OrbitControls === 'undefined') {
                    throw new Error("OrbitControls è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·š");
                }
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;

                // 5. ç‡ˆå…‰
                const ambient = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambient);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 7);
                scene.add(dirLight);

                // 6. ç›£è½äº‹ä»¶
                window.addEventListener('resize', onWindowResize);
                renderer.domElement.addEventListener('click', onCanvasClick);

                // 7. é–‹å§‹æ¸²æŸ“è¿´åœˆ
                renderer.setAnimationLoop(animate);

                // 8. å˜—è©¦è¼‰å…¥æˆ¿é–“ (ä½¿ç”¨çµ•å°è·¯å¾‘)
                loadRoom();

            } catch (e) {
                alert("åˆå§‹åŒ–å¤±æ•—ï¼š" + e.message);
                console.error(e);
            }
        }

        function loadRoom() {
            const loader = new THREE.GLTFLoader();
            // ä½¿ç”¨çµ•å°è·¯å¾‘
            loader.load(BASE_URL + 'A01.glb', (gltf) => {
                const room = gltf.scene;
                room.scale.set(20, 20, 20);
                room.position.set(0, 0, 0);
                scene.add(room);
            }, undefined, (err) => {
                console.warn("æˆ¿é–“è¼‰å…¥å¤±æ•—ï¼Œå¯èƒ½æ˜¯ç¶²è·¯å•é¡Œæˆ–æª”æ¡ˆè·¯å¾‘éŒ¯èª¤ã€‚", err);
            });
        }

        function loadModel(type) {
            if (model) {
                scene.remove(model);
                targets.forEach(t => scene.remove(t));
                targets = [];
            }

            document.getElementById('loading-text').classList.add('show');
            const fileName = type === 'male' ? 'B01.glb' : 'B02.glb';
            // ä½¿ç”¨çµ•å°è·¯å¾‘
            const url = BASE_URL + fileName;

            const loader = new THREE.GLTFLoader();
            loader.load(url, (gltf) => {
                model = gltf.scene;
                // é è¨­ä½ç½® (ä½¿ç”¨æ»‘æ¡¿çš„å€¼)
                const y = parseFloat(document.getElementById('range-y').value);
                model.position.set(-1.2, y, 0);
                model.rotation.set(-Math.PI/2, 0, Math.PI/2);
                scene.add(model);

                // å»ºç«‹ç©´ä½é»
                createTargets(model.position);

                document.getElementById('loading-text').classList.remove('show');
                showFeedback("æ¨¡ç‰¹å…’è¼‰å…¥å®Œæˆ");
            }, undefined, (err) => {
                document.getElementById('loading-text').classList.remove('show');
                console.error("Model load error:", err);
                alert("æ¨¡ç‰¹å…’è¼‰å…¥å¤±æ•—: " + fileName + "\nè«‹ç¢ºèªæª”æ¡ˆæ˜¯å¦å­˜åœ¨æ–¼ GitHub ä¸”ç¶²è·¯é€£ç·šæ­£å¸¸ã€‚");
            });
        }

        function createTargets(basePos) {
            // å»ºç«‹ 3 å€‹äº’å‹•çƒ
            const positions = [
                {x: 0, y: 0.3, z: -0.6}, // è‚©é ¸
                {x: 0, y: 0.35, z: 0},   // èƒŒ
                {x: 0, y: 0.3, z: 0.8}   // è…¿
            ];

            const geo = new THREE.SphereGeometry(0.2, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });

            positions.forEach(p => {
                const ball = new THREE.Mesh(geo, mat.clone());
                // è¨ˆç®—çµ•å°ä½ç½®
                ball.position.set(basePos.x + p.x, basePos.y + p.y, basePos.z + p.z);
                
                // åŠ å…¥å‘¼å¸ç‡ˆå‹•ç•«
                gsap.to(ball.material, { opacity: 0.1, duration: 0.8, yoyo: true, repeat: -1 });
                
                scene.add(ball);
                targets.push(ball);
            });
        }

        function updateHeight(val) {
            document.getElementById('val-y').innerText = val;
            if (model) {
                model.position.y = parseFloat(val);
                // æ›´æ–°çƒçš„ä½ç½®
                if (targets.length > 0) {
                    targets.forEach(t => scene.remove(t));
                    targets = [];
                    createTargets(model.position);
                }
            }
        }

        function setTechnique(id) {
            activeTechnique = id;
            document.querySelectorAll('.technique-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.technique-btn')[id-1].classList.add('active');
            showFeedback("å·²é¸æ“‡æ‰‹æ³•");
        }

        function onCanvasClick(e) {
            if (!activeTechnique) {
                showFeedback("âš ï¸ è«‹å…ˆé¸æ“‡æ‰‹æ³•ï¼");
                return;
            }

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // æª¢æŸ¥æ˜¯å¦é»åˆ°çƒ
            const intersects = raycaster.intersectObjects(targets);
            if (intersects.length > 0) {
                // æˆåŠŸ
                score.hits++;
                score.total++;
                playEffect(intersects[0].object.position, true);
                showFeedback("âœ¨ å®Œç¾æŒ‰å£“ï¼", true);
            } else if (model) {
                // æª¢æŸ¥æ˜¯å¦é»åˆ°äºº
                const hitsModel = raycaster.intersectObject(model, true);
                if (hitsModel.length > 0) {
                    score.total++;
                    playEffect(hitsModel[0].point, false);
                    showFeedback("âŒ ä½ç½®ä¸å°", false);
                }
            }
            updateUI();
        }

        function playEffect(pos, isSuccess) {
            const color = isSuccess ? 0xffff00 : 0xff0000;
            const eff = new THREE.Mesh(
                new THREE.RingGeometry(0.1, 0.2, 32),
                new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide })
            );
            eff.position.copy(pos);
            eff.position.y += 0.05;
            eff.rotation.x = -Math.PI/2;
            scene.add(eff);
            
            gsap.to(eff.scale, { x:2, y:2, opacity:0, duration:0.5, onComplete:()=>scene.remove(eff)});
        }

        function updateUI() {
            document.getElementById('hits').innerText = score.hits;
            const acc = score.total === 0 ? 0 : Math.round((score.hits / score.total) * 100);
            document.getElementById('acc').innerText = acc + "%";
            document.getElementById('progress-bar').style.width = acc + "%";
        }

        function showFeedback(msg, success) {
            const el = document.getElementById('feedback-text');
            el.innerText = msg;
            el.style.opacity = 1;
            el.style.background = success === true ? "rgba(0,150,0,0.8)" : (success === false ? "rgba(200,0,0,0.8)" : "rgba(0,0,0,0.7)");
            
            clearTimeout(window.feedbackTimer);
            window.feedbackTimer = setTimeout(() => { el.style.opacity = 0; }, 1500);
        }

        function resetCam() {
            controls.reset();
        }

        function onWindowResize() {
            if(camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        function animate() {
            if (controls) controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
