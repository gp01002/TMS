<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>è‰¾æŸåœ‹éš›èŠ³ç™‚ - ç‘å…¸å¼è…¿éƒ¨æŒ‰æ‘©VRæ•™å­¸ç³»çµ± (å„ªåŒ–äº’å‹•ç‰ˆ)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            touch-action: none; /* ç¦æ­¢ç€è¦½å™¨é è¨­çš„ç¸®æ”¾èˆ‡æ»‘å‹• */
        }
        .game-container { width: 100vw; height: 100vh; position: relative; }
        
        /* æ­¡è¿ç•«é¢ */
        .welcome-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.98) 0%, rgba(118, 75, 162, 0.98) 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000; transition: opacity 0.5s;
        }
        .welcome-screen.hidden { opacity: 0; pointer-events: none; }
        .welcome-content { text-align: center; color: white; padding: 40px; }
        .welcome-content h1 { font-size: 48px; margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .welcome-content p { font-size: 18px; margin-bottom: 30px; line-height: 1.8; }
        
        .enter-btn {
            background: white; color: #667eea; border: none; padding: 20px 60px; 
            font-size: 24px; border-radius: 50px; cursor: pointer; font-weight: bold; 
            margin: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); transition: all 0.3s;
        }
        .enter-btn:hover { transform: translateY(-5px) scale(1.05); box-shadow: 0 15px 40px rgba(0,0,0,0.4); }

        /* ä»‹é¢å±¤ */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }

        .status-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(255,255,255,0.95); padding: 15px 40px; border-radius: 50px;
            font-weight: bold; color: #333; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: flex; gap: 20px; align-items: center; pointer-events: auto;
        }

        /* å·¦å´é¢æ¿ */
        .control-panel {
            position: absolute; left: 20px; top: 90px; width: 280px;
            background: rgba(255,255,255,0.98); border-radius: 20px; padding: 20px;
            max-height: calc(100vh - 120px); overflow-y: auto; pointer-events: auto;
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
        }
        
        /* å³å´é¢æ¿ */
        .learning-panel {
            position: absolute; right: 20px; top: 90px; width: 360px;
            background: rgba(255,255,255,0.98); border-radius: 20px; padding: 25px;
            pointer-events: auto; box-shadow: 0 8px 30px rgba(0,0,0,0.3);
            max-height: calc(100vh - 120px); overflow-y: auto;
        }

        .phase-btn {
            display: block; width: 100%; padding: 15px; margin-bottom: 10px;
            border: 2px solid #e0e0e0; background: white; border-radius: 12px; 
            cursor: pointer; text-align: left; font-weight: bold; transition: all 0.3s;
            font-size: 14px;
        }
        .phase-btn:hover { 
            background: linear-gradient(90deg, #f0f0f0, #fafafa); 
            transform: translateX(5px); border-color: #667eea;
        }
        .phase-btn.active { 
            background: linear-gradient(135deg, #667eea, #764ba2); 
            color: white; border: none; 
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .step-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-left: 5px solid #667eea;
            padding: 20px; margin-bottom: 20px; border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .step-number { 
            font-size: 16px; color: #667eea; font-weight: bold; 
            margin-bottom: 8px; display: flex; align-items: center; gap: 8px;
        }
        .step-desc { 
            font-size: 20px; font-weight: bold; margin-bottom: 10px; 
            color: #333; line-height: 1.4;
        }
        .step-note { 
            font-size: 14px; color: #555; line-height: 1.6; 
            background: white; padding: 10px; border-radius: 8px;
            margin-top: 10px;
        }
        
        .technique-tag {
            display: inline-block; background: #667eea; color: white;
            padding: 6px 15px; border-radius: 20px; font-size: 13px;
            margin-top: 10px; font-weight: bold;
        }
        
        .interaction-tag {
            display: inline-block; background: #11998e; color: white;
            padding: 6px 15px; border-radius: 20px; font-size: 13px;
            margin-top: 10px; margin-left: 8px; font-weight: bold;
        }

        .nav-btn {
            background: linear-gradient(135deg, #667eea, #764ba2); 
            color: white; border: none; padding: 12px 25px;
            border-radius: 30px; cursor: pointer; font-size: 16px; 
            font-weight: bold; transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        /* æ‹–æ›³æç¤º */
        .drag-hint {
            position: absolute;
            background: rgba(102, 126, 234, 0.95);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 160;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            white-space: nowrap;
        }
        .drag-hint.show { opacity: 1; }
        
        /* æŒ‰å£“é€²åº¦åœˆ */
        .press-circle {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            z-index: 150;
        }
        .press-circle.show { opacity: 1; }
        .press-fill {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 4px solid #11998e;
            border-top-color: transparent;
            border-right-color: transparent;
            transform: rotate(0deg);
            transition: transform 0.1s linear;
        }

        .loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; font-weight: bold; 
            text-shadow: 0 2px 8px rgba(0,0,0,0.8);
            pointer-events: none; display: none;
            background: rgba(0,0,0,0.7); padding: 20px 40px;
            border-radius: 15px;
        }
        .loading.show { display: block; }

        .feedback {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85); color: #fff; padding: 20px 40px; 
            border-radius: 40px; font-size: 24px; opacity: 0; 
            pointer-events: none; transition: opacity 0.3s; z-index: 200;
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
            font-weight: bold; text-align: center;
        }
        
        /* äº’å‹•æ¨¡å¼æŒ‡ç¤º */
        .interaction-mode {
            position: absolute; top: 100px; left: 50%; transform: translateX(-50%);
            background: linear-gradient(135deg, #11998e, #38ef7d);
            color: white; padding: 12px 30px; border-radius: 30px;
            font-weight: bold; font-size: 18px;
            box-shadow: 0 6px 20px rgba(17, 153, 142, 0.4);
            pointer-events: none; opacity: 0;
            transition: all 0.3s; z-index: 150;
        }
        .interaction-mode.show { opacity: 1; }

        /* Debug é¢æ¿ */
        .debug-panel {
            position: absolute; bottom: 20px; left: 20px; 
            background: rgba(0,0,0,0.9); color: white; 
            padding: 15px; border-radius: 12px; font-size: 12px; 
            pointer-events: auto; width: 260px;
            max-height: 280px; overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .debug-row { 
            margin-bottom: 8px; display: flex; 
            justify-content: space-between; align-items: center; 
        }
    </style>
</head>
<body>

    <div class="game-container">
        <div id="canvas-container" style="width:100%; height:100%; background:#000;"></div>

        <div class="welcome-screen" id="welcome-screen">
            <div class="welcome-content">
                <h1>ğŸŒ¿ è‰¾æŸåœ‹éš›èŠ³ç™‚å­¸é™¢</h1>
                <h2 style="font-size: 36px; margin-bottom: 15px;">ç‘å…¸å¼è…¿éƒ¨æŒ‰æ‘© VR æ•™å­¸ç³»çµ±</h2>
                <p style="font-size: 20px; line-height: 1.8;">
                    âœ¨ æ™ºèƒ½äº’å‹•å„ªåŒ–ç‰ˆ<br>
                    ğŸ¯ ç›´æ¥æ‹–æ›³çƒé«”å³å¯äº’å‹•ï¼Œç„¡éœ€æ‰‹å‹•é–å®š<br>
                    ğŸ“± æ”¯æ´æ‰‹æ©Ÿ/å¹³æ¿è§¸æ§æ“ä½œ
                </p>
                <button class="enter-btn" onclick="startGame()">ğŸ“ é–‹å§‹äº’å‹•è¨“ç·´</button>
            </div>
        </div>

        <div class="ui-layer" id="ui-layer" style="display:none;">
            <div class="status-bar">
                <span>ğŸ« VR å°ˆæ¥­æ•™å®¤</span>
                <span id="model-status">ğŸ‘¤ è¼‰å…¥ä¸­...</span>
            </div>
            
            <div class="interaction-mode" id="interaction-mode">ğŸ® æº–å‚™äº’å‹•</div>

            <div class="drag-hint" id="drag-hint">ğŸ‘† æŒ‰ä½ä¸¦æ²¿ç®­é ­æ‹–æ›³</div>
            
            <div class="press-circle" id="press-circle">
                <div class="press-fill" id="press-fill"></div>
            </div>

            <div class="control-panel">
                <h3 style="margin-bottom:18px; color:#667eea; font-size:18px;">ğŸ“‹ ç™‚ç¨‹éšæ®µ</h3>
                
                <button class="phase-btn active" onclick="setPhase(1)" id="p1">
                    <div style="font-size:16px;">éšæ®µä¸€</div>
                    <div style="font-size:12px; color:#888; margin-top:4px;">æº–å‚™èˆ‡èµ·å§‹å®‰æ’«</div>
                </button>
                
                <button class="phase-btn" onclick="setPhase(2)" id="p2">
                    <div style="font-size:16px;">éšæ®µäºŒ</div>
                    <div style="font-size:12px; color:#888; margin-top:4px;">å·¦è…¿æŒ‰æ‘©æ“ä½œ</div>
                </button>
                
                <hr style="margin: 20px 0; border:0; border-top:2px solid #e0e0e0;">
                
                <div style="font-size:13px; color:#555; font-weight:bold; margin-bottom:8px;">ğŸ”„ åˆ‡æ›æ¨¡ç‰¹å…’</div>
                <div style="display:flex; gap:8px;">
                    <button class="phase-btn" style="padding:10px; text-align:center; flex:1;" onclick="loadModel('male')">ğŸ‘¨ ç”·æ€§</button>
                    <button class="phase-btn" style="padding:10px; text-align:center; flex:1;" onclick="loadModel('female')">ğŸ‘© å¥³æ€§</button>
                </div>
            </div>

            <div class="learning-panel">
                <h3 style="margin-bottom:18px; color:#667eea; font-size:18px;">ğŸ“– æ“ä½œæŒ‡å¼•</h3>
                
                <div id="step-display">
                    <div class="step-card">
                        <div class="step-number" id="step-id">
                            <span>ğŸ¯</span><span>STEP 1</span>
                        </div>
                        <div class="step-desc" id="step-text">è¼‰å…¥ä¸­...</div>
                        <div class="step-note" id="step-note"></div>
                        <div id="technique-display"></div>
                    </div>
                </div>

                <div style="display:flex; gap:12px; margin-top:20px;">
                    <button class="nav-btn" style="background:#888; flex:1;" onclick="prevStep()">â¬… ä¸Šä¸€æ­¥</button>
                    <button class="nav-btn" style="flex:1;" onclick="nextStep()">ä¸‹ä¸€æ­¥ â¡</button>
                </div>
                
                <div style="display:flex; gap:12px; margin-top:12px;">
                    <button id="lock-btn-main" class="nav-btn" style="background:#4dabf7; flex:1; font-size:14px;" onclick="toggleCameraLock()">
                        ğŸ”“ é¡é ­æ§åˆ¶: è‡ªå‹•
                    </button>
                </div>
                
                <div style="margin-top:20px; padding:15px; background:#f8f9fa; border-radius:10px;">
                    <div style="font-size:13px; color:#555; margin-bottom:8px; font-weight:bold;">
                        ğŸ® æ“ä½œèªªæ˜
                    </div>
                    <div style="font-size:12px; color:#666; line-height:1.8;">
                        <strong>âœ¨ æ–°åŠŸèƒ½ï¼š</strong>ç›´æ¥é»æ“Šæˆ–æŒ‰ä½çƒé«”å³å¯äº’å‹•ï¼Œé¡é ­æœƒè‡ªå‹•æš«åœæ—‹è½‰ã€‚<br>
                        <strong>ğŸ–±ï¸ æ‹–æ›³ï¼š</strong>æŒ‰ä½ç¶ è‰²çƒé«”æ¨å‘é‡‘è‰²çƒé«”ã€‚<br>
                        <strong>ğŸ‘† é»æ“Šï¼š</strong>ç›´æ¥é»é¸äº®èµ·çš„çƒé«”ã€‚
                    </div>
                </div>
            </div>

            <div class="debug-panel">
                <div style="font-weight:bold; color:#667eea; margin-bottom:10px;">ğŸ”§ æ¨¡ç‰¹å…’ä½ç½®å¾®èª¿</div>
                <div class="debug-row">
                    <label>X (å‰å¾Œ)</label>
                    <input type="range" id="range-x" min="-3" max="3" step="0.05" value="-1.2" oninput="updatePos()">
                </div>
                <div class="debug-row">
                    <label>Y (é«˜åº¦)</label>
                    <input type="range" id="range-y" min="0" max="4" step="0.05" value="2.35" oninput="updatePos()">
                </div>
                <div class="debug-row">
                    <label>å¤§å°</label>
                    <input type="range" id="range-scale" min="0.5" max="2" step="0.1" value="1.0" oninput="updatePos()">
                </div>
                <button style="width:100%; margin-top:5px; padding:5px;" onclick="resetCam()">é‡ç½®è¦–è§’</button>
            </div>

            <div class="loading" id="loading-text">â³ è¼‰å…¥æ•™å­¸è³‡æºä¸­...</div>
            <div class="feedback" id="feedback-text"></div>
        </div>
    </div>

    <script>
        const BASE_URL = "https://gp01002.github.io/TMS/";

        const learningData = {
            1: [
                { 
                    id: "1.1", 
                    text: "åœ¨æ¯›å·¾ä¸Šä¿¯é †è‡³å¤§è…¿", 
                    note: "è¼•æŸ”åœ°å°‡é›™æ‰‹æ”¾åœ¨æ¯›å·¾ä¸Šï¼Œå¾è†è“‹è™•å‘ä¸Šä¿¯é †è‡³å¤§è…¿ã€‚", 
                    target: 'thighs', 
                    technique: "ä¿¯é †æ³• Effleurage",
                    interactionMode: "drag", 
                    dragPath: [{x: 0.5, y: -0.25, z: 0}, {x: 0.2, y: -0.25, z: 0}],
                    duration: 2 
                },
                { 
                    id: "1.2", 
                    text: "ç”±å…©å´æ»‘ä¸‹è‡³è…³åº•", 
                    note: "é›™æ‰‹æ²¿è‘—è…¿éƒ¨å…©å´ï¼Œå‘ä¸‹æ»‘è‡³è…³åº•ã€‚", 
                    target: 'feet', 
                    technique: "é•·æ¨æ³•",
                    interactionMode: "drag",
                    dragPath: [{x: 0.2, y: -0.25, z: 0}, {x: 1.0, y: -0.35, z: 0}],
                    duration: 2
                },
                { 
                    id: "1.3", 
                    text: "å°‡æ¯›å·¾æ²åœ¨é›™è…¿ä¹‹é–“", 
                    note: "å°å¿ƒåœ°å°‡æ¯›å·¾æ²èµ·ä¸¦æ”¾ç½®åœ¨é›™è…¿ä¹‹é–“ã€‚", 
                    target: 'knees', 
                    technique: "æ¯›å·¾è™•ç†",
                    interactionMode: "click"
                },
                { 
                    id: "1.4", 
                    text: "é›™è…¿ç”±é˜¿åŸºé‡Œæ–¯è…±ä¸Šæ¨", 
                    note: "å¾è…³å¾Œè·Ÿçš„é˜¿åŸºé‡Œæ–¯è…±é–‹å§‹ï¼Œé›™æ‰‹åŒæ­¥å‘ä¸Šæ¨ã€‚", 
                    target: 'legs', 
                    technique: "é›™æ‰‹åŒæ­¥é•·æ¨",
                    interactionMode: "sequence", 
                    sequence: ['feet', 'calves', 'thighs'],
                    sequenceCount: 3
                },
                { 
                    id: "1.5", 
                    text: "å°‡å³è…³è¦†è“‹", 
                    note: "ç¢ºä¿ä¿æš–ï¼Œè¦†è“‹å³è…¿ã€‚", 
                    target: 'right_leg', 
                    technique: "ä¿æš–è™•ç†",
                    interactionMode: "click"
                },
                { 
                    id: "1.6", 
                    text: "ä¸Šæ²¹", 
                    note: "æ“ç†±æŒ‰æ‘©æ²¹ã€‚", 
                    target: 'hands', 
                    technique: "æ²¹å“æº–å‚™",
                    interactionMode: "press", 
                    pressDuration: 2 
                }
            ],
            2: [
                 { 
                    id: "2.1", 
                    text: "å·¦è…¿æŒ‰æ‘©é–‹å§‹", 
                    note: "ç¢ºèªå§¿å‹¢æ­£ç¢º", 
                    target: 'feet', 
                    technique: "èµ·å§‹",
                    interactionMode: "click"
                }
            ]
        };

        let scene, camera, renderer, controls, model;
        let currentPhase = 1;
        let currentStepIndex = 0;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let targets = [];
        let isDragging = false;
        let dragStartTime = 0;
        let dragPath = [];
        let pressStartTime = 0;
        let isPressing = false;
        let sequenceProgress = 0;
        let cameraLocked = false; 
        
        // å¢åŠ ä¸€å€‹è®Šæ•¸ï¼Œè¨˜éŒ„æ˜¯å¦æ­£åœ¨äº’å‹•ä¸­ (è‡ªå‹•é–å®šç”¨)
        let isInteracting = false;

        function startGame() {
            document.getElementById('welcome-screen').classList.add('hidden');
            document.getElementById('ui-layer').style.display = 'block';
            setTimeout(initThreeJS, 100);
        }
        
        function toggleCameraLock() {
            cameraLocked = !cameraLocked;
            updateLockBtn();
            if(cameraLocked) {
                controls.enabled = false;
                showFeedback('ğŸ”’ ç•«é¢å·²æ‰‹å‹•é–å®š', true);
            } else {
                controls.enabled = true;
                showFeedback('ğŸ”“ ç•«é¢å·²è§£é–', true);
            }
        }

        function updateLockBtn() {
            const btn = document.getElementById('lock-btn-main');
            if(cameraLocked) {
                btn.innerHTML = 'ğŸ”’ ç•«é¢å·²é–å®š (é»æ­¤è§£é–)';
                btn.style.background = '#ff6b6b';
            } else {
                btn.innerHTML = 'ğŸ”“ é¡é ­æ§åˆ¶: è‡ªå‹• (é»æ­¤é–å®š)';
                btn.style.background = '#4dabf7';
            }
        }

        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            
            const grid = new THREE.GridHelper(20, 20, 0x888888, 0x444444);
            scene.add(grid);

            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(2, 3, 3);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            const ambient = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            // å¢åŠ è§¸æ§ç›£è½
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onPointerDown);
            canvas.addEventListener('mousemove', onPointerMove);
            canvas.addEventListener('mouseup', onPointerUp);
            canvas.addEventListener('touchstart', onTouchStart, {passive: false});
            canvas.addEventListener('touchmove', onTouchMove, {passive: false});
            canvas.addEventListener('touchend', onPointerUp);

            window.addEventListener('resize', onWindowResize);
            renderer.setAnimationLoop(animate);

            loadRoom();
            loadModel('male');
            setPhase(1);
        }

        function loadRoom() {
            const loader = new THREE.GLTFLoader();
            loader.load(BASE_URL + 'A01.glb', (gltf) => {
                const room = gltf.scene;
                room.scale.set(20, 20, 20);
                scene.add(room);
            });
        }

        function loadModel(type) {
            if (model) scene.remove(model);
            
            document.getElementById('loading-text').classList.add('show');
            document.getElementById('model-status').innerText = 'ğŸ‘¤ è¼‰å…¥ä¸­...';
            
            const url = BASE_URL + (type === 'male' ? 'B01.glb' : 'B02.glb');
            const loader = new THREE.GLTFLoader();
            
            loader.load(url, (gltf) => {
                model = gltf.scene;
                updatePos(); 
                model.rotation.set(-Math.PI/2, 0, Math.PI/2);
                scene.add(model);
                
                document.getElementById('model-status').innerText = 'âœ… å°±ç·’';
                updateTargets();
                document.getElementById('loading-text').classList.remove('show');
            });
        }

        function updatePos() {
            if (model) {
                const x = parseFloat(document.getElementById('range-x').value);
                const y = parseFloat(document.getElementById('range-y').value);
                const scale = parseFloat(document.getElementById('range-scale').value);
                model.position.set(x, y, 0);
                model.scale.set(scale, scale, scale);
                updateTargets();
            }
        }

        function updateTargets() {
            if (!model) return;
            targets.forEach(t => scene.remove(t));
            targets = [];

            const step = learningData[currentPhase]?.[currentStepIndex];
            if (!step) return;

            showInteractionMode(step.interactionMode);
            createInteractionTargets(step);
        }

        function createInteractionTargets(step) {
            const basePos = model.position;
            
            // è®“çƒé«”æ›´å®¹æ˜“çœ‹è¦‹çš„æè³ª
            const matParams = { 
                transparent: true, 
                opacity: 0.6, 
                depthTest: false, // é—œéµï¼šè®“çƒé«”æ°¸é é¡¯ç¤ºåœ¨æœ€ä¸Šå±¤ï¼Œä¸æœƒè¢«è…¿æ“‹ä½
                depthWrite: false
            };

            if (step.interactionMode === 'drag') {
                const path = step.dragPath;
                path.forEach((p, i) => {
                    const color = i === 0 ? 0x00ff00 : 0xffd700;
                    const ball = createBall(basePos, p, color, matParams);
                    scene.add(ball);
                    targets.push(ball);
                });
                createPathLine(path, basePos);
                
            } else if (step.interactionMode === 'sequence') {
                step.sequence.forEach((targetType, i) => {
                    const pos = getTargetPosition(targetType);
                    const color = i === sequenceProgress ? 0x00ff00 : 0xaaaaaa;
                    const ball = createBall(basePos, pos, color, matParams);
                    scene.add(ball);
                    targets.push(ball);
                });
            } else {
                // Click & Press
                const pos = getTargetPosition(step.target);
                const color = step.interactionMode === 'press' ? 0x11998e : 0x00ff00;
                const ball = createBall(basePos, pos, color, matParams);
                if(step.interactionMode === 'press') ball.scale.set(1.5,1.5,1.5);
                scene.add(ball);
                targets.push(ball);
            }
        }

        function createBall(base, offset, color, matParams) {
            const geo = new THREE.SphereGeometry(0.15, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: color, ...matParams });
            const ball = new THREE.Mesh(geo, mat);
            // ä¿®æ­£åº§æ¨™åŠ ä¸Š model çš„ä½ç½®
            ball.position.set(base.x + offset.x, base.y + offset.y, base.z + offset.z);
            ball.renderOrder = 999; // ç¢ºä¿åœ¨æœ€ä¸Šå±¤

            // å‘¼å¸ç‡ˆæ•ˆæœ
            gsap.to(ball.scale, { x: 1.3, y: 1.3, z: 1.3, duration: 0.8, yoyo: true, repeat: -1 });
            return ball;
        }

        function createPathLine(path, basePos) {
            const points = path.map(p => new THREE.Vector3(basePos.x + p.x, basePos.y + p.y, basePos.z + p.z));
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineDashedMaterial({ color: 0xffff00, dashSize: 0.1, gapSize: 0.05 });
            const line = new THREE.Line(geometry, material);
            line.computeLineDistances();
            scene.add(line);
            targets.push(line);
        }

        function getTargetPosition(type) {
            // æ ¹æ“šæ¨¡å‹èª¿æ•´åº§æ¨™ (B01/B02 èººå¹³æ™‚)
            const map = {
                'thighs': {x: 0.2, y: -0.2, z: 0},
                'feet': {x: 1.0, y: -0.3, z: 0},
                'knees': {x: 0.5, y: -0.25, z: 0},
                'legs': {x: 0.4, y: -0.25, z: 0},
                'right_leg': {x: 0.4, y: -0.25, z: -0.3},
                'calves': {x: 0.7, y: -0.28, z: 0},
                'hands': {x: 0.5, y: 0.2, z: 0}
            };
            return map[type] || {x: 0, y: 0, z: 0};
        }

        // --- æ ¸å¿ƒäº’å‹•é‚è¼¯ (æ”¯æ´æ»‘é¼ èˆ‡è§¸æ§) ---

        function onTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            onPointerDown({ clientX: touch.clientX, clientY: touch.clientY });
        }

        function onTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            onPointerMove({ clientX: touch.clientX, clientY: touch.clientY });
        }

        function onPointerDown(e) {
            updateMousePos(e);
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(targets.filter(t => t.isMesh));

            if (intersects.length > 0) {
                // ** è‡ªå‹•é–å®šæ©Ÿåˆ¶ **
                isInteracting = true;
                if(!cameraLocked) controls.enabled = false; // æš«æ™‚é—œé–‰é¡é ­æ§åˆ¶
                
                const object = intersects[0].object;
                const step = learningData[currentPhase][currentStepIndex];
                
                // è¦–è¦ºå›é¥‹
                object.material.color.setHex(0xffffff);
                setTimeout(() => {
                    object.material.color.setHex(step.interactionMode === 'sequence' && targets.indexOf(object) !== sequenceProgress ? 0xaaaaaa : 0x00ff00);
                }, 200);

                if (step.interactionMode === 'drag') {
                    isDragging = true;
                    dragStartTime = Date.now();
                    dragPath = [object.position.clone()];
                    showDragHint(e.clientX, e.clientY);
                } else if (step.interactionMode === 'press') {
                    isPressing = true;
                    pressStartTime = Date.now();
                    showPressCircle(e.clientX, e.clientY);
                    updatePressCircle();
                } else if (step.interactionMode === 'sequence') {
                    checkSequence(object);
                } else if (step.interactionMode === 'click') {
                    completeStep();
                }
            }
        }

        function onPointerMove(e) {
            updateMousePos(e);
            
            // æ¸¸æ¨™æ¨£å¼
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(targets.filter(t => t.isMesh));
            renderer.domElement.style.cursor = intersects.length > 0 ? 'pointer' : 'default';

            if (isDragging) {
                // æ›´æ–°æ‹–æ›³æç¤ºä½ç½®
                const hint = document.getElementById('drag-hint');
                hint.style.left = (e.clientX + 20) + 'px';
                hint.style.top = (e.clientY - 20) + 'px';
                
                // è¨˜éŒ„è»Œè·¡ (æŠ•å½±åˆ°å¹³é¢ä¸Š)
                const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                const targetV3 = new THREE.Vector3();
                raycaster.ray.intersectPlane(planeZ, targetV3);
                if(targetV3) dragPath.push(targetV3);
            }
        }

        function onPointerUp() {
            // ** æ¢å¾©é¡é ­æ§åˆ¶ **
            if (isInteracting) {
                isInteracting = false;
                if(!cameraLocked) controls.enabled = true; // æ¢å¾©é¡é ­
            }

            const step = learningData[currentPhase][currentStepIndex];

            if (isDragging) {
                isDragging = false;
                document.getElementById('drag-hint').classList.remove('show');
                
                // å¯¬é¬†åˆ¤å®š
                const dist = dragPath.length > 0 ? dragPath[0].distanceTo(dragPath[dragPath.length-1]) : 0;
                if (dist > 0.3) { // åªè¦ç§»å‹•è·é›¢å¤ é•·å°±ç®—æˆåŠŸ
                    completeStep();
                } else {
                    showFeedback('âŒ æ‹–æ›³è·é›¢å¤ªçŸ­', false);
                }
                dragPath = [];
            }

            if (isPressing) {
                isPressing = false;
                document.getElementById('press-circle').classList.remove('show');
                const duration = (Date.now() - pressStartTime) / 1000;
                if (duration >= step.pressDuration) {
                    completeStep();
                } else {
                    showFeedback('âŒ æŒ‰å£“æ™‚é–“ä¸è¶³', false);
                }
            }
        }

        function updateMousePos(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        }

        // --- è¼”åŠ© UI å‡½å¼ ---

        function showDragHint(x, y) {
            const el = document.getElementById('drag-hint');
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            el.classList.add('show');
        }

        function showPressCircle(x, y) {
            const el = document.getElementById('press-circle');
            el.style.left = (x - 40) + 'px';
            el.style.top = (y - 40) + 'px';
            el.classList.add('show');
        }

        function updatePressCircle() {
            if (!isPressing) return;
            const step = learningData[currentPhase][currentStepIndex];
            const progress = Math.min((Date.now() - pressStartTime) / (step.pressDuration * 1000), 1);
            document.getElementById('press-fill').style.transform = `rotate(${progress * 360}deg)`;
            if(progress < 1) requestAnimationFrame(updatePressCircle);
        }

        function checkSequence(obj) {
            const step = learningData[currentPhase][currentStepIndex];
            const index = targets.indexOf(obj);
            
            // ä¿®æ­£ï¼šSequence æ¨¡å¼ä¸‹ targets å¯èƒ½åŒ…å« Lineï¼Œè¦éæ¿¾å‡º Mesh çš„ index
            const meshTargets = targets.filter(t => t.isMesh);
            const meshIndex = meshTargets.indexOf(obj);

            if (meshIndex === sequenceProgress) {
                sequenceProgress++;
                if (sequenceProgress >= step.sequenceCount) {
                    completeStep();
                } else {
                    updateTargets(); // æ›´æ–°ç‡ˆè™Ÿé¡è‰²
                    showFeedback('âœ… æ­£ç¢ºï¼ç¹¼çºŒä¸‹ä¸€å€‹', true);
                }
            } else {
                showFeedback('âŒ è«‹æŒ‰é †åºé»æ“Š', false);
            }
        }

        function completeStep() {
            const step = learningData[currentPhase][currentStepIndex];
            showFeedback(`ğŸ‰ å®Œæˆï¼š${step.text}`, true);
            
            // æ’­æ”¾ç‰¹æ•ˆ
            createSuccessEffect();

            setTimeout(() => {
                nextStep();
            }, 1000);
        }
        
        function createSuccessEffect() {
             // ç°¡å–®çš„ç²’å­ç‰¹æ•ˆ
        }

        function nextStep() {
            const list = learningData[currentPhase];
            if (currentStepIndex < list.length - 1) {
                currentStepIndex++;
                sequenceProgress = 0;
                updateStepUI();
                updateTargets();
            } else {
                showFeedback(`ğŸ† éšæ®µ ${currentPhase} å…¨æ•¸å®Œæˆï¼`, true);
            }
        }
        
        function prevStep() {
            if (currentStepIndex > 0) {
                currentStepIndex--;
                sequenceProgress = 0;
                updateStepUI();
                updateTargets();
            }
        }

        function setPhase(p) {
            currentPhase = p;
            currentStepIndex = 0;
            document.querySelectorAll('.phase-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('p'+p).classList.add('active');
            updateStepUI();
            updateTargets();
        }

        function updateStepUI() {
            const step = learningData[currentPhase][currentStepIndex];
            document.getElementById('step-id').innerHTML = `<span>ğŸ¯</span> STEP ${step.id}`;
            document.getElementById('step-text').innerText = step.text;
            document.getElementById('step-note').innerText = step.note;
            document.getElementById('technique-display').innerHTML = `
                <span class="technique-tag">${step.technique}</span>
                <span class="interaction-tag">${getModeName(step.interactionMode)}</span>
            `;
        }
        
        function getModeName(mode) {
            return {
                'drag': 'ğŸ–±ï¸ æ‹–æ›³äº’å‹•',
                'press': 'â±ï¸ é•·æŒ‰äº’å‹•',
                'sequence': 'ğŸ‘† é †åºé»æ“Š',
                'click': 'ğŸ‘† é»æ“Š'
            }[mode] || 'äº’å‹•';
        }

        function showInteractionMode(mode) {
            const el = document.getElementById('interaction-mode');
            el.innerText = getModeName(mode);
            el.classList.add('show');
            setTimeout(() => el.classList.remove('show'), 2000);
        }

        function showFeedback(msg, success) {
            const el = document.getElementById('feedback-text');
            el.innerText = msg;
            el.style.background = success ? 'rgba(40, 167, 69, 0.9)' : 'rgba(220, 53, 69, 0.9)';
            el.style.opacity = 1;
            clearTimeout(window.fbTimer);
            window.fbTimer = setTimeout(() => el.style.opacity = 0, 1500);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function resetCam() {
            controls.reset();
        }

        function animate() {
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
