<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>è‰¾æŸåœ‹éš›èŠ³ç™‚ - VR æ•™å­¸ç³»çµ±ï¼ˆçµ±ä¸€ç‰ˆï¼‰</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/webxr/VRButton.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: #1a1a1a;
            overflow: hidden;
            touch-action: none;
        }
        
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        .top-bar {
            position: absolute; top: 0; left: 0; width: 100%;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            padding: 15px 25px; color: white; display: flex; justify-content: space-between;
            align-items: center; pointer-events: auto;
        }

        .progress-bar {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            width: 80%; max-width: 500px; height: 6px; background: rgba(255,255,255,0.1);
            border-radius: 10px; overflow: hidden;
        }
        .progress-fill {
            height: 100%; background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%; transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(118, 75, 162, 0.6);
        }
        .progress-text {
            position: absolute; top: 70px; left: 50%; transform: translateX(-50%);
            color: #8ec5fc; font-size: 12px; text-align: center;
        }

        .side-menu {
            position: absolute; left: 20px; top: 100px; width: 300px;
            background: rgba(30, 30, 30, 0.95); backdrop-filter: blur(10px);
            border-radius: 15px; padding: 15px; border: 1px solid rgba(255,255,255,0.1);
            pointer-events: auto; max-height: calc(100vh - 140px); overflow-y: auto;
            transform: translateX(-360px); transition: transform 0.3s ease; 
            z-index: 20;
        }
        .side-menu.show { transform: translateX(0); }
        
        .menu-title { 
            color: #8ec5fc; font-size: 14px; margin-bottom: 10px; font-weight: bold; 
            letter-spacing: 1px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; 
            cursor: pointer;
        }
        
        .phase-btn {
            display: block; width: 100%; padding: 12px; margin-bottom: 8px;
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px; color: #ccc; text-align: left; cursor: pointer;
            transition: all 0.2s; font-size: 14px;
        }
        .phase-btn:hover { background: rgba(255,255,255,0.1); }
        .phase-btn.active { 
            background: linear-gradient(90deg, #667eea, #764ba2); 
            color: white; border: none; box-shadow: 0 4px 12px rgba(118, 75, 162, 0.4);
        }

        .pose-section { 
            display: block; background: rgba(102, 126, 234, 0.2); padding: 12px; 
            border-radius: 8px; margin-bottom: 15px; border: 1px solid rgba(102, 126, 234, 0.3); 
        }
        .pose-label { font-size: 11px; color: #8ec5fc; display: flex; justify-content: space-between; margin-bottom: 3px; }
        .pose-input { width: 100%; cursor: pointer; accent-color: #667eea; height: 20px; }
        .pose-btn {
            padding: 8px 12px; margin: 4px 2px; background: rgba(102, 126, 234, 0.3);
            border: 1px solid rgba(102, 126, 234, 0.5); border-radius: 6px;
            color: #8ec5fc; font-size: 11px; cursor: pointer; transition: all 0.2s;
        }
        .pose-btn:hover { background: rgba(102, 126, 234, 0.5); }
        .pose-btn.active { background: #667eea; color: white; }

        .action-card {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(30, 30, 30, 0.9); backdrop-filter: blur(10px);
            padding: 20px 30px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center; width: 90%; max-width: 500px;
            pointer-events: auto;
        }
        
        .instruction-title { color: #8ec5fc; font-size: 12px; font-weight: bold; margin-bottom: 5px; text-transform: uppercase; }
        .instruction-text { color: #fff; font-size: 20px; font-weight: bold; margin-bottom: 8px; }
        .instruction-note { color: #aaa; font-size: 14px; margin-bottom: 15px; line-height: 1.5; }

        .nav-btn {
            background: #444; color: white; border: none; padding: 8px 16px;
            border-radius: 20px; cursor: pointer; margin: 0 5px; font-weight: bold;
            font-size: 14px; display: inline-flex; align-items: center; gap: 5px;
        }
        .nav-btn:hover { background: #555; }
        .nav-btn.primary { background: #667eea; }
        
        .lock-btn { background: #444; border: 1px solid #666; }
        .lock-btn.locked {
            background: #ff6b6b; border: 1px solid #ff4444;
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
        }

        .gesture-hint {
            position: absolute;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white; padding: 10px 20px; border-radius: 25px;
            font-weight: bold; font-size: 15px; pointer-events: none;
            opacity: 0; transition: opacity 0.3s;
            transform: translate(-50%, -100%);
            white-space: nowrap; z-index: 100;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);
        }
        
        .action-label {
             position: absolute; background: rgba(0,0,0,0.8); color: #FFD700;
             padding: 6px 12px; border-radius: 6px; font-size: 13px;
             font-weight: bold; pointer-events: none; white-space: nowrap;
             z-index: 99; display: none; box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }

        .welcome-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d1b3d 100%);
            z-index: 1000; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: white; text-align: center; padding: 20px;
        }
        .main-title {
            font-size: 40px; font-weight: bold; color: #8ec5fc; 
            margin-bottom: 10px; letter-spacing: 2px;
            text-shadow: 0 0 20px rgba(142, 197, 252, 0.5);
        }
        .start-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white; border: none; padding: 15px 50px;
            font-size: 20px; border-radius: 50px; margin-top: 30px;
            cursor: pointer; box-shadow: 0 0 30px rgba(118, 75, 162, 0.6);
            transition: all 0.3s;
        }
        .start-btn:hover { transform: scale(1.05); }
        .loading-spinner {
            border: 4px solid rgba(255,255,255,0.1); border-left-color: #667eea;
            border-radius: 50%; width: 40px; height: 40px;
            animation: spin 1s linear infinite; margin-top: 20px; display: none;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        .success-badge {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #11998e, #38ef7d);
            color: white; padding: 30px 50px; border-radius: 20px;
            font-size: 32px; font-weight: bold; pointer-events: none;
            z-index: 200; box-shadow: 0 10px 40px rgba(17, 153, 142, 0.6);
        }

        /* VR ç‹€æ…‹é¡¯ç¤º */
        .vr-status {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.8); color: #8ec5fc;
            padding: 8px 15px; border-radius: 15px; font-size: 12px;
            pointer-events: none; z-index: 100; display: none;
        }
        .vr-status.active { display: block; }

        /* VR æŒ‰éˆ•ç¾åŒ– */
        #VRButton {
            background: linear-gradient(135deg, #667eea, #764ba2) !important;
            border: none !important;
            border-radius: 25px !important;
            padding: 12px 30px !important;
            font-weight: bold !important;
            font-size: 16px !important;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5) !important;
        }

        @media (max-width: 768px) {
            .action-card { bottom: 80px; padding: 15px 20px; width: 95%; }
            .instruction-text { font-size: 18px; }
        }
    </style>
</head>
<body>

    <div class="welcome-overlay" id="welcome">
        <div class="main-title">è‰¾æŸåœ‹éš›èŠ³ç™‚</div>
        <h1 style="font-size: 28px; margin-bottom: 10px;">ğŸ¤² å°ˆæ¥­èŠ³ç™‚æ•™å­¸ç³»çµ±</h1>
        <p style="color: #aaa;">çµ±ä¸€ç‰ˆ - æ”¯æ´æ¡Œé¢ + VR æ¨¡å¼</p>
        <p style="color: #8ec5fc; margin-top: 10px; font-size: 14px;">âœ¨ æ¡Œé¢æ“ä½œ / VR æ‰‹å‹¢è¿½è¹¤</p>
        <button class="start-btn" onclick="initApp()">é–‹å§‹ç™‚ç¨‹</button>
        <div class="loading-spinner" id="spinner"></div>
    </div>

    <div id="canvas-container" style="width:100vw; height:100vh;"></div>

    <div class="vr-status" id="vr-status">
        ğŸ¥½ æ¨¡å¼: <span id="vr-mode-text">æ¡Œé¢</span>
    </div>

    <div class="ui-layer" id="ui" style="display:none;">
        <div class="top-bar">
            <div style="font-weight: bold; font-size: 18px; display:flex; align-items:center; gap:10px;">
                <span style="font-size:24px;" id="current-tool-icon">ğŸ¤š</span>
                <span id="phase-title">éšæ®µä¸€ï¼šæº–å‚™èˆ‡èµ·å§‹</span>
            </div>
            
            <div style="display:flex; gap:10px;">
                <button class="nav-btn lock-btn" id="lock-btn" onclick="toggleCameraLock()">ğŸ”“ é–å®š</button>
                <button class="nav-btn" onclick="toggleMenu()">â˜°</button>
            </div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
        <div class="progress-text" id="progress-text">é€²åº¦: 0%</div>

        <div class="side-menu" id="side-menu">
            <div class="pose-section" id="pose-panel">
                <div class="menu-title" style="color:#8ec5fc;">
                    ğŸ¦´ è…¿éƒ¨å§¿å‹¢æ§åˆ¶ <span id="bone-status">(åµæ¸¬ä¸­...)</span>
                </div>
                
                <div style="margin-bottom:8px;">
                    <button class="pose-btn" id="btn-pose-flat" onclick="applyPose('flat')">å¹³èºº</button>
                    <button class="pose-btn" id="btn-pose-leftRaised" onclick="applyPose('leftRaised')">å·¦è…¿æŠ¬èµ·</button>
                    <button class="pose-btn" id="btn-pose-rightRaised" onclick="applyPose('rightRaised')">å³è…¿æŠ¬èµ·</button>
                </div>
                
                <div style="margin-bottom:12px;">
                    <div class="pose-label"><span>å·¦å¤§è…¿æŠ¬èµ·</span> <span id="val-left-thigh">0Â°</span></div>
                    <input type="range" class="pose-input" id="range-left-thigh" min="-90" max="45" step="1" value="0" oninput="onSliderChange()">
                </div>
            </div>

            <div class="menu-title">ç™‚ç¨‹éšæ®µé¸å–®</div>
            <button class="phase-btn active" onclick="setPhase(1)" id="p1">1. æº–å‚™èˆ‡èµ·å§‹å®‰æ’«</button>
            <button class="phase-btn" onclick="setPhase(2)" id="p2">2. å·¦è…¿æŒ‰æ‘©æ“ä½œ</button>
            <button class="phase-btn" onclick="setPhase(3)" id="p3">3. å³è…¿æŒ‰æ‘©æ“ä½œ</button>
            <button class="phase-btn" onclick="setPhase(4)" id="p4">4. çµå°¾èˆ‡å®‰æ’«</button>
            
            <div class="menu-title" style="margin-top:20px;">ä¸€èˆ¬è¨­å®š</div>
            <button class="phase-btn" onclick="resetCam()">ğŸ”„ é‡ç½®è¦–è§’</button>
            <button class="phase-btn" onclick="toggleModel()">ğŸ‘¤ åˆ‡æ›æ¨¡ç‰¹å…’</button>
        </div>

        <div class="gesture-hint" id="gesture-hint">ğŸ‘† æŒ‰ä½ä¸¦æ‹–æ›³</div>
        <div class="action-label" id="action-label">è·Ÿéš¨æ‰‹éƒ¨</div>

        <div class="action-card">
            <div class="instruction-title">STEP <span id="step-num">1.1</span></div>
            <div class="instruction-text" id="action-text">è¼‰å…¥ä¸­...</div>
            <div class="instruction-note" id="action-note">è·Ÿéš¨æ‰‹éƒ¨æŒ‡å¼•æ“ä½œ</div>
            
            <div style="display:flex; justify-content: center; gap:10px;">
                <button class="nav-btn" onclick="prevStep()">ä¸Šä¸€æ­¥</button>
                <button class="nav-btn primary" onclick="forceComplete()">è·³é</button>
            </div>
        </div>

        <div class="success-badge" id="success-badge">å®Œæˆï¼âœ¨</div>
    </div>

    <script>
        const BASE_URL = "https://gp01002.github.io/TMS/";
        const MODEL_CONFIG = {
            male: { pos: { x: 0.1, y: 2.2, z: 0 }, scale: 1.0, rot: { x: -1.57, y: 0, z: 1.57 } },
            female: { pos: { x: 0.1, y: 2.18, z: 0 }, scale: 1.0, rot: { x: -1.57, y: 0, z: 1.57 } }
        };
        
        const COORDS = {
            THIGH_ROOT: -3.3, THIGH_MID: -2.4, KNEE: -1.5, CALF_MID: -0.7, ANKLE: 0.1, FOOT: 0.3            
        };
        const LEFT_LEG_Z = 0.12, RIGHT_LEG_Z = -0.12;

        const learningData = {
            1: [
                { id: "1.1", text: "æ¯›å·¾ç®¡ç†èˆ‡é–‹å ´", note: "é»æ“Šå¤§è…¿æ ¹éƒ¨", type: "click", icon: "â¬œ", pos: {x: COORDS.THIGH_ROOT, y: -0.25, z: 0} },
                { id: "1.2", text: "å‡å‹»ä¸Šæ²¹", note: "æŒ‰å£“è†è“‹ 2 ç§’", type: "press", icon: "ğŸ§´", pos: {x: COORDS.KNEE, y: 0.2, z: 0}, duration: 2 },
                { id: "1.3", text: "é–‹å ´å¤§å®‰æ’«", note: "å¾è…³åº•æ»‘è‡³å¤§è…¿æ ¹", type: "drag", icon: "âœ¨", start: {x: COORDS.FOOT, y: -0.35, z: LEFT_LEG_Z}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: LEFT_LEG_Z} },
                { id: "1.4", text: "å³è…³ä¿æš–", note: "é»æ“Šå³è†", type: "click", icon: "â¬œ", pos: {x: COORDS.KNEE, y: -0.2, z: RIGHT_LEG_Z} }
            ],
            2: [
                { id: "2.1", text: "å¤§è…¿ï¼šæ‹‡æŒ‡é•·æ¨", note: "å¾è†è“‹æ¨è‡³å¤§è…¿æ ¹", type: "drag", icon: "ğŸ‘", start: {x: COORDS.KNEE, y: -0.25, z: LEFT_LEG_Z}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: LEFT_LEG_Z} },
                { id: "2.2", text: "åˆ†æ®µæ’¥æ", note: "å¤§è…¿ä¸­æ®µæ’¥æ", type: "drag", icon: "ğŸ¤", start: {x: COORDS.THIGH_MID, y: -0.25, z: LEFT_LEG_Z}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: LEFT_LEG_Z} },
                { id: "2.3", text: "Så‹æŠ“æ", note: "å…§å‘å¤–æŠ“æ", type: "drag", icon: "ã€°ï¸", start: {x: COORDS.THIGH_MID, y: -0.2, z: LEFT_LEG_Z - 0.1}, end: {x: COORDS.THIGH_MID, y: -0.2, z: LEFT_LEG_Z + 0.1} },
                { id: "2.4", text: "å°è…¿é•·æ¨", note: "è…³è¸è‡³è†è“‹", type: "drag", icon: "ğŸ¦µ", start: {x: COORDS.ANKLE, y: -0.3, z: LEFT_LEG_Z}, end: {x: COORDS.KNEE, y: -0.25, z: LEFT_LEG_Z} },
                { id: "2.5", text: "ä¸‰ç·šå¼æŒ‰å£“", note: "å°è…¿ä¸­ç·š", type: "drag", icon: "ğŸ“Š", start: {x: COORDS.CALF_MID, y: -0.3, z: LEFT_LEG_Z - 0.05}, end: {x: COORDS.KNEE, y: -0.25, z: LEFT_LEG_Z - 0.05} },
                { id: "2.6", text: "æŠ¬è…¿æº–å‚™", note: "é»æ“Šè…³è¸", type: "click", icon: "ğŸ¦¶", pos: {x: COORDS.FOOT, y: -0.3, z: LEFT_LEG_Z}, pose: "leftRaised" },
                { id: "2.7", text: "æ¹§æ³‰ç©´ç•«åœˆ", note: "æŒ‰å£“ 3 ç§’", type: "press", icon: "â­•", pos: {x: COORDS.FOOT + 0.05, y: 0.2, z: LEFT_LEG_Z}, duration: 3, pose: "leftRaised" },
                { id: "2.8", text: "åŠæ¡æ‹³æ»‘æ¨", note: "è…³è¸è‡³è…³è¶¾", type: "drag", icon: "ğŸ¤›", start: {x: COORDS.ANKLE, y: 0.2, z: LEFT_LEG_Z}, end: {x: COORDS.FOOT + 0.1, y: 0.2, z: LEFT_LEG_Z}, pose: "leftRaised" },
                { id: "2.9", text: "éœå¿ƒæŒ‰å£“", note: "æŒ‰ä½ 10 ç§’", type: "press", icon: "â±ï¸", pos: {x: COORDS.FOOT + 0.05, y: 0.2, z: LEFT_LEG_Z}, duration: 10, pose: "leftRaised" },
                { id: "2.10", text: "è“‹ä¸Šæ¯›å·¾", note: "é»æ“Šè†è“‹", type: "click", icon: "â¬œ", pos: {x: COORDS.KNEE, y: -0.1, z: LEFT_LEG_Z}, pose: "flat" }
            ],
            3: [
                { id: "3.1", text: "å³è…¿é–‹å§‹", note: "é»æ“Šå³è…³è¸", type: "click", icon: "â–¶ï¸", pos: {x: COORDS.ANKLE, y: -0.3, z: RIGHT_LEG_Z} },
                { id: "3.2", text: "å³è…¿é•·æ¨", note: "è†è“‹è‡³å¤§è…¿æ ¹", type: "drag", icon: "ğŸ‘", start: {x: COORDS.KNEE, y: -0.25, z: RIGHT_LEG_Z}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: RIGHT_LEG_Z} },
                { id: "3.10", text: "å®Œæˆå³è…¿", note: "é»æ“Šå³è†", type: "click", icon: "â¬œ", pos: {x: COORDS.KNEE, y: -0.1, z: RIGHT_LEG_Z}, pose: "flat" }
            ],
            4: [
                { id: "4.1", text: "æ•´åˆå®‰æ’«", note: "è…³åº•è‡³å¤§è…¿", type: "drag", icon: "âœ¨", start: {x: COORDS.FOOT, y: -0.35, z: 0}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: 0} },
                { id: "4.2", text: "å®Œæˆç™‚ç¨‹", note: "é»æ“Šè†è“‹", type: "click", icon: "ğŸ", pos: {x: COORDS.KNEE, y: -0.1, z: 0} }
            ]
        };

        let scene, camera, renderer, controls, model;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let interactables = []; 
        let currentPhase = 1, currentStepIndex = 0;
        let isDragging = false, isCameraLocked = false;
        let ghostHand, activeModelType = 'male';
        
        let trailLine = null, trailPoints = [];
        let isVRMode = false;
        let vrHand = null, handJoints = [];
        let pressTimer = null, pressStartTime = 0;

        let modelPos = { ...MODEL_CONFIG.male.pos };
        let modelRot = { ...MODEL_CONFIG.male.rot };
        let bones = { leftUpLeg: null };
        let poseControls = { leftThigh: 0 };
        
        const POSES = {
            flat: { leftThigh: 0 },
            leftRaised: { leftThigh: -45 },
            rightRaised: { leftThigh: 0 }
        };

        function hapticFeedback(pattern = [50]) {
            if (navigator.vibrate) navigator.vibrate(pattern);
        }

        function showSuccessBadge() {
            const badge = document.getElementById('success-badge');
            if (!badge) return;
            gsap.to(badge, {
                scale: 1, duration: 0.3, ease: "back.out(2)",
                onComplete: () => setTimeout(() => gsap.to(badge, { scale: 0, duration: 0.2 }), 800)
            });
        }

        function updateProgress() {
            const totalSteps = Object.values(learningData).reduce((sum, phase) => sum + phase.length, 0);
            let completedSteps = 0;
            for (let i = 1; i < currentPhase; i++) completedSteps += learningData[i].length;
            completedSteps += currentStepIndex;
            const percentage = Math.round((completedSteps / totalSteps) * 100);
            
            const fill = document.getElementById('progress-fill');
            const text = document.getElementById('progress-text');
            if (fill) fill.style.width = percentage + '%';
            if (text) text.innerText = `é€²åº¦: ${percentage}%`;
        }

        function createTrailLine() {
            if (trailLine) scene.remove(trailLine);
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.LineBasicMaterial({ color: 0x667eea, linewidth: 2, transparent: true, opacity: 0.8 });
            trailLine = new THREE.Line(geometry, material);
            scene.add(trailLine);
            trailPoints = [];
        }

        function updateTrailLine(position) {
            if (!trailLine) return;
            trailPoints.push(position.clone());
            if (trailPoints.length > 40) trailPoints.shift();
            
            const positions = new Float32Array(trailPoints.length * 3);
            trailPoints.forEach((point, i) => {
                positions[i * 3] = point.x;
                positions[i * 3 + 1] = point.y;
                positions[i * 3 + 2] = point.z;
            });
            trailLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            trailLine.geometry.attributes.position.needsUpdate = true;
        }

        function clearTrailLine() {
            if (trailLine) { scene.remove(trailLine); trailLine = null; trailPoints = []; }
        }

        function createParticles(position) {
            const particleCount = 20;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                velocities.push({ x: (Math.random() - 0.5) * 0.03, y: Math.random() * 0.05, z: (Math.random() - 0.5) * 0.03 });
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: 0x667eea, size: 0.03, transparent: true, opacity: 1.0, blending: THREE.AdditiveBlending });
            const particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            let frame = 0;
            const animate = () => {
                frame++;
                const positions = particleSystem.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] += velocities[i].x;
                    positions[i * 3 + 1] += velocities[i].y;
                    positions[i * 3 + 2] += velocities[i].z;
                    velocities[i].y -= 0.001;
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
                particleSystem.material.opacity -= 0.03;
                if (frame < 30 && particleSystem.material.opacity > 0) requestAnimationFrame(animate);
                else scene.remove(particleSystem);
            };
            animate();
        }

        function initApp() {
            document.getElementById('spinner').style.display = 'block';
            document.querySelector('.start-btn').style.display = 'none';
            setTimeout(initThreeJS, 100);
        }

        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const spotLight = new THREE.SpotLight(0xffeeb1, 1.5);
            spotLight.position.set(2, 6, 2);
            scene.add(spotLight);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);
            camera.position.set(1.5, 2.5, 2.5);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // å‰µå»º VR æŒ‰éˆ•
            document.body.appendChild(THREE.VRButton.createButton(renderer, {
                optionalFeatures: ['hand-tracking']
            }));

            renderer.xr.addEventListener('sessionstart', () => {
                isVRMode = true;
                console.log('âœ… VR æ¨¡å¼å·²å•Ÿå‹•');
                document.getElementById('vr-status').classList.add('active');
                document.getElementById('vr-mode-text').innerText = 'VR âœ“';
                document.getElementById('ui').style.display = 'none';
                if (ghostHand) ghostHand.visible = false;
                
                // è¨­å®š VR æ‰‹éƒ¨è¿½è¹¤
                vrHand = renderer.xr.getHand(0);
                scene.add(vrHand);
                console.log('ğŸ–ï¸ æ‰‹éƒ¨è¿½è¹¤å·²å•Ÿç”¨');
            });

            renderer.xr.addEventListener('sessionend', () => {
                isVRMode = false;
                console.log('âŒ VR æ¨¡å¼å·²é—œé–‰');
                document.getElementById('vr-status').classList.remove('active');
                document.getElementById('vr-mode-text').innerText = 'æ¡Œé¢';
                document.getElementById('ui').style.display = 'block';
            });

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxDistance = 6;
            controls.minDistance = 0.3;
            
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onPointerDown);
            canvas.addEventListener('mousemove', onPointerMove);
            canvas.addEventListener('mouseup', onPointerUp);
            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onPointerDown(e.touches[0]); }, {passive: false});
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onPointerMove(e.touches[0]); }, {passive: false});
            canvas.addEventListener('touchend', onPointerUp);
            window.addEventListener('resize', onWindowResize);

            renderer.setAnimationLoop(() => {
                if (!isVRMode) controls.update();
                else updateVRHandTracking();
                
                interactables.forEach(obj => { if(obj.tick) obj.tick(); });
                
                if (ghostHand && ghostHand.visible && !isVRMode) {
                    ghostHand.lookAt(camera.position);
                }
                
                renderer.render(scene, camera);
            });

            loadEnvironment();
        }

        // VR æ‰‹éƒ¨è¿½è¹¤æ›´æ–°
        function updateVRHandTracking() {
            if (!vrHand || !vrHand.joints) return;
            
            const indexTip = vrHand.joints['index-finger-tip'];
            if (!indexTip) return;
            
            const tipPosition = new THREE.Vector3();
            indexTip.getWorldPosition(tipPosition);
            
            checkVRInteraction(tipPosition);
        }

        function checkVRInteraction(tipPosition) {
            const step = learningData[currentPhase][currentStepIndex];
            
            if (step.type === 'drag') {
                const startPos = new THREE.Vector3(
                    step.start.x + modelPos.x,
                    step.start.y + modelPos.y,
                    step.start.z + modelPos.z
                );
                const endPos = new THREE.Vector3(
                    step.end.x + modelPos.x,
                    step.end.y + modelPos.y,
                    step.end.z + modelPos.z
                );
                
                if (!isDragging && tipPosition.distanceTo(startPos) < 0.15) {
                    isDragging = true;
                    createTrailLine();
                    console.log('ğŸŸ¢ VR æ‹–æ›³é–‹å§‹');
                }
                
                if (isDragging) {
                    updateTrailLine(tipPosition);
                    if (tipPosition.distanceTo(endPos) < 0.25) {
                        isDragging = false;
                        clearTrailLine();
                        createParticles(endPos);
                        console.log('ğŸ VR æ‹–æ›³å®Œæˆ');
                        setTimeout(() => { showSuccessBadge(); nextStep(); }, 500);
                    }
                }
            } else if (step.type === 'press') {
                const targetPos = new THREE.Vector3(
                    step.pos.x + modelPos.x,
                    step.pos.y + modelPos.y,
                    step.pos.z + modelPos.z
                );
                
                if (tipPosition.distanceTo(targetPos) < 0.15) {
                    if (!pressTimer) {
                        pressStartTime = Date.now();
                        console.log(`â±ï¸ VR æŒ‰å£“é–‹å§‹ (${step.duration}ç§’)`);
                        pressTimer = setInterval(() => {
                            const elapsed = (Date.now() - pressStartTime) / 1000;
                            if (elapsed >= step.duration) {
                                clearInterval(pressTimer);
                                pressTimer = null;
                                createParticles(targetPos);
                                console.log('âœ… VR æŒ‰å£“å®Œæˆ');
                                setTimeout(() => { showSuccessBadge(); nextStep(); }, 500);
                            }
                        }, 100);
                    }
                } else {
                    if (pressTimer) {
                        clearInterval(pressTimer);
                        pressTimer = null;
                        console.log('âŒ VR æŒ‰å£“å–æ¶ˆ');
                    }
                }
            } else if (step.type === 'click') {
                const targetPos = new THREE.Vector3(
                    step.pos.x + modelPos.x,
                    step.pos.y + modelPos.y,
                    step.pos.z + modelPos.z
                );
                
                if (tipPosition.distanceTo(targetPos) < 0.15) {
                    createParticles(targetPos);
                    console.log('ğŸ‘† VR é»æ“Šå®Œæˆ');
                    setTimeout(() => { showSuccessBadge(); nextStep(); }, 500);
                }
            }
        }

        function loadEnvironment() {
            const loader = new THREE.GLTFLoader();
            loader.load(BASE_URL + 'A01.glb', (gltf) => {
                const room = gltf.scene;
                room.scale.set(20, 20, 20);
                scene.add(room);
            });
            loadModel('male');
        }

        function loadModel(type) {
            if(model) scene.remove(model);
            activeModelType = type;
            modelPos = { ...MODEL_CONFIG[type].pos };
            modelRot = { ...MODEL_CONFIG[type].rot };

            const loader = new THREE.GLTFLoader();
            loader.load(BASE_URL + (type === 'male' ? 'B01.glb' : 'B02.glb'), (gltf) => {
                model = gltf.scene;
                model.position.set(modelPos.x, modelPos.y, modelPos.z);
                model.scale.setScalar(MODEL_CONFIG[type].scale);
                model.rotation.set(modelRot.x, modelRot.y, modelRot.z);
                
                model.traverse(child => {
                    if(child.isMesh) { child.castShadow = true; child.receiveShadow = true; }
                    if(child.isBone) {
                        const name = child.name.toLowerCase();
                        if(name.includes('left') && name.includes('thigh')) bones.leftUpLeg = child;
                    }
                });

                if(bones.leftUpLeg) document.getElementById('bone-status').innerText = "(âœ…)";
                scene.add(model);
                applyPose('flat');
                
                document.getElementById('welcome').style.display = 'none';
                document.getElementById('ui').style.display = 'block';
                createGhostHand();
                setPhase(1);
            });
        }

        function applyPose(poseName) {
            const pose = POSES[poseName];
            if (!pose) return;
            
            document.querySelectorAll('.pose-btn').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`btn-pose-${poseName}`);
            if(activeBtn) activeBtn.classList.add('active');
            
            gsap.to(poseControls, {
                leftThigh: pose.leftThigh, duration: 0.5,
                onUpdate: () => {
                    if (bones.leftUpLeg) bones.leftUpLeg.rotation.x = THREE.MathUtils.degToRad(poseControls.leftThigh);
                    document.getElementById('val-left-thigh').innerText = Math.round(poseControls.leftThigh) + 'Â°';
                }
            });
        }

        function createGhostHand() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = '100px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('âœ‹', 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const geometry = new THREE.PlaneGeometry(0.5, 0.5);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0.9, depthTest: false });
            ghostHand = new THREE.Mesh(geometry, material);
            ghostHand.renderOrder = 999;
            scene.add(ghostHand);
            ghostHand.visible = false;
        }

        function createInteractable(pos, icon) {
            const group = new THREE.Group();
            group.position.set(pos.x + modelPos.x, pos.y + modelPos.y + 0.1, pos.z + modelPos.z);

            const geometry = new THREE.SphereGeometry(0.12, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0x667eea, transparent: true, opacity: 0.6 });
            const sphere = new THREE.Mesh(geometry, material);
            group.add(sphere);

            scene.add(group);
            interactables.push(group);

            gsap.to(sphere.scale, { x: 1.3, y: 1.3, z: 1.3, duration: 0.7, yoyo: true, repeat: -1 });
            group.tick = () => sphere.lookAt(camera.position);
            
            return group;
        }

        function setPhase(p) {
            currentPhase = p; currentStepIndex = 0;
            document.querySelectorAll('.phase-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('p'+p);
            if(btn) { btn.classList.add('active'); document.getElementById('phase-title').innerText = btn.innerText; }
            setupStep();
        }

        function setupStep() {
            interactables.forEach(obj => scene.remove(obj));
            interactables = [];
            clearTrailLine();
            if (pressTimer) { clearInterval(pressTimer); pressTimer = null; }
            isDragging = false;

            const step = learningData[currentPhase][currentStepIndex];
            document.getElementById('step-num').innerText = step.id;
            document.getElementById('action-text').innerText = step.text;
            document.getElementById('action-note').innerText = step.note;
            document.getElementById('current-tool-icon').innerText = step.icon;

            if (step.pose) applyPose(step.pose);
            else applyPose('flat');

            if (step.type === 'drag') {
                createInteractable(step.start, 'ğŸŸ¢');
                createInteractable(step.end, 'ğŸ');
            } else {
                createInteractable(step.pos, step.icon);
            }
            
            updateProgress();
        }

        function nextStep() {
            const list = learningData[currentPhase];
            if (currentStepIndex < list.length - 1) {
                currentStepIndex++;
                setupStep();
            } else {
                hapticFeedback([200, 100, 200]);
                alert(`ğŸ‰ éšæ®µ ${currentPhase} å®Œæˆï¼`);
                if (learningData[currentPhase + 1]) setPhase(currentPhase + 1);
                else { alert("ğŸ† æ­å–œå®Œæˆæ‰€æœ‰ç™‚ç¨‹ï¼"); updateProgress(); }
            }
        }

        function prevStep() {
            if (currentStepIndex > 0) { currentStepIndex--; setupStep(); }
            else if (currentPhase > 1) {
                setPhase(currentPhase - 1);
                currentStepIndex = learningData[currentPhase].length - 1;
                setupStep();
            }
        }

        function forceComplete() { nextStep(); }
        function toggleCameraLock() {
            isCameraLocked = !isCameraLocked;
            controls.enabled = !isCameraLocked;
            const btn = document.getElementById('lock-btn');
            if (isCameraLocked) { btn.innerHTML = 'ğŸ”’'; btn.classList.add('locked'); hapticFeedback([50]); }
            else { btn.innerHTML = 'ğŸ”“'; btn.classList.remove('locked'); }
        }
        function toggleMenu() { document.getElementById('side-menu').classList.toggle('show'); }
        function toggleModel() {
            const newType = activeModelType === 'male' ? 'female' : 'male';
            loadModel(newType);
        }
        function resetCam() { if(!isVRMode) { controls.reset(); hapticFeedback([50]); } }
        function onSliderChange() {
            const val = parseFloat(document.getElementById('range-left-thigh').value);
            poseControls.leftThigh = val;
            if (bones.leftUpLeg) bones.leftUpLeg.rotation.x = THREE.MathUtils.degToRad(val);
            document.getElementById('val-left-thigh').innerText = Math.round(val) + 'Â°';
        }

        // æ¡Œé¢/æ‰‹æ©Ÿæ¨¡å¼äº’å‹•
        function onPointerDown(e) {
            if (isVRMode) return;
            updateMouse(e);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactables, true);
            if (intersects.length === 0) return;

            const step = learningData[currentPhase][currentStepIndex];
            
            if (step.type === 'drag') {
                isDragging = true;
                controls.enabled = false;
                createTrailLine();
                console.log('ğŸ–±ï¸ æ¡Œé¢æ‹–æ›³é–‹å§‹');
            } else if (step.type === 'press') {
                pressStartTime = Date.now();
                console.log(`â±ï¸ æ¡Œé¢æŒ‰å£“é–‹å§‹ (${step.duration}ç§’)`);
                pressTimer = setInterval(() => {
                    const elapsed = (Date.now() - pressStartTime) / 1000;
                    if (elapsed >= step.duration) {
                        clearInterval(pressTimer);
                        pressTimer = null;
                        createParticles(intersects[0].point);
                        console.log('âœ… æ¡Œé¢æŒ‰å£“å®Œæˆ');
                        setTimeout(() => { showSuccessBadge(); nextStep(); }, 800);
                    }
                }, 100);
            } else if (step.type === 'click') {
                createParticles(intersects[0].point);
                hapticFeedback([50, 50]);
                console.log('ğŸ‘† æ¡Œé¢é»æ“Šå®Œæˆ');
                setTimeout(() => { showSuccessBadge(); nextStep(); }, 800);
            }
        }

        function onPointerMove(e) {
            if (isVRMode || !isDragging) return;
            
            updateMouse(e);
            raycaster.setFromCamera(mouse, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -modelPos.y);
            const point = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, point);
            
            if (point) {
                updateTrailLine(point);
                const step = learningData[currentPhase][currentStepIndex];
                const endPos = new THREE.Vector3(step.end.x + modelPos.x, step.end.y + modelPos.y, step.end.z + modelPos.z);
                
                // ä¿®æ­£ï¼šæ”¾å¯¬åˆ¤å®šè·é›¢
                if (point.distanceTo(endPos) < 0.6) {
                    isDragging = false;
                    controls.enabled = true;
                    clearTrailLine();
                    createParticles(endPos);
                    hapticFeedback([100]);
                    console.log('ğŸ æ¡Œé¢æ‹–æ›³å®Œæˆ');
                    setTimeout(() => { showSuccessBadge(); nextStep(); }, 800);
                }
            }
        }

        function onPointerUp() {
            if (isVRMode) return;
            
            const step = learningData[currentPhase][currentStepIndex];
            
            // æŒ‰å£“é¡å‹ï¼šå¦‚æœæ”¾é–‹æ™‚æœªå®Œæˆï¼Œå–æ¶ˆ
            if (step.type === 'press' && pressTimer) {
                clearInterval(pressTimer);
                pressTimer = null;
                console.log('âŒ æ¡Œé¢æŒ‰å£“å–æ¶ˆï¼ˆæœªé”æ™‚é–“ï¼‰');
                return;
            }
            
            // æ‹–æ›³é¡å‹ï¼šæª¢æŸ¥æ˜¯å¦å·²åˆ°é”çµ‚é»
            if (isDragging) {
                isDragging = false;
                controls.enabled = true;
                clearTrailLine();
                console.log('âŒ æ¡Œé¢æ‹–æ›³æœªå®Œæˆ');
            }
        }

        function updateMouse(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
