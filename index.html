<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>è‰¾æŸåœ‹éš›èŠ³ç™‚ - VR æŒ‰æ‘©æ•™å­¸ (3D äº’å‹•ç‰ˆ v25)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/"
            }
        }
    </script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Microsoft JhengHei', sans-serif; background: #1a1a1a; overflow: hidden; touch-action: none; }
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .top-bar { position: absolute; top: 0; left: 0; width: 100%; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent); padding: 15px 25px; color: white; display: flex; justify-content: space-between; align-items: center; pointer-events: auto; }
        .side-menu { position: absolute; left: 20px; top: 80px; width: 300px; background: rgba(30, 30, 30, 0.95); backdrop-filter: blur(10px); border-radius: 15px; padding: 15px; border: 1px solid rgba(255,255,255,0.1); pointer-events: auto; max-height: calc(100vh - 120px); overflow-y: auto; transform: translateX(-360px); transition: transform 0.3s ease; z-index: 20; }
        .side-menu.show { transform: translateX(0); }
        .menu-title { color: #8ec5fc; font-size: 14px; margin-bottom: 10px; font-weight: bold; cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; }
        .phase-btn { display: block; width: 100%; padding: 12px; margin-bottom: 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #ccc; text-align: left; cursor: pointer; transition: all 0.2s; font-size: 14px; }
        .phase-btn.active { background: linear-gradient(90deg, #667eea, #764ba2); color: white; border: none; }
        .pose-section { display: block; background: rgba(102, 126, 234, 0.2); padding: 12px; border-radius: 8px; margin-bottom: 15px; }
        .pose-btn { padding: 8px 12px; margin: 4px 2px; background: rgba(102, 126, 234, 0.3); border: 1px solid rgba(102, 126, 234, 0.5); border-radius: 6px; color: #8ec5fc; font-size: 11px; cursor: pointer; }
        .pose-btn.active { background: #667eea; color: white; }
        body.vr-active .action-card, body.vr-active .gesture-hint { display: none !important; }
        .action-card { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); background: rgba(30, 30, 30, 0.95); backdrop-filter: blur(10px); padding: 20px 30px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1); text-align: center; width: 90%; max-width: 500px; pointer-events: auto; }
        .instruction-title { color: #8ec5fc; font-size: 12px; font-weight: bold; margin-bottom: 5px; text-transform: uppercase; }
        .instruction-text { color: #fff; font-size: 20px; font-weight: bold; margin-bottom: 8px; }
        .instruction-note { color: #aaa; font-size: 14px; margin-bottom: 15px; line-height: 1.5; }
        .nav-btn { background: #444; color: white; border: none; padding: 8px 16px; border-radius: 20px; cursor: pointer; margin: 0 5px; font-weight: bold; transition: all 0.3s; }
        .nav-btn.primary { background: #667eea; }
        .lock-btn { border: 1px solid #666; }
        .lock-btn.locked { background: #667eea; border: 1px solid #667eea; box-shadow: 0 0 10px rgba(102, 126, 234, 0.5); }
        .welcome-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(20, 20, 20, 0.95); z-index: 1000; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; text-align: center; padding: 20px; }
        .start-btn { background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; padding: 15px 50px; font-size: 20px; border-radius: 50px; margin-top: 30px; cursor: pointer; }
        .vr-status { position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 10px 15px; border-radius: 10px; color: #fff; font-size: 12px; display: none; border: 1px solid #00ff00; font-family: 'Courier New', monospace; z-index: 100; }
        .vr-status.active { display: block; }
        .vr-status-line { margin: 3px 0; padding: 3px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .vr-status-line:last-child { border-bottom: none; }
    </style>
</head>
<body>

    <div class="welcome-overlay" id="welcome">
        <div style="font-size: 40px; font-weight: bold; color: #8ec5fc; margin-bottom: 10px;">è‰¾æŸåœ‹éš›èŠ³ç™‚</div>
        <h1 style="font-size: 28px; margin-bottom: 10px;">ğŸ¤² VR ç‘å…¸å¼è…¿éƒ¨æŒ‰æ‘© SOP</h1>
        <p style="color: #00ff00; font-size: 20px; font-weight: bold;">3D äº’å‹•ç‰ˆ v25.0</p>
        <p style="color: #8ec5fc; font-size: 14px; margin-top:10px;">âœ¨ 3D çƒé«”äº’å‹• + ç¯„åœè¦–è¦ºåŒ– + æ›´æº–ç¢ºçš„ç¢°æ’</p>
        
        <div style="margin-top: 30px; background: rgba(0,255,0,0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(0,255,0,0.3); max-width: 600px;">
            <p style="color: #00ff00; font-weight: bold; font-size: 16px; margin-bottom: 15px;">ğŸ”§ VR æ“ä½œæŒ‡å—</p>
            <div style="text-align: left; color: #ccc; line-height: 2;">
                <p>1ï¸âƒ£ <b>ç¶ è‰²çƒé«”</b>ï¼šèµ·é»ï¼ˆæ‰‹æŒ‡é è¿‘å³å¯è§¸ç™¼ï¼‰</p>
                <p>2ï¸âƒ£ <b>ç´…è‰²çƒé«”</b>ï¼šçµ‚é»ï¼ˆæ‹–æ‹½æ“ä½œæ™‚é¡¯ç¤ºï¼‰</p>
                <p>3ï¸âƒ£ <b>é’è‰²å€åŸŸ</b>ï¼šè¡¨ç¤ºæ“ä½œè¦†è“‹ç¯„åœ</p>
                <p>4ï¸âƒ£ <b>é»ƒè‰²è™›ç·š</b>ï¼šè·Ÿéš¨è»Œè·¡ç§»å‹•æ‰‹æŒ‡</p>
            </div>
        </div>
        
        <button class="start-btn" onclick="initApp()">é–‹å§‹æ¨™æº–æµç¨‹</button>
        <div id="spinner" style="display:none; margin-top:20px; color:white;">è¼‰å…¥ä¸­...</div>
    </div>

    <div id="canvas-container" style="width:100vw; height:100vh;"></div>
    
    <div class="ui-layer" id="ui" style="display:none;">
        <div class="top-bar">
            <div style="font-weight: bold; font-size: 18px; display:flex; align-items:center; gap:10px;">
                <span style="font-size:24px;" id="current-tool-icon">ğŸ¤š</span>
                <span id="phase-title">SOP æº–å‚™éšæ®µ</span>
            </div>
            <div style="display:flex; gap:10px;">
                <button class="nav-btn lock-btn locked" id="lock-btn" onclick="toggleCameraLock()">ğŸ”’ å°æ’­é–å®š</button>
                <button class="nav-btn" onclick="toggleMenu()">â˜°</button>
            </div>
        </div>

        <div class="vr-status" id="vr-status">
            <div>ğŸ” VR ç›£æ§</div>
            <div style="margin-top:5px;" class="vr-status-line">ğŸ‘‹ æ‰‹å‹¢: <span id="hand-track-status" style="color: #ffff00;">...</span></div>
            <div class="vr-status-line">ğŸš€ ç§»å‹•: <span id="move-status">è‡ªå‹•å®šä½</span></div>
            <div class="vr-status-line">ğŸ¯ è·é›¢: <span id="distance-status">--</span></div>
            <div class="vr-status-line">ğŸ“ ç‹€æ…‹: <span id="interaction-status">å¾…æ©Ÿä¸­</span></div>
        </div>

        <div class="side-menu" id="side-menu">
            <div class="pose-section">
                <div class="menu-title">ğŸ¦´ é«”ä½èª¿æ•´</div>
                <div style="margin-bottom:8px;">
                    <button class="pose-btn active" id="btn-pose-flat" onclick="applyPose('flat')">å¹³èººæ”¾é¬†</button>
                    <button class="pose-btn" id="btn-pose-leftRaised" onclick="applyPose('leftRaised')">å·¦è…¿å±ˆè†</button>
                    <button class="pose-btn" id="btn-pose-rightRaised" onclick="applyPose('rightRaised')">å³è…¿å±ˆè†</button>
                </div>
            </div>
            <div class="menu-title">æ¨™æº–ä½œæ¥­æµç¨‹ (SOP)</div>
            <button class="phase-btn active" onclick="setPhase(1)" id="p1">2.0 æº–å‚™èˆ‡é–‹å ´</button>
            <button class="phase-btn" onclick="setPhase(2)" id="p2">3.0 å·¦è…¿æŒ‰æ‘©æµç¨‹</button>
            <button class="phase-btn" onclick="setPhase(3)" id="p3">4.0 å³è…¿æŒ‰æ‘©æµç¨‹</button>
            <button class="phase-btn" onclick="setPhase(4)" id="p4">5.0 æ•´é«”çµæŸç¨‹åº</button>
            <div class="menu-title" style="margin-top:20px;">ç³»çµ±è¨­å®š</div>
            <button class="phase-btn" onclick="resetCam()">ğŸ”„ é‡ç½®è¦–è§’</button>
            <button class="phase-btn" onclick="toggleModel()">ğŸ‘¤ åˆ‡æ›æ¨¡ç‰¹å…’</button>
        </div>

        <div class="action-card">
            <div class="instruction-title">STEP <span id="step-num">1.1</span></div>
            <div class="instruction-text" id="action-text">è¼‰å…¥ä¸­...</div>
            <div class="instruction-note" id="action-note">è«‹åƒé–± SOP æ‰‹å†Š</div>
            <div style="display:flex; justify-content: center; gap:10px;">
                <button class="nav-btn" onclick="prevStep()">ä¸Šä¸€æ­¥</button>
                <button class="nav-btn primary" onclick="forceComplete()">è·³é</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

        const BASE_URL = "https://gp01002.github.io/TMS/";

        const MODEL_CONFIG = {
            male: { pos: { x: 0.1, y: 2.32, z: 0 }, scale: 1.0, rot: { x: 1.57, y: 0, z: 1.57 } },
            female: { pos: { x: 0.1, y: 2.28, z: 0 }, scale: 1.0, rot: { x: 1.57, y: 0, z: 1.57 } }
        };
        
        const LEFT_LEG_Z = 0.12;  
        const RIGHT_LEG_Z = -0.12;
        const COORDS = {
            THIGH_ROOT: -3.3, THIGH_MID: -2.4, KNEE: -1.5, CALF_MID: -0.7, ANKLE: 0.1, FOOT: 0.3,
            CENTER_LEGS: 0
        };

        const VIEW_PRESETS = {
            overview: { 
                pcPos: {x: 2.0, y: 2.0, z: 2.0}, pcTarget: {x: 0, y: 0.5, z: 0}, 
                vrPos: {x: 0.7, z: 1.3} 
            },
            thigh: { 
                pcPos: {x: -2.0, y: 1.5, z: 1.0}, pcTarget: {x: -2.5, y: 0.5, z: 0}, 
                vrPos: {x: 0.6, z: 1.3} 
            },
            knee: { 
                pcPos: {x: -1.0, y: 1.2, z: 1.0}, pcTarget: {x: -1.5, y: 1.0, z: 0}, 
                vrPos: {x: 0.6, z: 1.3} 
            },
            calf: { 
                pcPos: {x: 0.5, y: 1.2, z: 1.0}, pcTarget: {x: -0.5, y: 0.5, z: 0}, 
                vrPos: {x: 0.6, z: 1.3} 
            },
            foot: { 
                pcPos: {x: 1.5, y: 1.0, z: 1.0}, pcTarget: {x: 0.5, y: 0.3, z: 0}, 
                vrPos: {x: 0.8, z: 1.3} 
            }
        };

        // ğŸ”¥ æ”¹é€² SOP è³‡æ–™ - ç‚ºæ‰€æœ‰æ“ä½œæ·»åŠ ç¯„åœå®šç¾©
        const learningData = {
            "1": [
                { id: "2.1", text: "æ¯›å·¾å®‰æ’«", note: "é›™æ‰‹å¾å¤§è…¿æ ¹éƒ¨æ²¿å…©å´æ»‘é †è‡³è…³åº•", type: "drag", tool: "towel", icon: "â¬œ", start: {x: COORDS.THIGH_ROOT, y: -0.2, z: 0}, end: {x: COORDS.FOOT, y: -0.3, z: 0}, view: "overview", pose: "flat" },
                { id: "2.2", text: "è…¿éƒ¨å®šä½", note: "æ”¾ç½®æ¯›å·¾æ²æ–¼é›™è…¿ä¹‹é–“", type: "click", tool: "towel_roll", icon: "ğŸŒ€", start: {x: COORDS.KNEE, y: -0.2, z: 0}, end: {x: COORDS.KNEE, y: -0.2, z: 0}, view: "knee", pose: "flat" },
                { id: "2.3", text: "åˆæ­¥èˆ’ç·©", note: "é›™æ‰‹ç”±è·Ÿè…±å‘ä¸Šé•·è·é›¢æ’«é †è‡³å¤§è…¿", type: "drag", tool: "hands", icon: "âœ¨", start: {x: COORDS.FOOT, y: -0.3, z: 0}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: 0}, view: "overview", pose: "flat" },
                { id: "2.4", text: "å–®è…¿æº–å‚™", note: "è¦†è“‹å³è…¿ï¼Œæº–å‚™æ“ä½œå·¦è…¿", type: "click", tool: "towel", icon: "ğŸ›¡ï¸", start: {x: COORDS.KNEE, y: -0.2, z: RIGHT_LEG_Z}, end: {x: COORDS.THIGH_MID, y: -0.2, z: RIGHT_LEG_Z}, view: "overview", pose: "flat" },
                { id: "2.5", text: "ä¸Šæ²¹èˆ‡é–‹å ´", note: "å·¦è…¿ä¸Šæ²¹ä¸¦åŸ·è¡Œå¤§å®‰æ’«", type: "drag", tool: "oil", icon: "ğŸ§´", start: {x: COORDS.FOOT, y: -0.3, z: LEFT_LEG_Z}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: LEFT_LEG_Z}, view: "thigh", pose: "flat" }
            ],
            "2": [
                { id: "3.1", text: "å¤§è…¿é•·æ¨æ’«", note: "æ‹‡æŒ‡ä½µæ’ï¼Œå¾è†è“‹æ¨è‡³å¤§è…¿æ ¹éƒ¨", type: "drag", tool: "thumb", icon: "ğŸ‘", start: {x: COORDS.KNEE, y: -0.2, z: LEFT_LEG_Z}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: LEFT_LEG_Z}, view: "thigh", pose: "flat" },
                { id: "3.1.2", text: "Så‹æŠ“æ (å¤§è…¿)", note: "é›™æ‰‹äº¤æ›¿Så‹ææ‹‰è‚ŒæŸ", type: "drag", tool: "hand", icon: "âœŠ", start: {x: COORDS.KNEE, y: -0.2, z: LEFT_LEG_Z}, end: {x: COORDS.THIGH_MID, y: -0.15, z: LEFT_LEG_Z}, view: "thigh", pose: "flat" },
                { id: "3.2", text: "æ¨è‡³å§”ä¸­ç©´", note: "å°è…¿é•·æ¨è‡³è†çª©ä¸­å¿ƒ", type: "drag", tool: "hand", icon: "â˜ï¸", start: {x: COORDS.ANKLE, y: -0.3, z: LEFT_LEG_Z}, end: {x: COORDS.KNEE, y: -0.25, z: LEFT_LEG_Z}, view: "calf", pose: "flat" },
                { id: "3.2.2", text: "è†çª©åˆ†å€æŒ‰å£“", note: "æŒ‰å£“å§”ä¸­ç©´å‘¨é‚Š (å…§ä¸­å¤–å¾ªç’°)", type: "press", tool: "thumb", icon: "ğŸ“", start: {x: COORDS.KNEE, y: -0.25, z: LEFT_LEG_Z}, end: {x: COORDS.KNEE, y: -0.25, z: LEFT_LEG_Z}, duration: 3, view: "knee", pose: "flat" },
                { id: "3.3", text: "è¶³éƒ¨ï¼šæ¹§æ³‰ç©´æ‰“åœˆ", note: "æŠ¬è…¿90åº¦ï¼Œæ‹‡æŒ‡é †æ™‚é˜æŒ‰å£“æ¹§æ³‰", type: "drag", tool: "thumb", icon: "ğŸ¦¶", start: {x: COORDS.FOOT, y: 0.2, z: LEFT_LEG_Z}, end: {x: COORDS.FOOT, y: 0.3, z: LEFT_LEG_Z}, view: "foot", pose: "leftRaised" }
            ],
            "3": [
                { id: "4.1", text: "å³å¤§è…¿é•·æ¨", note: "æ‹‡æŒ‡ä½µæ’ï¼Œå°ç¨±æ“ä½œ", type: "drag", tool: "thumb", icon: "ğŸ‘", start: {x: COORDS.KNEE, y: -0.2, z: RIGHT_LEG_Z}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: RIGHT_LEG_Z}, view: "thigh", pose: "flat" },
                { id: "4.2", text: "Så‹æŠ“æ (å³è…¿)", note: "é›™æ‰‹äº¤æ›¿Så‹ææ‹‰", type: "drag", tool: "hand", icon: "âœŠ", start: {x: COORDS.KNEE, y: -0.2, z: RIGHT_LEG_Z}, end: {x: COORDS.THIGH_MID, y: -0.15, z: RIGHT_LEG_Z}, view: "thigh", pose: "flat" },
                { id: "4.3", text: "å³è¶³æ¹§æ³‰ç©´", note: "æŠ¬å³è…¿90åº¦ï¼ŒæŒ‰å£“æ¹§æ³‰", type: "drag", tool: "thumb", icon: "ğŸ¦¶", start: {x: COORDS.FOOT, y: 0.2, z: RIGHT_LEG_Z}, end: {x: COORDS.FOOT, y: 0.3, z: RIGHT_LEG_Z}, view: "foot", pose: "rightRaised" }
            ],
            "4": [
                { id: "5.1", text: "å³è…¿å–®é‚Šå®‰æ’«", note: "å®Œæˆå³è…¿å¾Œé€²è¡Œé•·æ¨æ’«", type: "drag", tool: "hand", icon: "âœ¨", start: {x: COORDS.ANKLE, y: -0.3, z: RIGHT_LEG_Z}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: RIGHT_LEG_Z}, view: "overview", pose: "flat" },
                { id: "5.2", text: "æ•´é«”å¤§å®‰æ’«", note: "é›™è…¿åŒæ™‚é•·æ¨ï¼Œæ•´åˆæ„Ÿå—", type: "drag", tool: "hands", icon: "ğŸŒŠ", start: {x: COORDS.ANKLE, y: -0.3, z: 0}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: 0}, view: "overview", pose: "flat" },
                { id: "5.3", text: "è¶³åº•éœç½®", note: "æŒå¿ƒè¦†è“‹è¶³åº•ï¼Œåœç•™æ¥åœ°", type: "press", tool: "hands", icon: "ğŸ§˜", start: {x: COORDS.FOOT, y: -0.35, z: 0}, end: {x: COORDS.FOOT, y: -0.35, z: 0}, duration: 5, view: "foot", pose: "flat" },
                { id: "5.4", text: "æœ€çµ‚è¦†è“‹", note: "è“‹ä¸Šå¤§æ¯›å·¾ï¼Œå®Œæˆç™‚ç¨‹", type: "click", tool: "towel", icon: "âœ…", start: {x: COORDS.THIGH_MID, y: -0.1, z: 0}, end: {x: COORDS.KNEE, y: -0.1, z: 0}, view: "overview", pose: "flat" }
            ]
        };

        let scene, camera, renderer, controls, model;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let interactables = []; 
        let currentPhase = 1, currentStepIndex = 0;
        let isDragging = false;
        let isCameraLocked = true; 
        let ghostHand, tweenAnim, activeModelType = 'male';
        
        let modelPos = { ...MODEL_CONFIG.male.pos };
        let modelRot = { ...MODEL_CONFIG.male.rot };
        let modelScale = MODEL_CONFIG.male.scale;

        let bones = { leftUpLeg: null, leftLeg: null, rightUpLeg: null, rightLeg: null };
        let poseControls = { leftThigh: 0, leftKnee: 0, leftAnkle: 45, rightThigh: 0, rightKnee: 0, rightAnkle: 45 };
        const POSES = {
            flat: { leftThigh: 0, leftKnee: 0, leftAnkle: 45, rightThigh: 0, rightKnee: 0, rightAnkle: 45 },
            leftRaised: { leftThigh: 0, leftKnee: -90, leftAnkle: 45, rightThigh: 0, rightKnee: 0, rightAnkle: 45 }, 
            rightRaised: { leftThigh: 0, leftKnee: 0, leftAnkle: 45, rightThigh: 0, rightKnee: -90, rightAnkle: 45 } 
        };

        let vrControllers = [];
        let vrHands = [];
        let vrHandData = [];
        let handModelFactory, controllerModelFactory;
        let dolly, cameraOffset;
        let vrHitStatus = { isTouchingStart: false, touchStartTime: 0, activeHand: null };
        let isStepCompleting = false;
        
        let instructionBoardMesh, instructionCtx;
        let vr3DButtonMesh; 
        let globalEnterVRFunc = null; 
        
        let teleportLine, teleportReticle, teleportReticleInner;
        let isTeleporting = false;
        let teleportTarget = new THREE.Vector3();
        let pinchStartTime = 0; 
        const TELEPORT_DELAY = 1500;
        
        let interactionLine;
        let trajectoryLine;
        let areaIndicator; // ğŸ”¥ æ–°å¢ï¼šç¯„åœæŒ‡ç¤ºå™¨

        // ğŸ”¥ å„ªåŒ– VR é…ç½®
        const VR_CONFIG = {
            DETECTION_RADIUS: 0.50,        // ğŸ”¥ å†å¢å¤§ä¸€äº›
            PRESS_DURATION: 0.4,
            HAND_INDICATOR_SIZE: 0.12,
            HAPTIC_INTENSITY: 1.0,
            HAPTIC_DURATION: 150,
            PINCH_THRESHOLD: 0.04,
            SPHERE_SIZE: 0.15              // ğŸ”¥ 3D çƒé«”å¤§å°
        };

        function safeSetText(id, text) { const el = document.getElementById(id); if (el) el.innerText = text; }

        function initApp() {
            document.getElementById('spinner').style.display = 'block';
            document.querySelector('.start-btn').style.display = 'none';
            setTimeout(initThreeJS, 100);
        }

        function updateCameraView(stepData) {
            if (!isCameraLocked) return;
            const viewKey = stepData.view || "overview";
            const viewConfig = VIEW_PRESETS[viewKey] || VIEW_PRESETS.overview;

            if (renderer.xr.isPresenting) {
                gsap.to(dolly.position, {
                    x: viewConfig.vrPos.x,
                    z: viewConfig.vrPos.z,
                    duration: 2.0,
                    ease: "power2.inOut"
                });
            } else {
                gsap.to(camera.position, {
                    x: viewConfig.pcPos.x, y: viewConfig.pcPos.y, z: viewConfig.pcPos.z,
                    duration: 1.5, ease: "power2.inOut"
                });
                gsap.to(controls.target, {
                    x: viewConfig.pcTarget.x, y: viewConfig.pcTarget.y, z: viewConfig.pcTarget.z,
                    duration: 1.5, ease: "power2.inOut", onUpdate: () => controls.update()
                });
            }
        }

        function createInstructionBoard() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            instructionCtx = canvas.getContext('2d');
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0.9, side: THREE.DoubleSide });
            
            const geometry = new THREE.PlaneGeometry(1.8, 0.9);
            instructionBoardMesh = new THREE.Mesh(geometry, material);
            instructionBoardMesh.position.set(-1.0, 3.2, -2.0); 
            instructionBoardMesh.rotation.set(0, 0, 0); 
            scene.add(instructionBoardMesh);
            
            const btnGeo = new THREE.BoxGeometry(0.5, 0.5, 0.1);
            const btnMat = new THREE.MeshBasicMaterial({ color: 0x00aa00 });
            vr3DButtonMesh = new THREE.Mesh(btnGeo, btnMat);
            vr3DButtonMesh.position.set(1.2, 0, 0.1); 
            
            const btnCanvas = document.createElement('canvas');
            btnCanvas.width = 256; btnCanvas.height = 256;
            const btnCtx = btnCanvas.getContext('2d');
            btnCtx.fillStyle = '#00aa00';
            btnCtx.fillRect(0,0,256,256);
            btnCtx.fillStyle = 'white';
            btnCtx.font = 'bold 40px Arial';
            btnCtx.textAlign = 'center';
            btnCtx.textBaseline = 'middle';
            btnCtx.fillText("é»æ“Šé€²å…¥", 128, 100);
            btnCtx.fillText("VR", 128, 160);
            
            vr3DButtonMesh.material = new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(btnCanvas) });
            instructionBoardMesh.add(vr3DButtonMesh); 
            interactables.push(vr3DButtonMesh); 

            updateInstructionBoard("æ­¡è¿ä½¿ç”¨ VR æ•™å­¸", "è«‹æåˆæ‰‹æŒ‡å‚³é€è‡³åºŠé‚Š");
        }

        function updateInstructionBoard(title, text) {
            if (!instructionCtx) return;
            const ctx = instructionCtx;
            ctx.fillStyle = '#222222'; ctx.fillRect(0, 0, 1024, 512);
            ctx.strokeStyle = '#667eea'; ctx.lineWidth = 20; ctx.strokeRect(10, 10, 1004, 492);
            ctx.textAlign = 'center';
            ctx.fillStyle = '#8ec5fc'; ctx.font = 'bold 60px "Microsoft JhengHei"'; ctx.fillText(title, 512, 130);
            ctx.fillStyle = '#ffffff'; ctx.font = 'bold 80px "Microsoft JhengHei"'; ctx.fillText(text, 512, 280);
            ctx.fillStyle = '#aaaaaa'; ctx.font = '40px "Microsoft JhengHei"'; ctx.fillText("æ“ä½œæç¤ºï¼šè«‹çœ‹å°é¢é«˜ç‰†é»‘æ¿", 512, 420);
            instructionBoardMesh.material.map.needsUpdate = true;
        }

        function createTeleportVisuals() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(30 * 3); 
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            teleportLine = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 }));
            teleportLine.visible = false; scene.add(teleportLine);

            const ringGeo = new THREE.RingGeometry(0.20, 0.25, 32); ringGeo.rotateX(-Math.PI / 2); 
            teleportReticle = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide }));
            teleportReticle.visible = false; scene.add(teleportReticle);
            
            const innerGeo = new THREE.CircleGeometry(0.18, 32); innerGeo.rotateX(-Math.PI / 2);
            teleportReticleInner = new THREE.Mesh(innerGeo, new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5 }));
            teleportReticleInner.visible = false; teleportReticleInner.scale.set(0, 0, 0); teleportReticle.add(teleportReticleInner);
        }

        function createVRInstructions() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 768;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, 1024, 768);
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 48px "Microsoft JhengHei"';
            ctx.textAlign = 'center';
            ctx.fillText('VR æ“ä½œæŒ‡å—', 512, 80);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '36px "Microsoft JhengHei"';
            ctx.textAlign = 'left';
            const tips = [
                'ğŸŸ¢ ç¶ è‰²çƒé«”ï¼šèµ·é»ï¼ˆé è¿‘é–‹å§‹ï¼‰',
                'ğŸ”´ ç´…è‰²çƒé«”ï¼šçµ‚é»ï¼ˆæ‹–æ‹½ç›®æ¨™ï¼‰',
                'ğŸ”µ é’è‰²å€åŸŸï¼šæ“ä½œè¦†è“‹ç¯„åœ',
                'ğŸ‘† é£ŸæŒ‡é è¿‘ç¶ çƒå³å¯è§¸ç™¼',
                'ğŸ¤ æåˆæ‰‹æŒ‡ 1.5 ç§’å‚³é€'
            ];
            tips.forEach((tip, i) => {
                ctx.fillText(tip, 100, 200 + i * 90);
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            const geometry = new THREE.PlaneGeometry(2, 1.5);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(-1, 2, 0.5);
            mesh.rotation.y = Math.PI / 4;
            scene.add(mesh);
        }

        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 5, 15);
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const spotLight = new THREE.SpotLight(0xffeeb1, 1.5);
            spotLight.position.set(2, 6, 2);
            scene.add(spotLight);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);
            camera.position.set(1.5, 2.5, 2.5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true; 
            container.appendChild(renderer.domElement);

            const vrButton = createVRButton(renderer);
            document.body.appendChild(vrButton);

            dolly = new THREE.Group();
            dolly.position.set(0.7, 0, 1.0); 
            scene.add(dolly);
            
            cameraOffset = new THREE.Group();
            cameraOffset.position.y = 2.75; 
            dolly.add(cameraOffset);
            cameraOffset.add(camera);
            
            const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]);
            interactionLine = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ 
                color: 0x00ffff,
                linewidth: 3,
                transparent: true,
                opacity: 0.7
            }));
            interactionLine.visible = false;
            scene.add(interactionLine);

            const trajGeo = new THREE.BufferGeometry();
            const trajPos = new Float32Array(50 * 3);
            trajGeo.setAttribute('position', new THREE.BufferAttribute(trajPos, 3));
            trajectoryLine = new THREE.Line(trajGeo, new THREE.LineDashedMaterial({ color: 0xffff00, dashSize: 0.1, gapSize: 0.05, scale: 1 }));
            trajectoryLine.computeLineDistances();
            trajectoryLine.visible = false;
            scene.add(trajectoryLine);
            
            createInstructionBoard();
            createTeleportVisuals();
            createGhostHand(); 
            createVRInstructions();
            setupVRHands();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0); 
            controls.enabled = false; 
            controls.update();

            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onPointerDown);
            canvas.addEventListener('mousemove', onPointerMove);
            canvas.addEventListener('mouseup', onPointerUp);
            canvas.addEventListener('touchstart', onTouchStart, {passive: false});
            canvas.addEventListener('touchmove', onTouchMove, {passive: false});
            canvas.addEventListener('touchend', onPointerUp);
            window.addEventListener('resize', onWindowResize);

            renderer.setAnimationLoop(() => {
                if (renderer.xr.isPresenting) {
                    handleVRInteraction();
                    handleTeleportation(); 
                    updateVRStatus(); 
                } else {
                    controls.update();
                }
                interactables.forEach(obj => { if(obj.tick) obj.tick(); });
                if (ghostHand && ghostHand.visible) {
                    ghostHand.lookAt(dolly.position.x, dolly.position.y + 1.6, dolly.position.z);
                }
                renderer.render(scene, camera);
            });

            loadEnvironment();
        }

        function createVRButton(renderer) {
            const button = document.createElement('button');
            button.style.position = 'absolute'; button.style.top = '10%'; button.style.left = '50%'; button.style.transform = 'translateX(-50%)';
            button.style.padding = '15px 40px'; button.style.border = '2px solid rgba(0, 255, 0, 0.5)'; button.style.borderRadius = '50px';
            button.style.background = 'rgba(0, 30, 0, 0.7)'; button.style.backdropFilter = 'blur(5px)';
            button.style.color = '#00ff00'; button.style.font = 'bold 20px "Microsoft JhengHei", monospace';
            button.style.cursor = 'pointer'; button.style.zIndex = '999'; button.style.display = 'none'; button.style.transition = 'all 0.3s ease';
            button.onmouseover = () => { button.style.transform = 'translateX(-50%) scale(1.05)'; };
            button.onmouseout = () => { button.style.transform = 'translateX(-50%) scale(1)'; };
            
            function showEnterVR() {
                let currentSession = null;
                button.textContent = 'ğŸ¥½ é€²å…¥ VR'; button.style.display = '';
                const enterVR = async () => {
                    if (!currentSession) {
                        const sessionInit = { optionalFeatures: ['local-floor', 'hand-tracking'] };
                        try {
                            const session = await navigator.xr.requestSession('immersive-vr', sessionInit);
                            currentSession = session;
                            session.addEventListener('end', () => { 
                                currentSession = null; button.textContent = 'ğŸ¥½ é€²å…¥ VR'; vr3DButtonMesh.visible = true; document.body.classList.remove('vr-active'); 
                            });
                            await renderer.xr.setSession(session);
                            button.textContent = 'ğŸšª é€€å‡º VR'; vr3DButtonMesh.visible = false; document.body.classList.add('vr-active');
                        } catch(e) { alert("VR Error: " + e.message); }
                    } else { currentSession.end(); }
                };
                button.onclick = enterVR; globalEnterVRFunc = enterVR; 
            }
            if ('xr' in navigator) navigator.xr.isSessionSupported('immersive-vr').then(s => s ? showEnterVR() : null);
            return button;
        }

        function setupVRHands() {
            handModelFactory = new XRHandModelFactory();
            controllerModelFactory = new XRControllerModelFactory();
            
            for (let i = 0; i < 2; i++) {
                const controller = renderer.xr.getController(i); cameraOffset.add(controller); vrControllers.push(controller);
                const hand = renderer.xr.getHand(i); cameraOffset.add(hand); 
                try { const handModel = handModelFactory.createHandModel(hand, "mesh"); hand.add(handModel); } catch (e) {}
                
                const handData = { hand: hand, handIndex: i, handedness: null, isTracking: false, indexTip: null, thumbTip: null, wrist: null, indicator: null, isPinching: false };
                
                const indicator = new THREE.Mesh(
                    new THREE.SphereGeometry(VR_CONFIG.HAND_INDICATOR_SIZE, 32, 32), 
                    new THREE.MeshStandardMaterial({ 
                        color: 0x00ff00, 
                        transparent: true, 
                        opacity: 0.6,
                        emissive: 0x00ff00,
                        emissiveIntensity: 0.5
                    })
                );
                indicator.visible = false; scene.add(indicator); handData.indicator = indicator;
                
                hand.addEventListener('connected', (e) => { handData.handedness = e.data.handedness; handData.isTracking = true; safeSetText('hand-track-status', `${e.data.handedness} OK`); });
                hand.addEventListener('disconnected', () => { handData.isTracking = false; handData.indicator.visible = false; });
                vrHands.push(hand); vrHandData.push(handData);
            }
        }

        function updateVRStatus() {
            vrHandData.forEach(handData => {
                if (!handData.isTracking) return;
                const hand = handData.hand;
                if (hand.joints && hand.joints['index-finger-tip']) {
                    handData.indexTip = hand.joints['index-finger-tip'];
                    handData.thumbTip = hand.joints['thumb-tip'];
                    handData.wrist = hand.joints['wrist'];
                    
                    const worldPos = new THREE.Vector3();
                    handData.indexTip.getWorldPosition(worldPos);
                    if (handData.indicator) {
                        handData.indicator.position.copy(worldPos);
                        handData.indicator.visible = true;
                    }
                }
            });
            
            const currentData = learningData[String(currentPhase)];
            if (currentData && interactables.length > 0) {
                const startObj = interactables.find(obj => obj.userData.isStart || (!obj.userData.isEnd && !obj.userData.isStart));
                if (startObj) {
                    vrHandData.forEach(handData => {
                        if (handData.indicator && handData.indicator.visible) {
                            const dist = handData.indicator.position.distanceTo(startObj.position);
                            if (dist < 1.0) {
                                safeSetText('distance-status', `${(dist * 100).toFixed(0)}cm`);
                            }
                        }
                    });
                }
            }
        }

        function handleTeleportation() {
            if (isStepCompleting) return; 
            let anyHandPinching = false;
            vrHandData.forEach(handData => {
                if (!handData.isTracking || !handData.indexTip || !handData.thumbTip || !handData.wrist) return;
                const indexPos = new THREE.Vector3(); const thumbPos = new THREE.Vector3(); const wristPos = new THREE.Vector3();
                handData.indexTip.getWorldPosition(indexPos); handData.thumbTip.getWorldPosition(thumbPos); handData.wrist.getWorldPosition(wristPos);
                
                const pinchDist = indexPos.distanceTo(thumbPos);
                const isPinching = pinchDist < VR_CONFIG.PINCH_THRESHOLD;
                const isInteracting = handData.indicator.material.color.getHex() !== 0x00ff00; 
                if (isInteracting) return; 

                if (isPinching) {
                    anyHandPinching = true;
                    if (!handData.isPinching) { handData.isPinching = true; pinchStartTime = Date.now(); safeSetText('move-status', 'â³ é›†æ°£...'); teleportReticleInner.scale.set(0, 0, 0); }
                    const elapsed = Date.now() - pinchStartTime;
                    const progress = Math.min(elapsed / TELEPORT_DELAY, 1.0);
                    
                    const direction = new THREE.Vector3().subVectors(indexPos, wristPos).normalize();
                    const startPoint = indexPos.clone();
                    let targetPoint = new THREE.Vector3();
                    if (direction.y < -0.1) { 
                        const t = -startPoint.y / direction.y;
                        if (t > 0 && t < 10) targetPoint.copy(startPoint).add(direction.multiplyScalar(t)); else targetPoint.copy(startPoint).add(direction.multiplyScalar(3));
                    } else { targetPoint.copy(startPoint).add(direction.multiplyScalar(3)); }
                    targetPoint.y = 0; 

                    let color = 0xff0000; 
                    if (elapsed > TELEPORT_DELAY) { color = 0x00ff00; safeSetText('move-status', 'âœ… æ”¾é–‹å‚³é€'); } else { color = 0xffff00; safeSetText('move-status', `â³ ${((TELEPORT_DELAY - elapsed)/1000).toFixed(1)}s`); }

                    updateTeleportCurve(startPoint, targetPoint, color);
                    teleportReticle.position.copy(targetPoint); teleportReticle.material.color.setHex(color); teleportReticle.visible = true; teleportLine.visible = true;
                    teleportReticleInner.visible = true; teleportReticleInner.scale.set(progress, progress, 1); teleportReticleInner.material.color.setHex(color);
                    
                    if (elapsed > TELEPORT_DELAY) { teleportTarget.copy(targetPoint); isTeleporting = true; } else { isTeleporting = false; }
                } else {
                    if (handData.isPinching) {
                        handData.isPinching = false;
                        if (isTeleporting) {
                            dolly.position.x = teleportTarget.x; dolly.position.z = teleportTarget.z;
                            safeSetText('move-status', 'ğŸš€ å·²å‚³é€'); triggerHaptic(handData, 1.0, 200);
                        } else { safeSetText('move-status', 'âŒ å–æ¶ˆ'); }
                        teleportLine.visible = false; teleportReticle.visible = false; isTeleporting = false;
                    }
                }
            });
            if (!anyHandPinching) { teleportLine.visible = false; teleportReticle.visible = false; }
        }

        function updateTeleportCurve(start, end, color) {
            const positions = teleportLine.geometry.attributes.position.array;
            teleportLine.material.color.setHex(color);
            const p0 = start; const p2 = end; const p1 = new THREE.Vector3().lerpVectors(p0, p2, 0.5); p1.y += 1.5; 
            for (let i = 0; i < 30; i++) {
                const t = i / 29;
                const tx = (1-t)*(1-t)*p0.x + 2*(1-t)*t*p1.x + t*t*p2.x;
                const ty = (1-t)*(1-t)*p0.y + 2*(1-t)*t*p1.y + t*t*p2.y;
                const tz = (1-t)*(1-t)*p0.z + 2*(1-t)*t*p1.z + t*t*p2.z;
                positions[i * 3] = tx; positions[i * 3 + 1] = ty; positions[i * 3 + 2] = tz;
            }
            teleportLine.geometry.attributes.position.needsUpdate = true;
        }

        function handleVRInteraction() {
            if (!interactables.length || isStepCompleting) return;
            const currentData = learningData[String(currentPhase)];
            if (!currentData) return;
            const step = currentData[currentStepIndex];
            
            const startObj = interactables.find(obj => obj.userData.isStart || (!obj.userData.isEnd && !obj.userData.isStart));
            const endObj = interactables.find(obj => obj.userData.isEnd);
            if (!startObj) return;

            vrHandData.forEach(handData => {
                if (!handData.isTracking || !handData.indicator || !handData.indicator.visible) return;
                const indexTipWorldPos = handData.indicator.position;
                const distToStart = indexTipWorldPos.distanceTo(startObj.position);
                
                if (distToStart < 0.8) {
                    interactionLine.visible = true;
                    const points = interactionLine.geometry.attributes.position.array;
                    points[0] = indexTipWorldPos.x; points[1] = indexTipWorldPos.y; points[2] = indexTipWorldPos.z;
                    points[3] = startObj.position.x; points[4] = startObj.position.y; points[5] = startObj.position.z;
                    interactionLine.geometry.attributes.position.needsUpdate = true;
                } else { interactionLine.visible = false; }
                
                if (step.type === 'click') handleClickInteraction(distToStart, handData, startObj);
                else if (step.type === 'press') handlePressInteraction(distToStart, handData, startObj, step.duration || VR_CONFIG.PRESS_DURATION);
                else if (step.type === 'drag') handleDragInteraction(distToStart, indexTipWorldPos, handData, startObj, endObj);
            });
        }

        function handleClickInteraction(distance, handData, targetObj) {
            if (distance < VR_CONFIG.DETECTION_RADIUS) {
                handData.indicator.material.color.set(0xff0000);
                handData.indicator.material.emissiveIntensity = 1.0;
                safeSetText('interaction-status', 'ğŸ”´ é»æ“Šä¸­');
                if (!vrHitStatus.touchStartTime) {
                    vrHitStatus.touchStartTime = Date.now(); vrHitStatus.activeHand = handData.handedness;
                    triggerHaptic(handData, 0.8, 100);
                    playClickFeedback(targetObj);
                } else {
                    if ((Date.now() - vrHitStatus.touchStartTime) / 1000 >= 0.3) { 
                        safeSetText('interaction-status', 'âœ… å®Œæˆ');
                        completeStepVR(); 
                        vrHitStatus.touchStartTime = 0; 
                    }
                }
            } else { 
                handData.indicator.material.color.set(0x00ff00); 
                handData.indicator.material.emissiveIntensity = 0.5;
                if (distance < 1.0) safeSetText('interaction-status', 'ğŸŸ¡ æ¥è¿‘ä¸­');
                else safeSetText('interaction-status', 'âšª å¾…æ©Ÿä¸­');
                if(vrHitStatus.activeHand === handData.handedness) vrHitStatus.touchStartTime = 0; 
            }
        }

        function handlePressInteraction(distance, handData, targetObj, requiredDuration) {
            if (distance < VR_CONFIG.DETECTION_RADIUS) {
                handData.indicator.material.color.set(0xffff00);
                handData.indicator.material.emissiveIntensity = 1.0;
                if (!vrHitStatus.touchStartTime) { 
                    vrHitStatus.touchStartTime = Date.now(); 
                    vrHitStatus.activeHand = handData.handedness; 
                    triggerHaptic(handData, 0.5, 50); 
                    safeSetText('interaction-status', 'ğŸŸ¡ æŒ‰å£“ä¸­...');
                }
                else {
                    const elapsed = (Date.now() - vrHitStatus.touchStartTime) / 1000;
                    const progress = Math.min(elapsed / requiredDuration, 1.0) * 100;
                    safeSetText('interaction-status', `ğŸŸ¡ æŒ‰å£“ ${progress.toFixed(0)}%`);
                    targetObj.scale.setScalar(1 + Math.min(elapsed / requiredDuration, 1) * 0.3);
                    if (elapsed >= requiredDuration) { 
                        triggerHaptic(handData, 1.0, 200);
                        safeSetText('interaction-status', 'âœ… å®Œæˆ');
                        completeStepVR(); 
                        vrHitStatus.touchStartTime = 0; 
                    }
                }
            } else { 
                handData.indicator.material.color.set(0x00ff00); 
                handData.indicator.material.emissiveIntensity = 0.5;
                targetObj.scale.set(1,1,1); 
                if (distance < 1.0) safeSetText('interaction-status', 'ğŸŸ¢ æ¥è¿‘ä¸­');
                else safeSetText('interaction-status', 'âšª å¾…æ©Ÿä¸­');
                if(vrHitStatus.activeHand === handData.handedness) vrHitStatus.touchStartTime = 0; 
            }
        }

        function handleDragInteraction(distToStart, indexPos, handData, startObj, endObj) {
            if (!vrHitStatus.isTouchingStart) {
                if (distToStart < VR_CONFIG.DETECTION_RADIUS) {
                    vrHitStatus.isTouchingStart = true; vrHitStatus.activeHand = handData.handedness;
                    handData.indicator.material.color.set(0xffff00);
                    handData.indicator.scale.setScalar(1.5);
                    handData.indicator.material.emissiveIntensity = 1.0;
                    triggerHaptic(handData, 0.8, 100);
                    safeSetText('interaction-status', 'ğŸŸ¡ é–‹å§‹æ‹–æ‹½');
                    if (startObj.userData.sphere) startObj.userData.sphere.material.color.set(0xffff00);
                    if (endObj) {
                        endObj.visible = true;
                        gsap.to(endObj.scale, { x: 1.3, y: 1.3, z: 1.3, duration: 0.5, yoyo: true, repeat: -1 });
                    }
                }
            } else if (vrHitStatus.activeHand === handData.handedness) {
                handData.indicator.material.color.set(0xffa500);
                if (endObj) {
                    const distToEnd = indexPos.distanceTo(endObj.position);
                    const totalDist = startObj.position.distanceTo(endObj.position);
                    const progress = 1 - Math.min(distToEnd / totalDist, 1);
                    
                    safeSetText('interaction-status', `ğŸŸ  é€²åº¦ ${(progress * 100).toFixed(0)}%`);
                    if (startObj.userData.sphere) startObj.userData.sphere.material.opacity = 0.3 + progress * 0.7;
                    handData.indicator.material.emissiveIntensity = progress;
                    
                    if (distToEnd < VR_CONFIG.DETECTION_RADIUS * 1.2) {
                        triggerHaptic(handData, 1.0, 200);
                        safeSetText('interaction-status', 'âœ… å®Œæˆ');
                        completeStepVR(); 
                        vrHitStatus.isTouchingStart = false;
                        handData.indicator.scale.setScalar(1);
                    }
                }
            }
        }

        function triggerHaptic(handData, intensity = 1.0, duration = 200) {
            vrControllers.forEach(c => { if(c.gamepad?.hapticActuators?.length) c.gamepad.hapticActuators[0].pulse(intensity, duration); });
        }
        function playClickFeedback(obj) { gsap.to(obj.scale, { x: 1.5, y: 1.5, z: 1.5, duration: 0.2, yoyo: true, repeat: 1 }); }
        function completeStepVR() {
            if (isStepCompleting) return; isStepCompleting = true;
            interactables.forEach(obj => gsap.to(obj.scale, { x: 0, y: 0, z: 0, duration: 0.4 }));
            if (areaIndicator) gsap.to(areaIndicator.scale, { x: 0, y: 0, z: 0, duration: 0.4 });
            setTimeout(() => { nextStep(); isStepCompleting = false; }, 1000);
        }

        function checkIntersection() {
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -model.position.y);
            const point = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, point);
            
            const intersects = raycaster.intersectObjects(interactables, true);
            if (intersects.length > 0) {
                const obj = intersects[0].object;
                if (obj === vr3DButtonMesh && globalEnterVRFunc) { globalEnterVRFunc(); return; }
                
                const currentData = learningData[String(currentPhase)]; 
                if (!currentData) return;

                const step = currentData[currentStepIndex];
                if (isDragging && (step.type === 'press' || step.type === 'click')) {
                    isDragging = false; const targetGroup = intersects[0].object.parent;
                    if (targetGroup) gsap.to(targetGroup.scale, { x: 1.5, y: 1.5, z: 1.5, duration: 0.2, yoyo: true, repeat: 1 });
                    setTimeout(() => { nextStep(); }, 800);
                }
            }

            if (point && isDragging) {
                if (ghostHand) {
                    ghostHand.visible = true; ghostHand.position.copy(point); ghostHand.position.y += 0.2;
                    const currentData = learningData[String(currentPhase)];
                    if (currentData) {
                        const step = currentData[currentStepIndex];
                        if (step.type === 'drag') {
                            const endPos = new THREE.Vector3(step.end.x + model.position.x, step.end.y + model.position.y, step.end.z + model.position.z);
                            if (ghostHand.position.distanceTo(endPos) < 0.8) {
                                isDragging = false; if (!isCameraLocked) controls.enabled = true; setTimeout(() => { nextStep(); }, 500);
                            }
                        }
                    }
                }
            }
        }

        function onTouchStart(e) { e.preventDefault(); onPointerDown(e.touches[0]); }
        function onTouchMove(e) { e.preventDefault(); onPointerMove(e.touches[0]); }
        function onPointerDown(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([vr3DButtonMesh], true);
            if (intersects.length > 0 && globalEnterVRFunc) { globalEnterVRFunc(); return; }
            const gameIntersects = raycaster.intersectObjects(interactables, true);
            if (gameIntersects.length > 0) { isDragging = true; controls.enabled = false; checkIntersection(); } else { controls.enabled = true; }
        }
        function onPointerMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            if (isDragging) { raycaster.setFromCamera(mouse, camera); checkIntersection(); }
        }
        function onPointerUp() {
            if (isDragging) { checkIntersection(); isDragging = false; if (!isCameraLocked) controls.enabled = true; if (ghostHand) ghostHand.visible = false; }
        }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        function loadEnvironment() {
            const loader = new GLTFLoader(); 
            loader.load(BASE_URL + 'A01.glb', (gltf) => {
                const room = gltf.scene; room.scale.set(20, 20, 20);
                room.traverse(c => { if (c.isMesh) c.receiveShadow = true; }); scene.add(room);
            });
            loadModel('male');
        }
        
        function loadModel(type) {
            if (model) scene.remove(model);
            activeModelType = type;
            const config = MODEL_CONFIG[type];
            modelPos = { ...config.pos };
            modelRot = { ...config.rot };
            modelScale = config.scale;

            const loader = new GLTFLoader();
            loader.load(BASE_URL + (type === 'male' ? 'B01.glb' : 'B02.glb'), (gltf) => {
                model = gltf.scene;
                model.position.set(modelPos.x, modelPos.y, modelPos.z);
                model.scale.set(modelScale, modelScale, modelScale);
                model.rotation.set(modelRot.x, modelRot.y, modelRot.z);
                
                model.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true; child.receiveShadow = true; child.frustumCulled = false;
                        if (child.material) { child.material = new THREE.MeshStandardMaterial({ color: child.material.color, map: child.material.map, skinning: true }); }
                    }
                });
                bones = {};
                model.traverse(child => {
                    if (child.isBone) {
                        const name = child.name.toLowerCase().replace(/[^a-z0-9]/g, '');
                        if (name.includes('left') && name.includes('thigh')) bones.leftUpLeg = child;
                        else if (name.includes('left') && name.includes('leg')) bones.leftLeg = child;
                        else if (name.includes('right') && name.includes('thigh')) bones.rightUpLeg = child;
                        else if (name.includes('right') && name.includes('leg')) bones.rightLeg = child;
                    }
                });
                scene.add(model); applyPose('flat');
                document.getElementById('welcome').style.display = 'none'; document.getElementById('ui').style.display = 'block';
                setPhase(1);
            });
        }

        function setPhase(p) {
            currentPhase = p; currentStepIndex = 0;
            document.querySelectorAll('.phase-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('p' + p); if (btn) btn.classList.add('active');
            if (btn) safeSetText('phase-title', btn.innerText);
            setupStep();
        }

        function setupStep() {
            interactables.forEach(obj => { if (obj !== vr3DButtonMesh) scene.remove(obj); });
            interactables = [vr3DButtonMesh]; 
            if (areaIndicator) { scene.remove(areaIndicator); areaIndicator = null; }

            const currentData = learningData[String(currentPhase)];
            if (!currentData) { console.warn("Learning data undefined for phase:", currentPhase); return; }

            const step = currentData[currentStepIndex];
            if (!step) return;

            safeSetText('step-num', step.id); safeSetText('action-text', step.text); safeSetText('action-note', step.note);
            updateInstructionBoard(`STEP ${step.id} ${step.text}`, step.note); 
            
            updateCameraView(step);

            if (step.pose) applyPose(step.pose); else applyPose('flat');
            
            vrHitStatus = { isTouchingStart: false, touchStartTime: 0, activeHand: null };

            // ğŸ”¥ å‰µå»ºç¯„åœæŒ‡ç¤ºå™¨ï¼ˆç„¡è«–ä»€éº¼é¡å‹ï¼‰
            createAreaIndicator(step.start, step.end);

            if (step.type === 'drag') {
                const startObj = create3DInteractable(step.start, 0x00ff00, 'start'); 
                startObj.userData.isStart = true;
                const endObj = create3DInteractable(step.end, 0xff0000, 'end', true); 
                endObj.userData.isEnd = true;
                showGhostGuide(step.start, step.end, true);
            } else {
                create3DInteractable(step.start, 0x00ff00, step.type);
                showGhostGuide(step.start, step.end || step.start, false);
            }
        }

        // ğŸ”¥ æ–°å¢ï¼šå‰µå»ºç¯„åœæŒ‡ç¤ºå™¨
        function createAreaIndicator(start, end) {
            const startPos = new THREE.Vector3(start.x + model.position.x, start.y + model.position.y, start.z + model.position.z);
            const endPos = new THREE.Vector3(end.x + model.position.x, end.y + model.position.y, end.z + model.position.z);
            
            const distance = startPos.distanceTo(endPos);
            const center = new THREE.Vector3().lerpVectors(startPos, endPos, 0.5);
            
            // å‰µå»ºåŠé€æ˜é’è‰²åœ“æŸ±é«”è¡¨ç¤ºç¯„åœ
            const geometry = new THREE.CylinderGeometry(0.15, 0.15, Math.max(distance, 0.2), 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            areaIndicator = new THREE.Mesh(geometry, material);
            
            // å®šä½ä¸¦æ—‹è½‰
            areaIndicator.position.copy(center);
            if (distance > 0.1) {
                const direction = new THREE.Vector3().subVectors(endPos, startPos).normalize();
                areaIndicator.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
            }
            
            scene.add(areaIndicator);
            
            // è„ˆå‹•å‹•ç•«
            gsap.to(areaIndicator.material, { opacity: 0.35, duration: 1, yoyo: true, repeat: -1, ease: "sine.inOut" });
        }

        // ğŸ”¥ å…¨æ–°ï¼šå‰µå»º 3D äº’å‹•çƒé«”
        function create3DInteractable(pos, color, type, isHidden = false) {
            const group = new THREE.Group();
            group.position.set(pos.x + model.position.x, pos.y + model.position.y + 0.1, pos.z + model.position.z);
            
            // ğŸ”¥ æ ¸å¿ƒçƒé«”ï¼ˆæ›´å¤§æ›´å®¹æ˜“é»æ“Šï¼‰
            const sphereGeometry = new THREE.SphereGeometry(VR_CONFIG.SPHERE_SIZE, 32, 32);
            const sphereMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.8,
                metalness: 0.3,
                roughness: 0.4
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            group.add(sphere);
            
            // ğŸ”¥ å¤–åœˆå…‰ç’°
            const ringGeometry = new THREE.RingGeometry(VR_CONFIG.DETECTION_RADIUS * 0.8, VR_CONFIG.DETECTION_RADIUS, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            group.add(ring);
            
            // ğŸ”¥ ç¢°æ’æª¢æ¸¬çƒé«”ï¼ˆæ›´å¤§ï¼‰
            const hitBox = new THREE.Mesh(
                new THREE.SphereGeometry(VR_CONFIG.DETECTION_RADIUS, 16, 16), 
                new THREE.MeshBasicMaterial({ visible: false })
            );
            group.add(hitBox);
            
            // å„²å­˜çƒé«”å¼•ç”¨
            group.userData.sphere = sphere;
            group.userData.ring = ring;
            
            if (isHidden) group.visible = false;
            scene.add(group); 
            interactables.push(group);
            
            // ğŸ”¥ å‹•ç•«
            gsap.to(sphere.scale, { x: 1.2, y: 1.2, z: 1.2, duration: 1, yoyo: true, repeat: -1, ease: "sine.inOut" });
            gsap.to(ring.scale, { x: 1.15, y: 1.15, duration: 1.2, yoyo: true, repeat: -1, ease: "sine.inOut" });
            gsap.to(sphere.rotation, { y: Math.PI * 2, duration: 4, repeat: -1, ease: "none" });
            
            group.tick = () => { 
                ring.lookAt(camera.position);
            };
            return group;
        }

        function createGhostHand() {
            const texture = createEmojiTexture('âœ‹');
            const geometry = new THREE.PlaneGeometry(0.5, 0.5);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0.8, depthTest: false, side: THREE.DoubleSide });
            ghostHand = new THREE.Mesh(geometry, material); ghostHand.renderOrder = 999;
            scene.add(ghostHand); ghostHand.visible = false;
        }

        function createEmojiTexture(emoji) {
            const c = document.createElement('canvas'); c.width = 128; c.height = 128;
            const ctx = c.getContext('2d'); ctx.font = '100px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(emoji, 64, 64); return new THREE.CanvasTexture(c);
        }

        function showGhostGuide(startRel, endRel, isMove) {
            if (!ghostHand) createGhostHand();
            
            ghostHand.visible = true;
            
            const start = {
                x: startRel.x + model.position.x,
                y: startRel.y + model.position.y + 0.2,
                z: startRel.z + model.position.z
            };

            if (isMove) {
                const end = {
                    x: endRel.x + model.position.x,
                    y: endRel.y + model.position.y + 0.2,
                    z: endRel.z + model.position.z
                };

                ghostHand.position.set(start.x, start.y, start.z);
                
                if (tweenAnim) tweenAnim.kill();
                
                tweenAnim = gsap.timeline({ repeat: -1, repeatDelay: 1 });
                tweenAnim.to(ghostHand.position, {
                    x: end.x, y: end.y, z: end.z,
                    duration: 2.0, 
                    ease: "power2.inOut"
                }).to(ghostHand.material, { opacity: 0, duration: 0.5 });

                const points = [new THREE.Vector3(start.x, start.y - 0.1, start.z), new THREE.Vector3(end.x, end.y - 0.1, end.z)];
                trajectoryLine.geometry.setFromPoints(points);
                trajectoryLine.computeLineDistances();
                trajectoryLine.visible = true;

            } else {
                ghostHand.position.set(start.x, start.y + 0.3, start.z);
                if (tweenAnim) tweenAnim.kill();
                tweenAnim = gsap.to(ghostHand.position, {
                    y: start.y, duration: 0.8, yoyo: true, repeat: -1
                });
                trajectoryLine.visible = false;
            }
        }

        function nextStep() {
            const list = learningData[String(currentPhase)];
            if (currentStepIndex < list.length - 1) { currentStepIndex++; setupStep(); } 
            else { if (learningData[String(currentPhase + 1)]) setTimeout(() => setPhase(currentPhase + 1), 2000); else setTimeout(() => setPhase(1), 2000); }
        }

        function prevStep() { if (currentStepIndex > 0) { currentStepIndex--; setupStep(); } }
        function forceComplete() { nextStep(); }
        function resetCam() { if (!renderer.xr.isPresenting) controls.reset(); }
        
        function toggleCameraLock() { 
            isCameraLocked = !isCameraLocked; 
            controls.enabled = !isCameraLocked;
            const btn = document.getElementById('lock-btn');
            if(isCameraLocked) {
                btn.classList.add('locked'); btn.innerHTML = 'ğŸ”’ å°æ’­é–å®š';
                const currentData = learningData[String(currentPhase)];
                if(currentData) updateCameraView(currentData[currentStepIndex]);
            } else { btn.classList.remove('locked'); btn.innerHTML = 'ğŸ”“ è‡ªç”±è¦–è§’'; }
        }
        
        function toggleMenu() { document.getElementById('side-menu').classList.toggle('show'); }
        
        function applyPose(poseName) {
            const pose = POSES[poseName];
            if (!pose) return;
            document.querySelectorAll('.pose-btn').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`btn-pose-${poseName}`);
            if (activeBtn) activeBtn.classList.add('active');
            gsap.to(poseControls, {
                leftThigh: pose.leftThigh, leftKnee: pose.leftKnee, rightThigh: pose.rightThigh, rightKnee: pose.rightKnee,
                duration: 0.5, onUpdate: updatePose
            });
        }

        function updatePose() {
            if (bones.leftUpLeg) bones.leftUpLeg.rotation.x = THREE.MathUtils.degToRad(poseControls.leftThigh);
            if (bones.leftLeg) bones.leftLeg.rotation.x = THREE.MathUtils.degToRad(poseControls.leftKnee);
            if (bones.rightUpLeg) bones.rightUpLeg.rotation.x = THREE.MathUtils.degToRad(poseControls.rightThigh);
            if (bones.rightLeg) bones.rightLeg.rotation.x = THREE.MathUtils.degToRad(poseControls.rightKnee);
        }

        function toggleModel() {
            const newType = activeModelType === 'male' ? 'female' : 'male';
            loadModel(newType);
        }

        window.initApp = initApp; window.toggleCameraLock = toggleCameraLock; window.toggleMenu = toggleMenu;
        window.applyPose = applyPose; window.setPhase = setPhase; window.resetCam = resetCam;
        window.toggleModel = toggleModel; window.prevStep = prevStep; window.forceComplete = forceComplete;
    </script>
</body>
</html>
