<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‰¾æŸåœ‹éš›èŠ³ç™‚ - VRè™›æ“¬æŒ‰æ‘©æ²»ç™‚ç³»çµ± (ç©´ä½äº’å‹•ç‰ˆ)</title>
    <!-- å¼•å…¥ GSAP å‹•ç•«åº« -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Microsoft JhengHei', 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            overflow: hidden;
        }

        .game-container { width: 100vw; height: 100vh; position: relative; }
        
        /* æ­¡è¿ç•«é¢ */
        .welcome-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.95) 0%, rgba(118, 75, 162, 0.95) 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000; transition: opacity 0.5s;
        }
        .welcome-screen.hidden { opacity: 0; pointer-events: none; }
        .welcome-content { text-align: center; color: white; max-width: 800px; padding: 40px; }
        .welcome-content h1 { font-size: 48px; margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .enter-btn {
            background: white; color: #667eea; border: none; padding: 15px 40px; font-size: 20px;
            border-radius: 50px; cursor: pointer; transition: all 0.3s; font-weight: bold; margin: 10px;
        }
        .enter-btn:hover { transform: translateY(-3px); box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
        .enter-btn.vr-btn { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); color: white; }

        /* ç‹€æ…‹åˆ— */
        .status-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95); padding: 10px 30px; border-radius: 50px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2); z-index: 100; display: flex; gap: 20px;
        }
        .status-item { display: flex; align-items: center; gap: 8px; font-size: 16px; font-weight: bold; }

        /* å·¦å´é¢æ¿ */
        .control-panel {
            position: absolute; left: 20px; top: 90px; width: 300px;
            background: rgba(255, 255, 255, 0.95); border-radius: 20px; padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2); z-index: 100;
            max-height: calc(100vh - 120px); overflow-y: auto;
        }
        .panel-section { margin-bottom: 20px; }
        .panel-title { font-size: 18px; font-weight: bold; color: #667eea; margin-bottom: 10px; border-bottom: 2px solid #f0f0f0; padding-bottom: 5px; }

        /* æ¨¡ç‰¹å…’é¸æ“‡å¡ç‰‡ */
        .model-selector { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .model-card {
            background: #f5f7fa; border: 2px solid transparent; border-radius: 10px; padding: 10px;
            cursor: pointer; text-align: center; transition: all 0.2s;
        }
        .model-card.active { border-color: #764ba2; background: #e0eafc; }
        .model-icon { font-size: 32px; display: block; margin-bottom: 5px; }

        /* æ²»ç™‚æ‰‹æ³•æŒ‰éˆ• */
        .technique-list { display: flex; flex-direction: column; gap: 8px; }
        .technique-btn {
            background: #fff; border: 1px solid #ddd; border-radius: 10px; padding: 12px;
            cursor: pointer; text-align: left; transition: all 0.2s; display: flex; align-items: center; gap: 10px;
        }
        .technique-btn:hover { transform: translateX(5px); background: #f0f0f0; }
        .technique-btn.active {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: white; border: none; box-shadow: 0 5px 15px rgba(250, 112, 154, 0.4);
        }

        /* å³å´è³‡è¨Šé¢æ¿ */
        .info-panel {
            position: absolute; right: 20px; top: 90px; width: 300px;
            background: rgba(255, 255, 255, 0.95); border-radius: 20px; padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2); z-index: 100;
        }
        .progress-item { margin-bottom: 10px; }
        .progress-label { display: flex; justify-content: space-between; font-size: 13px; margin-bottom: 3px; }
        .progress-bar { width: 100%; height: 15px; background: #eee; border-radius: 10px; overflow: hidden; }
        .progress-fill { height: 100%; background: #667eea; width: 0%; transition: width 0.3s; }

        /* åº•éƒ¨å·¥å…·åˆ— */
        .toolbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95); padding: 10px 20px; border-radius: 50px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2); z-index: 100; display: flex; gap: 10px;
        }
        .tool-btn {
            background: #667eea; color: white; border: none; padding: 10px 20px; border-radius: 20px; cursor: pointer;
        }

        /* Loading */
        .loading-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.95); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 500; transition: opacity 0.3s;
        }
        .loading-overlay.hidden { opacity: 0; pointer-events: none; }
        .spinner { width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #667eea; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* ç‰¹æ•ˆæç¤ºæ–‡å­— */
        .treatment-effect {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 20px 40px; border-radius: 15px; font-size: 24px; font-weight: bold; color: white;
            opacity: 0; pointer-events: none; z-index: 200; text-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .treatment-effect.success { background: rgba(76, 175, 80, 0.9); animation: popIn 0.5s; }
        .treatment-effect.fail { background: rgba(244, 67, 54, 0.9); animation: shake 0.5s; }

        @keyframes popIn { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; } }
        @keyframes shake { 0%, 100% { transform: translate(-50%, -50%); } 25% { transform: translate(-60px, -50%); } 75% { transform: translate(-40px, -50%); } }

        /* Debug Panel */
        .debug-panel {
            position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white;
            padding: 10px; border-radius: 5px; z-index: 2000; width: 220px; font-size: 12px;
        }
        .debug-row { margin-bottom: 5px; }
        .debug-row input { width: 100%; }
        .toggle-debug { position: absolute; top: 10px; right: 10px; z-index: 2001; }
    </style>
</head>
<body>

    <!-- Debug Toggle -->
    <button class="toggle-debug" onclick="document.getElementById('debug-panel').style.display = document.getElementById('debug-panel').style.display === 'none' ? 'block' : 'none'">ğŸ”§ ä½ç½®èª¿æ ¡</button>
    
    <div class="debug-panel" id="debug-panel" style="display: none;">
        <h3>æ¨¡ç‰¹å…’ä½ç½®èª¿æ•´</h3>
        <div class="debug-row">
            X: <span id="val-x">-1.20</span>
            <input type="range" id="range-x" min="-5" max="5" step="0.05" value="-1.2">
        </div>
        <div class="debug-row">
            Y: <span id="val-y">0.00</span>
            <input type="range" id="range-y" min="-2" max="2" step="0.01" value="0.00">
        </div>
        <div class="debug-row">
            Z: <span id="val-z">0.00</span>
            <input type="range" id="range-z" min="-5" max="5" step="0.05" value="0">
        </div>
        <p style="color:#aaa;">* Yè»¸è¨­ç‚ºè² å€¼å¯ç©¿éåœ°æ¿</p>
    </div>

    <div class="game-container">
        <!-- æ­¡è¿ç•«é¢ -->
        <div class="welcome-screen" id="welcome-screen">
            <div class="welcome-content">
                <h1>ğŸ¥½ VRè™›æ“¬æŒ‰æ‘©æ²»ç™‚ç³»çµ±</h1>
                <p>è«‹ä¾ç…§æŒ‡ç¤ºæŒ‰å£“ç™¼å…‰çš„ç©´ä½é»<br>æ­£ç¢ºæŒ‰å£“æ‰èƒ½ç´¯ç©æ²»ç™‚é€²åº¦</p>
                <button class="enter-btn" onclick="enterSpace(false)">ğŸ–¥ï¸ é€²å…¥é«”é©—</button>
            </div>
        </div>

        <!-- 3D ç•«å¸ƒ -->
        <div id="canvas-container">
            <div class="loading-overlay" id="loading-overlay">
                <div class="spinner"></div>
                <div style="margin-top:10px; color:#667eea; font-weight:bold;" id="loading-text">è¼‰å…¥ä¸­...</div>
            </div>
        </div>

        <!-- UI ä»‹é¢ -->
        <div class="status-bar">
            <div class="status-item">ğŸ¥ é†«ç™‚ç©ºé–“ A01</div>
            <div class="status-item" id="hint-text" style="color: #fa709a;">ğŸ’¡ è«‹é¸æ“‡æ¨¡ç‰¹å…’é–‹å§‹</div>
        </div>

        <div class="control-panel">
            <div class="panel-section">
                <div class="panel-title">ğŸ‘¥ é¸æ“‡æ¨¡ç‰¹å…’</div>
                <div class="model-selector">
                    <div class="model-card" onclick="selectModel('male')" id="model-male">
                        <span class="model-icon">ğŸ‘¨</span>ç”·æ€§ (B01)
                    </div>
                    <div class="model-card" onclick="selectModel('female')" id="model-female">
                        <span class="model-icon">ğŸ‘©</span>å¥³æ€§ (B02)
                    </div>
                </div>
            </div>
            <div class="panel-section">
                <div class="panel-title">ğŸ–ï¸ æ²»ç™‚æ‰‹æ³•</div>
                <div class="technique-list">
                    <button class="technique-btn" onclick="selectTechnique(1)">ğŸ–ï¸ æ¨æ’«æ³• Effleurage</button>
                    <button class="technique-btn" onclick="selectTechnique(2)">ğŸ‘ æ‰ææ³• Petrissage</button>
                    <button class="technique-btn" onclick="selectTechnique(3)">ğŸ‘† æ‘©æ“¦æ³• Friction</button>
                    <button class="technique-btn" onclick="selectTechnique(4)">âœŠ å©æ“Šæ³• Tapotement</button>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <div class="panel-title">ğŸ“Š æ²»ç™‚è©•ä¼°</div>
            <div class="progress-item">
                <div class="progress-label"><span>æº–ç¢ºåº¦ (Accuracy)</span><span id="score-val">0%</span></div>
                <div class="progress-bar"><div class="progress-fill" id="score-bar" style="background: #4CAF50;"></div></div>
            </div>
            <div class="progress-item">
                <div class="progress-label"><span>æ²»ç™‚é€²åº¦ (Progress)</span><span id="progress-val">0%</span></div>
                <div class="progress-bar"><div class="progress-fill" id="progress-bar"></div></div>
            </div>
            <div style="margin-top: 20px; padding: 10px; background: #f8f9fa; border-radius: 10px;">
                <div style="font-size: 13px; color: #666;">æœ¬æ¬¡ç™‚ç¨‹</div>
                <div style="display:flex; justify-content:space-between; margin-top:5px;">
                    <strong>æŒ‰å£“æ¬¡æ•¸: <span id="hit-count">0</span></strong>
                    <strong>å¤±èª¤: <span id="miss-count" style="color:red;">0</span></strong>
                </div>
            </div>
        </div>

        <div class="toolbar">
            <button class="tool-btn" onclick="resetCamera()">ğŸ”„ é‡ç½®è¦–è§’</button>
            <button class="tool-btn" onclick="resetTreatment()">ğŸ—‘ï¸ é‡ç½®ç™‚ç¨‹</button>
        </div>

        <div class="treatment-effect" id="treatment-effect"></div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        let scene, camera, renderer, controls, patientModel;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let targetPoints = []; // å­˜æ”¾æŒ‰æ‘©ç†±é»
        let isGameActive = false;
        
        // éŠæˆ²ç‹€æ…‹
        let gameState = {
            hits: 0,
            misses: 0,
            progress: 0,
            selectedTechnique: null
        };

        const techniqueNames = { 1: 'æ¨æ’«æ³•', 2: 'æ‰ææ³•', 3: 'æ‘©æ“¦æ³•', 4: 'å©æ“Šæ³•' };

        // åˆå§‹åŒ–å ´æ™¯
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);

            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(2, 3, 3);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 0.5, 0);

            // ç‡ˆå…‰
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // è¼‰å…¥æˆ¿é–“
            loadRoom();

            // äº‹ä»¶ç›£è½
            window.addEventListener('resize', onResize);
            renderer.domElement.addEventListener('click', onClick);
            
            // Debug æ»‘æ¡¿ç›£è½
            document.getElementById('range-x').addEventListener('input', updateModelPos);
            document.getElementById('range-y').addEventListener('input', updateModelPos);
            document.getElementById('range-z').addEventListener('input', updateModelPos);

            animate();
        }

        function loadRoom() {
            const loader = new THREE.GLTFLoader();
            loader.load('A01.glb', (gltf) => {
                const room = gltf.scene;
                // è‡ªå‹•ç¸®æ”¾æˆ¿é–“
                const box = new THREE.Box3().setFromObject(room);
                const size = box.getSize(new THREE.Vector3());
                const scale = 20 / Math.max(size.x, size.y, size.z);
                room.scale.set(scale, scale, scale);
                room.position.y = -box.min.y * scale; // è²¼åœ°
                scene.add(room);
                document.getElementById('loading-overlay').classList.add('hidden');
            });
        }

        function selectModel(gender) {
            if (patientModel) {
                scene.remove(patientModel);
                // æ¸…é™¤èˆŠçš„ç†±é»
                targetPoints.forEach(p => scene.remove(p));
                targetPoints = [];
            }

            document.getElementById('loading-overlay').classList.remove('hidden');
            document.getElementById('loading-text').innerText = "è¼‰å…¥æ¨¡ç‰¹å…’...";

            // UI æ›´æ–°
            document.querySelectorAll('.model-card').forEach(c => c.classList.remove('active'));
            document.getElementById('model-' + gender).classList.add('active');

            const file = gender === 'male' ? 'B01.glb' : 'B02.glb';
            
            const loader = new THREE.GLTFLoader();
            loader.load(file, (gltf) => {
                patientModel = gltf.scene;
                
                // é è¨­ä½ç½® (è§£æ±ºæµ®ç©ºå•é¡Œ)
                // âœ¨ å°‡é è¨­é«˜åº¦è¨­ç‚º 0.0ï¼Œå¦‚æœé‚„å¤ªé«˜ï¼Œå¯ç”¨ Debug é¢æ¿æ‹‰åˆ°è² æ•¸
                patientModel.position.set(-1.2, 0.0, 0); 
                patientModel.rotation.set(-Math.PI / 2, 0, Math.PI / 2);
                
                scene.add(patientModel);
                
                // æ›´æ–° Debug é¢æ¿æ•¸å€¼
                document.getElementById('range-x').value = -1.2;
                document.getElementById('range-y').value = 0.0;
                document.getElementById('range-z').value = 0;
                updateDebugVal();

                // âœ¨ å»ºç«‹æŒ‰æ‘©ç†±é» (è‚©è†€ã€èƒŒéƒ¨ã€è…¿)
                createTargetPoints(patientModel.position);

                document.getElementById('loading-overlay').classList.add('hidden');
                document.getElementById('hint-text').innerText = "ğŸ’¡ è«‹é¸æ“‡æ‰‹æ³•ä¸¦æŒ‰å£“ç™¼å…‰éƒ¨ä½";
                isGameActive = true;
            });
        }

        // âœ¨ å»ºç«‹ç™¼å…‰çš„æŒ‰æ‘©ç©´ä½é»
        function createTargetPoints(basePos) {
            // å®šç¾©ç›¸å°æ–¼æ¨¡ç‰¹å…’ä½ç½®çš„ç†±é»åç§»é‡ (éœ€æ ¹æ“šå¯¦éš›æ¨¡å‹å¤§å°å¾®èª¿)
            // ç”±æ–¼æ¨¡å‹æ—‹è½‰äº†ï¼Œé€™è£¡çš„åº§æ¨™æ˜¯ä¸–ç•Œåº§æ¨™
            const pointsData = [
                { x: 0, y: 0.2, z: -0.6, name: 'è‚©é ¸' }, // é ­éƒ¨é™„è¿‘
                { x: 0, y: 0.25, z: 0, name: 'èƒŒéƒ¨' },   // èƒŒéƒ¨ä¸­å¤®
                { x: 0, y: 0.2, z: 0.8, name: 'è…¿éƒ¨' }   // è…¿éƒ¨
            ];

            const geometry = new THREE.SphereGeometry(0.25, 32, 32);
            
            pointsData.forEach(p => {
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, 
                    transparent: true, 
                    opacity: 0.4 
                });
                
                const sphere = new THREE.Mesh(geometry, material);
                
                // è¨ˆç®—ä¸–ç•Œåº§æ¨™ï¼šåŸºåº•ä½ç½® + åç§»
                // æ³¨æ„ï¼šé€™è£¡å‡è¨­ basePos æ˜¯(-1.2, y, 0)ï¼Œæˆ‘å€‘éœ€è¦åŠ ä¸Šç›¸å°ä½ç½®
                sphere.position.set(
                    basePos.x + p.x, 
                    basePos.y + p.y + 0.5, // ç¨å¾®æµ®èµ·ä¾†ä¸€é»æ–¹ä¾¿çœ‹åˆ°
                    basePos.z + p.z
                );
                
                sphere.userData = { isTarget: true, name: p.name };
                
                // åŠ å…¥å‘¼å¸ç‡ˆå‹•ç•«
                gsap.to(material, {
                    opacity: 0.1,
                    duration: 1,
                    repeat: -1,
                    yoyo: true
                });

                scene.add(sphere);
                targetPoints.push(sphere);
            });
        }

        // Debug: æ›´æ–°æ¨¡å‹ä½ç½®
        function updateModelPos() {
            if (!patientModel) return;
            const x = parseFloat(document.getElementById('range-x').value);
            const y = parseFloat(document.getElementById('range-y').value);
            const z = parseFloat(document.getElementById('range-z').value);
            
            patientModel.position.set(x, y, z);
            updateDebugVal();

            // æ›´æ–°ç†±é»ä½ç½® (è·Ÿéš¨æ¨¡å‹)
            if (targetPoints.length > 0) {
                // é‡æ–°å»ºç«‹ç†±é» (ç°¡å–®æš´åŠ›æ³•)
                targetPoints.forEach(p => scene.remove(p));
                targetPoints = [];
                createTargetPoints(patientModel.position);
            }
        }

        function updateDebugVal() {
            document.getElementById('val-x').innerText = document.getElementById('range-x').value;
            document.getElementById('val-y').innerText = document.getElementById('range-y').value;
            document.getElementById('val-z').innerText = document.getElementById('range-z').value;
        }

        function selectTechnique(id) {
            gameState.selectedTechnique = id;
            document.querySelectorAll('.technique-btn').forEach(b => b.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            const name = techniqueNames[id];
            showFeedback(`å·²é¸æ“‡ï¼š${name}`, 'info');
        }

        function onClick(event) {
            if (!isGameActive || !gameState.selectedTechnique) {
                if(!gameState.selectedTechnique) showFeedback("âš ï¸ è«‹å…ˆé¸æ“‡æ²»ç™‚æ‰‹æ³•", "fail");
                return;
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // 1. æª¢æ¸¬æ˜¯å¦é»ä¸­ç†±é» (Target Points)
            const hitTargets = raycaster.intersectObjects(targetPoints);
            
            if (hitTargets.length > 0) {
                const target = hitTargets[0].object;
                handleSuccess(target.position, target.userData.name);
                return;
            }

            // 2. æª¢æ¸¬æ˜¯å¦é»ä¸­èº«é«” (ä½†æ²’ä¸­ç†±é»)
            if (patientModel) {
                const hitModel = raycaster.intersectObject(patientModel, true);
                if (hitModel.length > 0) {
                    handleMiss(hitModel[0].point);
                }
            }
        }

        function handleSuccess(pos, partName) {
            gameState.hits++;
            gameState.progress += 10; // æ¯æ¬¡å¢åŠ 10%
            if(gameState.progress > 100) gameState.progress = 100;

            updateUI();
            
            // æ’­æ”¾æŒ‰æ‘©ç‰¹æ•ˆ
            playVisualEffect(pos);
            
            showFeedback(`âœ¨ Perfect! æˆåŠŸæŒ‰å£“${partName}`, "success");
        }

        function handleMiss(pos) {
            gameState.misses++;
            updateUI();
            
            // é¡¯ç¤ºä¸€å€‹å°çš„å¤±æ•—æç¤ºé»
            const missMark = new THREE.Mesh(
                new THREE.RingGeometry(0.05, 0.08, 32),
                new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide })
            );
            missMark.position.copy(pos);
            missMark.position.y += 0.05;
            missMark.rotation.x = -Math.PI/2;
            scene.add(missMark);
            
            gsap.to(missMark.scale, {x: 2, y: 2, duration: 0.5, opacity: 0, onComplete: () => scene.remove(missMark)});

            showFeedback("âŒ ä½ç½®åç§»ï¼è«‹æŒ‰å£“ç™¼å…‰éƒ¨ä½", "fail");
        }

        function playVisualEffect(pos) {
            // ç”¢ç”Ÿä¸€å€‹æ‰‹æŒæˆ–å…‰çƒ
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8 })
            );
            sphere.position.copy(pos);
            scene.add(sphere);

            // æ ¹æ“šæ‰‹æ³•æ’­æ”¾å‹•ç•«
            if (gameState.selectedTechnique == 4) { // å©æ“Š
                gsap.to(sphere.position, { y: pos.y + 0.3, duration: 0.1, yoyo: true, repeat: 5, onComplete: () => scene.remove(sphere) });
            } else { // å…¶ä»–
                gsap.to(sphere.scale, { x: 1.5, z: 1.5, duration: 0.5, yoyo: true, repeat: 1, onComplete: () => scene.remove(sphere) });
            }
        }

        function showFeedback(text, type) {
            const el = document.getElementById('treatment-effect');
            el.innerText = text;
            el.className = `treatment-effect ${type}`; // reset class
            el.style.opacity = 1;
            
            // é‡æ–°è§¸ç™¼å‹•ç•«
            void el.offsetWidth; 
            
            setTimeout(() => { el.style.opacity = 0; }, 1500);
        }

        function updateUI() {
            document.getElementById('hit-count').innerText = gameState.hits;
            document.getElementById('miss-count').innerText = gameState.misses;
            document.getElementById('progress-val').innerText = gameState.progress + '%';
            document.getElementById('progress-bar').style.width = gameState.progress + '%';

            // è¨ˆç®—æº–ç¢ºåº¦
            const total = gameState.hits + gameState.misses;
            const acc = total === 0 ? 0 : Math.round((gameState.hits / total) * 100);
            document.getElementById('score-val').innerText = acc + '%';
            document.getElementById('score-bar').style.width = acc + '%';

            if(gameState.progress >= 100) {
                showFeedback("ğŸ‰ ç™‚ç¨‹å®Œæˆï¼è«‹æ›´æ›éƒ¨ä½æˆ–çµæŸ", "success");
            }
        }

        function enterSpace() {
            document.getElementById('welcome-screen').classList.add('hidden');
            init();
        }

        function resetCamera() {
            controls.reset();
        }

        function resetTreatment() {
            gameState = { hits: 0, misses: 0, progress: 0, selectedTechnique: null };
            updateUI();
            showFeedback("ç™‚ç¨‹å·²é‡ç½®", "info");
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
