<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>è‰¾æŸåœ‹éš›èŠ³ç™‚ - VR æŒ‰æ‘©æ•™å­¸ (å°é¢é«˜æ›ç‰ˆ v20)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/"
            }
        }
    </script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: #1a1a1a;
            overflow: hidden;
            touch-action: none;
        }
        
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        .top-bar {
            position: absolute; top: 0; left: 0; width: 100%;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            padding: 15px 25px; color: white; display: flex; justify-content: space-between;
            align-items: center; pointer-events: auto;
        }

        .side-menu {
            position: absolute; left: 20px; top: 80px; width: 300px;
            background: rgba(30, 30, 30, 0.95); backdrop-filter: blur(10px);
            border-radius: 15px; padding: 15px; border: 1px solid rgba(255,255,255,0.1);
            pointer-events: auto; max-height: calc(100vh - 120px); overflow-y: auto;
            transform: translateX(-360px); transition: transform 0.3s ease; z-index: 20;
        }
        .side-menu.show { transform: translateX(0); }
        
        .menu-title { color: #8ec5fc; font-size: 14px; margin-bottom: 10px; font-weight: bold; cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; }
        .phase-btn { display: block; width: 100%; padding: 12px; margin-bottom: 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #ccc; text-align: left; cursor: pointer; transition: all 0.2s; font-size: 14px; }
        .phase-btn.active { background: linear-gradient(90deg, #667eea, #764ba2); color: white; border: none; }
        .pose-section { display: block; background: rgba(102, 126, 234, 0.2); padding: 12px; border-radius: 8px; margin-bottom: 15px; }
        .pose-btn { padding: 8px 12px; margin: 4px 2px; background: rgba(102, 126, 234, 0.3); border: 1px solid rgba(102, 126, 234, 0.5); border-radius: 6px; color: #8ec5fc; font-size: 11px; cursor: pointer; }
        .pose-btn.active { background: #667eea; color: white; }

        body.vr-active .action-card { display: none !important; }
        body.vr-active .gesture-hint { display: none !important; }

        .action-card {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(30, 30, 30, 0.95); backdrop-filter: blur(10px);
            padding: 20px 30px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1);
            text-align: center; width: 90%; max-width: 500px; pointer-events: auto;
        }
        .instruction-title { color: #8ec5fc; font-size: 12px; font-weight: bold; margin-bottom: 5px; text-transform: uppercase; }
        .instruction-text { color: #fff; font-size: 20px; font-weight: bold; margin-bottom: 8px; }
        .instruction-note { color: #aaa; font-size: 14px; margin-bottom: 15px; line-height: 1.5; }
        .nav-btn { background: #444; color: white; border: none; padding: 8px 16px; border-radius: 20px; cursor: pointer; margin: 0 5px; font-weight: bold; transition: all 0.3s; }
        .nav-btn.primary { background: #667eea; }
        
        .lock-btn { border: 1px solid #666; }
        .lock-btn.locked { background: #667eea; border: 1px solid #667eea; box-shadow: 0 0 10px rgba(102, 126, 234, 0.5); }

        .gesture-hint {
            position: absolute; background: rgba(102, 126, 234, 0.9); color: white;
            padding: 8px 16px; border-radius: 20px; font-weight: bold;
            font-size: 14px; pointer-events: none; opacity: 0; transition: opacity 0.3s;
            transform: translate(-50%, -100%); white-space: nowrap; z-index: 100;
        }

        .welcome-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(20, 20, 20, 0.95); z-index: 1000; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; text-align: center; padding: 20px; }
        .start-btn { background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; padding: 15px 50px; font-size: 20px; border-radius: 50px; margin-top: 30px; cursor: pointer; }
        
        .vr-status {
            position: absolute; bottom: 20px; left: 20px; 
            background: rgba(0,0,0,0.8); padding: 10px 15px;
            border-radius: 10px; color: #fff;
            font-size: 12px; display: none;
            border: 1px solid #00ff00;
            font-family: 'Courier New', monospace;
            z-index: 100;
        }
        .vr-status.active { display: block; }
        .vr-status-line { margin: 3px 0; padding: 3px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .vr-status-line:last-child { border-bottom: none; }
    </style>
</head>
<body>

    <div class="welcome-overlay" id="welcome">
        <div style="font-size: 40px; font-weight: bold; color: #8ec5fc; margin-bottom: 10px;">è‰¾æŸåœ‹éš›èŠ³ç™‚</div>
        <h1 style="font-size: 28px; margin-bottom: 10px;">ğŸ¤² VR ç‘å…¸æŒ‰æ‘©æ•™å­¸</h1>
        <p style="color: #00ff00; font-size: 20px; font-weight: bold;">Quest 3 å°é¢é«˜æ›ç‰ˆ v20.0</p>
        <p style="color: #8ec5fc; font-size: 14px; margin-top:10px;">âœ¨ é»‘æ¿ç§»è‡³å°é¢é«˜è™• + è¦–è·æ‹‰é  + è¶´å§¿å„ªåŒ–</p>
        
        <div style="margin-top: 30px; background: rgba(0,255,0,0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(0,255,0,0.3); max-width: 600px;">
            <p style="color: #00ff00; font-weight: bold; font-size: 16px; margin-bottom: 15px;">ğŸ”§ æ“ä½œèªªæ˜</p>
            <div style="text-align: left; color: #ccc; line-height: 2;">
                <p>1ï¸âƒ£ <b>çœ‹å°é¢ï¼š</b>æ•™å­¸æ¿æ‡¸æ›åœ¨åºŠçš„å°é¢ç‰†ä¸Š (é«˜è™•)</p>
                <p>2ï¸âƒ£ <b>è‡ªå‹•ï¼š</b>ç³»çµ±æœƒè‡ªå‹•ç§»å‹•ä½ç½®ï¼Œä¿æŒèˆ’é©æ“ä½œè·é›¢</p>
                <p>3ï¸âƒ£ <b>é»æ“Šï¼š</b>ç›´æ¥é»æ“Šå°é¢ç¶ è‰²çš„ 3D æ–¹å¡Šé€²å…¥ VR</p>
            </div>
        </div>
        
        <button class="start-btn" onclick="initApp()">é€²å…¥æ•™å®¤</button>
        <div id="spinner" style="display:none; margin-top:20px; color:white;">è¼‰å…¥ä¸­...</div>
    </div>

    <div id="canvas-container" style="width:100vw; height:100vh;"></div>
    
    <div class="ui-layer" id="ui" style="display:none;">
        <div class="top-bar">
            <div style="font-weight: bold; font-size: 18px; display:flex; align-items:center; gap:10px;">
                <span style="font-size:24px;" id="current-tool-icon">ğŸ¤š</span>
                <span id="phase-title">éšæ®µä¸€ï¼šæº–å‚™èˆ‡èµ·å§‹</span>
            </div>
            <div style="display:flex; gap:10px;">
                <button class="nav-btn lock-btn locked" id="lock-btn" onclick="toggleCameraLock()">ğŸ”’ å°æ’­é–å®š</button>
                <button class="nav-btn" onclick="toggleMenu()">â˜°</button>
            </div>
        </div>

        <div class="vr-status" id="vr-status">
            <div>ğŸ” VR ç‹€æ…‹</div>
            <div style="margin-top:5px;" class="vr-status-line">ğŸ‘‹ æ‰‹éƒ¨: <span id="hand-track-status" style="color: #ffff00;">...</span></div>
            <div class="vr-status-line">ğŸš€ ç§»å‹•: <span id="move-status">è‡ªå‹•è·Ÿéš¨</span></div>
        </div>

        <div class="side-menu" id="side-menu">
            <div class="pose-section">
                <div class="menu-title">ğŸ¦´ è…¿éƒ¨å§¿å‹¢</div>
                <div style="margin-bottom:8px;">
                    <button class="pose-btn active" id="btn-pose-flat" onclick="applyPose('flat')">å¹³èºº</button>
                    <button class="pose-btn" id="btn-pose-leftRaised" onclick="applyPose('leftRaised')">å·¦è…¿å½æ›²</button>
                    <button class="pose-btn" id="btn-pose-rightRaised" onclick="applyPose('rightRaised')">å³è…¿å½æ›²</button>
                </div>
            </div>
            <div class="menu-title">ç™‚ç¨‹éšæ®µ</div>
            <button class="phase-btn active" onclick="setPhase(1)" id="p1">1. å‹»æ²¹èˆ‡è¼•æ’«</button>
            <button class="phase-btn" onclick="setPhase(2)" id="p2">2. å·¦è…¿æ‰æ</button>
            <button class="phase-btn" onclick="setPhase(3)" id="p3">3. å³è…¿æ¨å£“</button>
            <button class="phase-btn" onclick="setPhase(4)" id="p4">4. çµå°¾å®‰æ’«</button>
            <div class="menu-title" style="margin-top:20px;">è¨­å®š</div>
            <button class="phase-btn" onclick="resetCam()">ğŸ”„ é‡ç½®è¦–è§’</button>
            <button class="phase-btn" onclick="toggleModel()">ğŸ‘¤ åˆ‡æ›æ¨¡ç‰¹å…’</button>
        </div>

        <div class="action-card">
            <div class="instruction-title">STEP <span id="step-num">1.1</span></div>
            <div class="instruction-text" id="action-text">è¼‰å…¥ä¸­...</div>
            <div class="instruction-note" id="action-note">è·Ÿéš¨æ‰‹éƒ¨æŒ‡å¼•æ“ä½œ</div>
            <div style="display:flex; justify-content: center; gap:10px;">
                <button class="nav-btn" onclick="prevStep()">ä¸Šä¸€æ­¥</button>
                <button class="nav-btn primary" onclick="forceComplete()">è·³é</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

        const BASE_URL = "https://gp01002.github.io/TMS/";

        const MODEL_CONFIG = {
            male: { pos: { x: 0.1, y: 2.32, z: 0 }, scale: 1.0, rot: { x: 1.57, y: 0, z: 1.57 } },
            female: { pos: { x: 0.1, y: 2.28, z: 0 }, scale: 1.0, rot: { x: 1.57, y: 0, z: 1.57 } }
        };
        
        const LEFT_LEG_Z = 0.12;  
        const RIGHT_LEG_Z = -0.12;
        const COORDS = {
            THIGH_ROOT: -3.3, THIGH_MID: -2.4, KNEE: -1.5, CALF_MID: -0.7, ANKLE: 0.1, FOOT: 0.3            
        };

        // ğŸ”¥ æ™ºæ…§é‹é¡ï¼šVR è·é›¢ç¨å¾®æ‹‰é  (Z=1.3)
        const VIEW_PRESETS = {
            overview: { 
                pcPos: {x: 2.0, y: 2.0, z: 2.0}, pcTarget: {x: 0, y: 0.5, z: 0}, 
                vrPos: {x: 0.8, z: 0.8} // ç¸½è¦½
            },
            thigh: { 
                pcPos: {x: -2.0, y: 1.5, z: 1.0}, pcTarget: {x: -2.5, y: 0.5, z: 0},
                vrPos: {x: -1.5, z: 1.3} // å¤§è…¿ (è·é›¢1.3)
            },
            knee: {
                pcPos: {x: -1.0, y: 1.2, z: 1.0}, pcTarget: {x: -1.5, y: 1.0, z: 0},
                vrPos: {x: -1.0, z: 1.3} // è†è“‹ (è·é›¢1.3)
            },
            calf: {
                pcPos: {x: 0.5, y: 1.2, z: 1.0}, pcTarget: {x: -0.5, y: 0.5, z: 0},
                vrPos: {x: 0.5, z: 1.3} // å°è…¿ (è·é›¢1.3)
            }
        };

        const learningData = {
            "1": [ 
                { id: "1.1", text: "å–æ²¹", note: "é»æ“Šç²¾æ²¹ç“¶", type: "click", tool: "oil", icon: "ğŸ§´", pos: {x: -1.0, y: 0.2, z: 0.5}, view: "overview", pose: "flat" }, 
                { id: "1.2", text: "æº«ç†±é›™æ‰‹", note: "é›™æ‰‹åˆåæ“ç†±", type: "press", tool: "hands", icon: "ğŸ”¥", pos: {x: COORDS.KNEE, y: 0.3, z: 0}, duration: 3, view: "knee", pose: "flat" },
                { id: "1.3", text: "å¤§è…¿è¼•æ’«", note: "é›™æ‰‹å¾è†è“‹æ»‘å‘å¤§è…¿æ ¹éƒ¨", type: "drag", tool: "hand", icon: "ğŸŒŠ", start: {x: COORDS.KNEE, y: -0.25, z: LEFT_LEG_Z}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: LEFT_LEG_Z}, view: "thigh", pose: "flat" }
            ],
            "2": [ 
                { id: "2.1", text: "å·¦å°è…¿æ‰æ", note: "æŠ“æ¡å°è…¿è‚š", type: "click", tool: "hand", icon: "âœŠ", pos: {x: COORDS.CALF_MID, y: -0.25, z: LEFT_LEG_Z}, view: "calf", pose: "leftRaised" },
                { id: "2.2", text: "å·¦å°è…¿æ‰­è½‰", note: "åå‘æ‰­è½‰è‚Œè‚‰", type: "press", tool: "hand", icon: "ğŸ”„", pos: {x: COORDS.CALF_MID, y: -0.25, z: LEFT_LEG_Z}, duration: 2, view: "calf", pose: "leftRaised" },
            ],
            "3": [ 
                { id: "3.1", text: "å³å°è…¿æ¨å£“", note: "æ‹‡æŒ‡æ¨å£“å°è…¿", type: "drag", tool: "thumb", icon: "ğŸ‘", start: {x: COORDS.CALF_MID, y: -0.25, z: RIGHT_LEG_Z}, end: {x: COORDS.KNEE, y: -0.20, z: RIGHT_LEG_Z}, view: "calf", pose: "rightRaised" },
            ],
            "4": [ 
                { id: "4.1", text: "å…¨è…¿é•·æ¨å®‰æ’«", note: "å¾è…³è¸æ¨è‡³å¤§è…¿", type: "drag", tool: "hand", icon: "âœ¨", start: {x: COORDS.ANKLE, y: -0.30, z: LEFT_LEG_Z}, end: {x: COORDS.THIGH_ROOT, y: -0.2, z: LEFT_LEG_Z}, view: "overview", pose: "flat" },
            ]
        };

        let scene, camera, renderer, controls, model;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let interactables = []; 
        let currentPhase = 1, currentStepIndex = 0;
        let isDragging = false;
        let isCameraLocked = true; 
        let ghostHand, tweenAnim, activeModelType = 'male';
        
        let modelPos = { ...MODEL_CONFIG.male.pos };
        let modelRot = { ...MODEL_CONFIG.male.rot };
        let modelScale = MODEL_CONFIG.male.scale;

        let bones = { leftUpLeg: null, leftLeg: null, rightUpLeg: null, rightLeg: null };
        let poseControls = { leftThigh: 0, leftKnee: 0, leftAnkle: 45, rightThigh: 0, rightKnee: 0, rightAnkle: 45 };
        const POSES = {
            flat: { leftThigh: 0, leftKnee: 0, leftAnkle: 45, rightThigh: 0, rightKnee: 0, rightAnkle: 45 },
            leftRaised: { leftThigh: 0, leftKnee: -90, leftAnkle: 45, rightThigh: 0, rightKnee: 0, rightAnkle: 45 }, 
            rightRaised: { leftThigh: 0, leftKnee: 0, leftAnkle: 45, rightThigh: 0, rightKnee: -90, rightAnkle: 45 } 
        };

        let vrControllers = [];
        let vrHands = [];
        let vrHandData = [];
        let handModelFactory, controllerModelFactory;
        let dolly, cameraOffset;
        let vrHitStatus = { isTouchingStart: false, touchStartTime: 0, activeHand: null };
        let isStepCompleting = false;
        
        let instructionBoardMesh, instructionCtx;
        let vr3DButtonMesh; 
        let globalEnterVRFunc = null; 
        
        let teleportLine, teleportReticle, teleportReticleInner;
        let isTeleporting = false;
        let teleportTarget = new THREE.Vector3();
        let pinchStartTime = 0; 
        const TELEPORT_DELAY = 2500; 

        const VR_CONFIG = {
            DETECTION_RADIUS: 0.30,        
            PRESS_DURATION: 0.5,
            HAND_INDICATOR_SIZE: 0.10,     
            HAPTIC_INTENSITY: 1.0,
            HAPTIC_DURATION: 200,
            PINCH_THRESHOLD: 0.03
        };

        function safeSetText(id, text) { const el = document.getElementById(id); if (el) el.innerText = text; }

        function initApp() {
            document.getElementById('spinner').style.display = 'block';
            document.querySelector('.start-btn').style.display = 'none';
            setTimeout(initThreeJS, 100);
        }

        function updateCameraView(stepData) {
            if (!isCameraLocked) return;
            const viewKey = stepData.view || "overview";
            const viewConfig = VIEW_PRESETS[viewKey] || VIEW_PRESETS.overview;

            if (renderer.xr.isPresenting) {
                gsap.to(dolly.position, {
                    x: viewConfig.vrPos.x,
                    z: viewConfig.vrPos.z,
                    duration: 2.0,
                    ease: "power2.inOut"
                });
            } else {
                gsap.to(camera.position, {
                    x: viewConfig.pcPos.x, y: viewConfig.pcPos.y, z: viewConfig.pcPos.z,
                    duration: 1.5, ease: "power2.inOut"
                });
                gsap.to(controls.target, {
                    x: viewConfig.pcTarget.x, y: viewConfig.pcTarget.y, z: viewConfig.pcTarget.z,
                    duration: 1.5, ease: "power2.inOut", onUpdate: () => controls.update()
                });
            }
        }

        // ğŸ”¥ ä¿®æ”¹ï¼š3D é»‘æ¿ä½ç½® - ç§»åˆ°å°é¢ (Z=-2.0)ï¼Œé«˜åº¦æå‡ (Y=3.2)
        function createInstructionBoard() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            instructionCtx = canvas.getContext('2d');
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0.9, side: THREE.DoubleSide });
            
            const geometry = new THREE.PlaneGeometry(1.8, 0.9);
            instructionBoardMesh = new THREE.Mesh(geometry, material);
            
            // ä½ç½®ï¼šX=-1.0 (å¤§è‡´ä¸­é–“), Y=3.2 (é«˜è™•), Z=-2.0 (å°é¢ç‰†)
            instructionBoardMesh.position.set(-1.0, 3.2, -2.0); 
            
            // æ—‹è½‰ï¼šé¢å‘ Z æ­£å‘ (é¢å‘ä½¿ç”¨è€…)
            instructionBoardMesh.rotation.set(0, 0, 0); 
            
            scene.add(instructionBoardMesh);
            
            // 3D é€²å…¥ VR æŒ‰éˆ• (æ”¾åœ¨æ¿å­å³å´)
            const btnGeo = new THREE.BoxGeometry(0.5, 0.5, 0.1);
            const btnMat = new THREE.MeshBasicMaterial({ color: 0x00aa00 });
            vr3DButtonMesh = new THREE.Mesh(btnGeo, btnMat);
            
            // æ”¾åœ¨æ¿å­å³å´ (X+1.2)
            vr3DButtonMesh.position.set(1.2, 0, 0.1); 
            
            const btnCanvas = document.createElement('canvas');
            btnCanvas.width = 256; btnCanvas.height = 256;
            const btnCtx = btnCanvas.getContext('2d');
            btnCtx.fillStyle = '#00aa00';
            btnCtx.fillRect(0,0,256,256);
            btnCtx.fillStyle = 'white';
            btnCtx.font = 'bold 40px Arial';
            btnCtx.textAlign = 'center';
            btnCtx.textBaseline = 'middle';
            btnCtx.fillText("é»æ“Šé€²å…¥", 128, 100);
            btnCtx.fillText("VR", 128, 160);
            
            vr3DButtonMesh.material = new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(btnCanvas) });
            
            instructionBoardMesh.add(vr3DButtonMesh); 
            interactables.push(vr3DButtonMesh); 

            updateInstructionBoard("æ­¡è¿ä½¿ç”¨ VR æ•™å­¸", "è«‹æåˆæ‰‹æŒ‡å‚³é€è‡³åºŠé‚Š");
        }

        function updateInstructionBoard(title, text) {
            if (!instructionCtx) return;
            const ctx = instructionCtx;
            ctx.fillStyle = '#222222'; ctx.fillRect(0, 0, 1024, 512);
            ctx.strokeStyle = '#667eea'; ctx.lineWidth = 20; ctx.strokeRect(10, 10, 1004, 492);
            ctx.textAlign = 'center';
            ctx.fillStyle = '#8ec5fc'; ctx.font = 'bold 60px "Microsoft JhengHei"'; ctx.fillText(title, 512, 130);
            ctx.fillStyle = '#ffffff'; ctx.font = 'bold 80px "Microsoft JhengHei"'; ctx.fillText(text, 512, 280);
            ctx.fillStyle = '#aaaaaa'; ctx.font = '40px "Microsoft JhengHei"'; ctx.fillText("æ“ä½œæç¤ºï¼šè«‹çœ‹å°é¢é«˜ç‰†é»‘æ¿", 512, 420);
            instructionBoardMesh.material.map.needsUpdate = true;
        }

        function createTeleportVisuals() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(30 * 3); 
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            teleportLine = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 }));
            teleportLine.visible = false; scene.add(teleportLine);

            const ringGeo = new THREE.RingGeometry(0.20, 0.25, 32); ringGeo.rotateX(-Math.PI / 2); 
            teleportReticle = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide }));
            teleportReticle.visible = false; scene.add(teleportReticle);
            
            const innerGeo = new THREE.CircleGeometry(0.18, 32); innerGeo.rotateX(-Math.PI / 2);
            teleportReticleInner = new THREE.Mesh(innerGeo, new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5 }));
            teleportReticleInner.visible = false; teleportReticleInner.scale.set(0, 0, 0); teleportReticle.add(teleportReticleInner);
        }

        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 5, 15);
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const spotLight = new THREE.SpotLight(0xffeeb1, 1.5);
            spotLight.position.set(2, 6, 2);
            scene.add(spotLight);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);
            camera.position.set(1.5, 2.5, 2.5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true; 
            container.appendChild(renderer.domElement);

            const vrButton = createVRButton(renderer);
            document.body.appendChild(vrButton);

            // ğŸ”¥ åˆå§‹ä½ç½®ï¼šè·é›¢ç¨å¾®æ‹‰é–‹ä¸€é»é» (Z=1.0)
            dolly = new THREE.Group();
            dolly.position.set(0.7, 0, 1.0); 
            scene.add(dolly);
            
            cameraOffset = new THREE.Group();
            cameraOffset.position.y = 1.65; 
            dolly.add(cameraOffset);
            cameraOffset.add(camera);
            
            createInstructionBoard();
            createTeleportVisuals();
            setupVRHands();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0); 
            controls.enabled = false; 
            controls.update();

            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onPointerDown);
            canvas.addEventListener('mousemove', onPointerMove);
            canvas.addEventListener('mouseup', onPointerUp);
            canvas.addEventListener('touchstart', onTouchStart, {passive: false});
            canvas.addEventListener('touchmove', onTouchMove, {passive: false});
            canvas.addEventListener('touchend', onPointerUp);
            window.addEventListener('resize', onWindowResize);

            renderer.setAnimationLoop(() => {
                if (renderer.xr.isPresenting) {
                    handleVRInteraction();
                    handleTeleportation(); 
                    updateVRStatus(); 
                } else {
                    controls.update();
                }
                interactables.forEach(obj => { if(obj.tick) obj.tick(); });
                if (ghostHand && ghostHand.visible && !renderer.xr.isPresenting) {
                    ghostHand.lookAt(camera.position);
                }
                renderer.render(scene, camera);
            });

            loadEnvironment();
        }

        function createVRButton(renderer) {
            const button = document.createElement('button');
            button.style.position = 'absolute'; button.style.top = '10%'; button.style.left = '50%'; button.style.transform = 'translateX(-50%)';
            button.style.padding = '15px 40px'; button.style.border = '2px solid rgba(0, 255, 0, 0.5)'; button.style.borderRadius = '50px';
            button.style.background = 'rgba(0, 30, 0, 0.7)'; button.style.backdropFilter = 'blur(5px)';
            button.style.color = '#00ff00'; button.style.font = 'bold 20px "Microsoft JhengHei", monospace';
            button.style.cursor = 'pointer'; button.style.zIndex = '999'; button.style.display = 'none'; button.style.transition = 'all 0.3s ease';
            button.onmouseover = () => { button.style.transform = 'translateX(-50%) scale(1.05)'; };
            button.onmouseout = () => { button.style.transform = 'translateX(-50%) scale(1)'; };
            
            function showEnterVR() {
                let currentSession = null;
                button.textContent = 'ğŸ¥½ é€²å…¥ VR'; button.style.display = '';
                const enterVR = async () => {
                    if (!currentSession) {
                        const sessionInit = { optionalFeatures: ['local-floor', 'hand-tracking'] };
                        try {
                            const session = await navigator.xr.requestSession('immersive-vr', sessionInit);
                            currentSession = session;
                            session.addEventListener('end', () => { 
                                currentSession = null; button.textContent = 'ğŸ¥½ é€²å…¥ VR'; vr3DButtonMesh.visible = true; document.body.classList.remove('vr-active'); 
                            });
                            await renderer.xr.setSession(session);
                            button.textContent = 'ğŸšª é€€å‡º VR'; vr3DButtonMesh.visible = false; document.body.classList.add('vr-active');
                        } catch(e) { alert("VR Error: " + e.message); }
                    } else { currentSession.end(); }
                };
                button.onclick = enterVR; globalEnterVRFunc = enterVR; 
            }
            if ('xr' in navigator) navigator.xr.isSessionSupported('immersive-vr').then(s => s ? showEnterVR() : null);
            return button;
        }

        function setupVRHands() {
            handModelFactory = new XRHandModelFactory();
            controllerModelFactory = new XRControllerModelFactory();
            
            for (let i = 0; i < 2; i++) {
                const controller = renderer.xr.getController(i); cameraOffset.add(controller); vrControllers.push(controller);
                const hand = renderer.xr.getHand(i); cameraOffset.add(hand); 
                try { const handModel = handModelFactory.createHandModel(hand, "mesh"); hand.add(handModel); } catch (e) {}
                
                const handData = { hand: hand, handIndex: i, handedness: null, isTracking: false, indexTip: null, thumbTip: null, wrist: null, indicator: null, isPinching: false };
                const indicator = new THREE.Mesh(new THREE.SphereGeometry(VR_CONFIG.HAND_INDICATOR_SIZE, 32, 32), new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3 }));
                indicator.visible = false; scene.add(indicator); handData.indicator = indicator;
                
                hand.addEventListener('connected', (e) => { handData.handedness = e.data.handedness; handData.isTracking = true; safeSetText('hand-track-status', `${e.data.handedness} OK`); });
                hand.addEventListener('disconnected', () => { handData.isTracking = false; handData.indicator.visible = false; });
                vrHands.push(hand); vrHandData.push(handData);
            }
        }

        function updateVRStatus() {
            vrHandData.forEach(handData => {
                if (!handData.isTracking) return;
                const hand = handData.hand;
                if (hand.joints && hand.joints['index-finger-tip']) {
                    handData.indexTip = hand.joints['index-finger-tip'];
                    handData.thumbTip = hand.joints['thumb-tip'];
                    handData.wrist = hand.joints['wrist'];
                    
                    const worldPos = new THREE.Vector3();
                    handData.indexTip.getWorldPosition(worldPos);
                    if (handData.indicator) {
                        handData.indicator.position.copy(worldPos);
                        handData.indicator.visible = true;
                    }
                }
            });
        }

        function handleTeleportation() {
            if (isStepCompleting) return; 
            let anyHandPinching = false;
            vrHandData.forEach(handData => {
                if (!handData.isTracking || !handData.indexTip || !handData.thumbTip || !handData.wrist) return;
                const indexPos = new THREE.Vector3(); const thumbPos = new THREE.Vector3(); const wristPos = new THREE.Vector3();
                handData.indexTip.getWorldPosition(indexPos); handData.thumbTip.getWorldPosition(thumbPos); handData.wrist.getWorldPosition(wristPos);
                
                const pinchDist = indexPos.distanceTo(thumbPos);
                const isPinching = pinchDist < VR_CONFIG.PINCH_THRESHOLD;
                const isInteracting = handData.indicator.material.color.getHex() !== 0x00ff00; 
                if (isInteracting) return; 

                if (isPinching) {
                    anyHandPinching = true;
                    if (!handData.isPinching) { handData.isPinching = true; pinchStartTime = Date.now(); safeSetText('move-status', 'â³ é›†æ°£...'); teleportReticleInner.scale.set(0, 0, 0); }
                    const elapsed = Date.now() - pinchStartTime;
                    const progress = Math.min(elapsed / TELEPORT_DELAY, 1.0);
                    
                    const direction = new THREE.Vector3().subVectors(indexPos, wristPos).normalize();
                    const startPoint = indexPos.clone();
                    let targetPoint = new THREE.Vector3();
                    if (direction.y < -0.1) { 
                        const t = -startPoint.y / direction.y;
                        if (t > 0 && t < 10) targetPoint.copy(startPoint).add(direction.multiplyScalar(t)); else targetPoint.copy(startPoint).add(direction.multiplyScalar(3));
                    } else { targetPoint.copy(startPoint).add(direction.multiplyScalar(3)); }
                    targetPoint.y = 0; 

                    let color = 0xff0000; 
                    if (elapsed > TELEPORT_DELAY) { color = 0x00ff00; safeSetText('move-status', 'âœ… æ”¾é–‹å‚³é€'); } else { color = 0xffff00; safeSetText('move-status', `â³ ${(2.5 - elapsed/1000).toFixed(1)}s`); }

                    updateTeleportCurve(startPoint, targetPoint, color);
                    teleportReticle.position.copy(targetPoint); teleportReticle.material.color.setHex(color); teleportReticle.visible = true; teleportLine.visible = true;
                    teleportReticleInner.visible = true; teleportReticleInner.scale.set(progress, progress, 1); teleportReticleInner.material.color.setHex(color);
                    
                    if (elapsed > TELEPORT_DELAY) { teleportTarget.copy(targetPoint); isTeleporting = true; } else { isTeleporting = false; }
                } else {
                    if (handData.isPinching) {
                        handData.isPinching = false;
                        if (isTeleporting) {
                            dolly.position.x = teleportTarget.x; dolly.position.z = teleportTarget.z;
                            safeSetText('move-status', 'ğŸš€ å·²å‚³é€'); triggerHaptic(handData, 1.0, 200);
                        } else { safeSetText('move-status', 'âŒ å–æ¶ˆ'); }
                        teleportLine.visible = false; teleportReticle.visible = false; isTeleporting = false;
                    }
                }
            });
            if (!anyHandPinching) { teleportLine.visible = false; teleportReticle.visible = false; }
        }

        function updateTeleportCurve(start, end, color) {
            const positions = teleportLine.geometry.attributes.position.array;
            teleportLine.material.color.setHex(color);
            const p0 = start; const p2 = end; const p1 = new THREE.Vector3().lerpVectors(p0, p2, 0.5); p1.y += 1.5; 
            for (let i = 0; i < 30; i++) {
                const t = i / 29;
                const tx = (1-t)*(1-t)*p0.x + 2*(1-t)*t*p1.x + t*t*p2.x;
                const ty = (1-t)*(1-t)*p0.y + 2*(1-t)*t*p1.y + t*t*p2.y;
                const tz = (1-t)*(1-t)*p0.z + 2*(1-t)*t*p1.z + t*t*p2.z;
                positions[i * 3] = tx; positions[i * 3 + 1] = ty; positions[i * 3 + 2] = tz;
            }
            teleportLine.geometry.attributes.position.needsUpdate = true;
        }

        function handleVRInteraction() {
            if (!interactables.length || isStepCompleting) return;
            const currentData = learningData[String(currentPhase)];
            if (!currentData) return;
            const step = currentData[currentStepIndex];
            
            const startObj = interactables.find(obj => obj.userData.isStart || (!obj.userData.isEnd && !obj.userData.isStart));
            const endObj = interactables.find(obj => obj.userData.isEnd);
            if (!startObj) return;

            vrHandData.forEach(handData => {
                if (!handData.isTracking || !handData.indicator || !handData.indicator.visible) return;
                const indexTipWorldPos = handData.indicator.position;
                const distToStart = indexTipWorldPos.distanceTo(startObj.position);
                
                if (step.type === 'click') handleClickInteraction(distToStart, handData, startObj);
                else if (step.type === 'press') handlePressInteraction(distToStart, handData, startObj, step.duration || VR_CONFIG.PRESS_DURATION);
                else if (step.type === 'drag') handleDragInteraction(distToStart, indexTipWorldPos, handData, startObj, endObj);
            });
        }

        function handleClickInteraction(distance, handData, targetObj) {
            if (distance < VR_CONFIG.DETECTION_RADIUS) {
                handData.indicator.material.color.set(0xff0000);
                if (!vrHitStatus.touchStartTime) {
                    vrHitStatus.touchStartTime = Date.now(); vrHitStatus.activeHand = handData.handedness;
                    triggerHaptic(handData); playClickFeedback(targetObj);
                } else {
                    if ((Date.now() - vrHitStatus.touchStartTime) / 1000 >= 0.3) { completeStepVR(); vrHitStatus.touchStartTime = 0; }
                }
            } else { handData.indicator.material.color.set(0x00ff00); if(vrHitStatus.activeHand === handData.handedness) vrHitStatus.touchStartTime = 0; }
        }

        function handlePressInteraction(distance, handData, targetObj, requiredDuration) {
            if (distance < VR_CONFIG.DETECTION_RADIUS) {
                handData.indicator.material.color.set(0xffff00);
                if (!vrHitStatus.touchStartTime) { vrHitStatus.touchStartTime = Date.now(); vrHitStatus.activeHand = handData.handedness; triggerHaptic(handData, 0.5, 50); }
                else {
                    const elapsed = (Date.now() - vrHitStatus.touchStartTime) / 1000;
                    targetObj.scale.setScalar(1 + Math.min(elapsed / requiredDuration, 1) * 0.3);
                    if (elapsed >= requiredDuration) { completeStepVR(); vrHitStatus.touchStartTime = 0; }
                }
            } else { handData.indicator.material.color.set(0x00ff00); targetObj.scale.set(1,1,1); if(vrHitStatus.activeHand === handData.handedness) vrHitStatus.touchStartTime = 0; }
        }

        function handleDragInteraction(distToStart, indexPos, handData, startObj, endObj) {
            if (!vrHitStatus.isTouchingStart) {
                if (distToStart < VR_CONFIG.DETECTION_RADIUS) {
                    vrHitStatus.isTouchingStart = true; vrHitStatus.activeHand = handData.handedness;
                    handData.indicator.material.color.set(0xffff00); triggerHaptic(handData);
                    startObj.children[1].material.color.set(0xffff00); if (endObj) endObj.visible = true;
                }
            } else if (vrHitStatus.activeHand === handData.handedness) {
                handData.indicator.material.color.set(0xffa500);
                if (endObj) {
                    const distToEnd = indexPos.distanceTo(endObj.position);
                    const progress = 1 - Math.min(distToEnd / startObj.position.distanceTo(endObj.position), 1);
                    startObj.children[1].material.opacity = 0.3 + progress * 0.7;
                    if (distToEnd < VR_CONFIG.DETECTION_RADIUS) { completeStepVR(); vrHitStatus.isTouchingStart = false; }
                }
            }
        }

        function triggerHaptic(handData, intensity = 1.0, duration = 200) {
            vrControllers.forEach(c => { if(c.gamepad?.hapticActuators?.length) c.gamepad.hapticActuators[0].pulse(intensity, duration); });
        }
        function playClickFeedback(obj) { gsap.to(obj.scale, { x: 1.5, y: 1.5, z: 1.5, duration: 0.2, yoyo: true, repeat: 1 }); }
        function completeStepVR() {
            if (isStepCompleting) return; isStepCompleting = true;
            interactables.forEach(obj => gsap.to(obj.scale, { x: 0, y: 0, z: 0, duration: 0.4 }));
            setTimeout(() => { nextStep(); isStepCompleting = false; }, 1000);
        }

        function checkIntersection() {
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -model.position.y);
            const point = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, point);
            
            const intersects = raycaster.intersectObjects(interactables, true);
            if (intersects.length > 0) {
                const obj = intersects[0].object;
                if (obj === vr3DButtonMesh && globalEnterVRFunc) { globalEnterVRFunc(); return; }
                
                const currentData = learningData[String(currentPhase)]; 
                if (!currentData) return;

                const step = currentData[currentStepIndex];
                if (isDragging && (step.type === 'press' || step.type === 'click')) {
                    isDragging = false; const targetGroup = intersects[0].object.parent;
                    if (targetGroup) gsap.to(targetGroup.scale, { x: 1.5, y: 1.5, z: 1.5, duration: 0.2, yoyo: true, repeat: 1 });
                    setTimeout(() => { nextStep(); }, 800);
                }
            }

            if (point && isDragging) {
                if (ghostHand) {
                    ghostHand.visible = true; ghostHand.position.copy(point); ghostHand.position.y += 0.2;
                    const step = currentData[currentStepIndex];
                    if (step.type === 'drag') {
                        const endPos = new THREE.Vector3(step.end.x + model.position.x, step.end.y + model.position.y, step.end.z + model.position.z);
                        if (ghostHand.position.distanceTo(endPos) < 0.8) {
                            isDragging = false; if (!isCameraLocked) controls.enabled = true; setTimeout(() => { nextStep(); }, 500);
                        }
                    }
                }
            }
        }

        function onTouchStart(e) { e.preventDefault(); onPointerDown(e.touches[0]); }
        function onTouchMove(e) { e.preventDefault(); onPointerMove(e.touches[0]); }
        function onPointerDown(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([vr3DButtonMesh], true);
            if (intersects.length > 0 && globalEnterVRFunc) { globalEnterVRFunc(); return; }
            const gameIntersects = raycaster.intersectObjects(interactables, true);
            if (gameIntersects.length > 0) { isDragging = true; controls.enabled = false; checkIntersection(); } else { controls.enabled = true; }
        }
        function onPointerMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            if (isDragging) { raycaster.setFromCamera(mouse, camera); checkIntersection(); }
        }
        function onPointerUp() {
            if (isDragging) { checkIntersection(); isDragging = false; if (!isCameraLocked) controls.enabled = true; if (ghostHand) ghostHand.visible = false; }
        }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        function loadEnvironment() {
            const loader = new GLTFLoader(); 
            loader.load(BASE_URL + 'A01.glb', (gltf) => {
                const room = gltf.scene; room.scale.set(20, 20, 20);
                room.traverse(c => { if (c.isMesh) c.receiveShadow = true; }); scene.add(room);
            });
            loadModel('male');
        }
        
        function loadModel(type) {
            if (model) scene.remove(model);
            activeModelType = type;
            const config = MODEL_CONFIG[type];
            modelPos = { ...config.pos };
            modelRot = { ...config.rot };
            modelScale = config.scale;

            const loader = new GLTFLoader();
            loader.load(BASE_URL + (type === 'male' ? 'B01.glb' : 'B02.glb'), (gltf) => {
                model = gltf.scene;
                model.position.set(modelPos.x, modelPos.y, modelPos.z);
                model.scale.set(modelScale, modelScale, modelScale);
                model.rotation.set(modelRot.x, modelRot.y, modelRot.z);
                
                model.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true; child.receiveShadow = true; child.frustumCulled = false;
                        if (child.material) { child.material = new THREE.MeshStandardMaterial({ color: child.material.color, map: child.material.map, skinning: true }); }
                    }
                });
                bones = {};
                model.traverse(child => {
                    if (child.isBone) {
                        const name = child.name.toLowerCase().replace(/[^a-z0-9]/g, '');
                        if (name.includes('left') && name.includes('thigh')) bones.leftUpLeg = child;
                        else if (name.includes('left') && name.includes('leg')) bones.leftLeg = child;
                        else if (name.includes('right') && name.includes('thigh')) bones.rightUpLeg = child;
                        else if (name.includes('right') && name.includes('leg')) bones.rightLeg = child;
                    }
                });
                scene.add(model); applyPose('flat');
                document.getElementById('welcome').style.display = 'none'; document.getElementById('ui').style.display = 'block';
                setPhase(1);
            });
        }

        function setPhase(p) {
            currentPhase = p; currentStepIndex = 0;
            document.querySelectorAll('.phase-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('p' + p); if (btn) btn.classList.add('active');
            if (btn) safeSetText('phase-title', btn.innerText);
            setupStep();
        }

        function setupStep() {
            interactables.forEach(obj => { if (obj !== vr3DButtonMesh) scene.remove(obj); });
            interactables = [vr3DButtonMesh]; 

            const currentData = learningData[String(currentPhase)];
            if (!currentData) { console.warn("Learning data undefined for phase:", currentPhase); return; }

            const step = currentData[currentStepIndex];
            if (!step) return;

            safeSetText('step-num', step.id); safeSetText('action-text', step.text); safeSetText('action-note', step.note);
            updateInstructionBoard(`STEP ${step.id} ${step.text}`, step.note); 
            
            updateCameraView(step);

            if (step.pose) applyPose(step.pose); else applyPose('flat');
            
            vrHitStatus = { isTouchingStart: false, touchStartTime: 0, activeHand: null };

            if (step.type === 'drag') {
                const startObj = createInteractable(step.start, 'ğŸŸ¢', 'start'); startObj.userData.isStart = true;
                const endObj = createInteractable(step.end, 'ğŸ', 'end', true); endObj.userData.isEnd = true;
            } else {
                createInteractable(step.pos, step.icon, 'click');
            }
        }

        function createInteractable(pos, icon, type, isHidden = false) {
            const group = new THREE.Group();
            group.position.set(pos.x + model.position.x, pos.y + model.position.y + 0.1, pos.z + model.position.z);
            const map = createEmojiTexture(icon);
            const iconMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.5), new THREE.MeshBasicMaterial({ map: map, transparent: true, depthTest: false }));
            const hitBox = new THREE.Mesh(new THREE.SphereGeometry(VR_CONFIG.DETECTION_RADIUS, 16, 16), new THREE.MeshBasicMaterial({ visible: false }));
            group.add(iconMesh); group.add(hitBox);
            if (isHidden) group.visible = false;
            scene.add(group); interactables.push(group);
            gsap.to(iconMesh.scale, { x: 1.2, y: 1.2, duration: 0.8, yoyo: true, repeat: -1 });
            group.tick = () => { iconMesh.lookAt(camera.position); };
            return group;
        }

        function createEmojiTexture(emoji) {
            const c = document.createElement('canvas'); c.width = 128; c.height = 128;
            const ctx = c.getContext('2d'); ctx.font = '100px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(emoji, 64, 64); return new THREE.CanvasTexture(c);
        }

        function nextStep() {
            const list = learningData[String(currentPhase)];
            if (currentStepIndex < list.length - 1) { currentStepIndex++; setupStep(); } 
            else { if (learningData[String(currentPhase + 1)]) setTimeout(() => setPhase(currentPhase + 1), 2000); else setTimeout(() => setPhase(1), 2000); }
        }

        function prevStep() { if (currentStepIndex > 0) { currentStepIndex--; setupStep(); } }
        function forceComplete() { nextStep(); }
        function resetCam() { if (!renderer.xr.isPresenting) controls.reset(); }
        
        function toggleCameraLock() { 
            isCameraLocked = !isCameraLocked; 
            controls.enabled = !isCameraLocked;
            const btn = document.getElementById('lock-btn');
            if(isCameraLocked) {
                btn.classList.add('locked'); btn.innerHTML = 'ğŸ”’ å°æ’­é–å®š';
                const currentData = learningData[String(currentPhase)];
                if(currentData) updateCameraView(currentData[currentStepIndex]);
            } else { btn.classList.remove('locked'); btn.innerHTML = 'ğŸ”“ è‡ªç”±è¦–è§’'; }
        }
        
        function toggleMenu() { document.getElementById('side-menu').classList.toggle('show'); }
        
        function applyPose(poseName) {
            const pose = POSES[poseName];
            if (!pose) return;
            document.querySelectorAll('.pose-btn').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`btn-pose-${poseName}`);
            if (activeBtn) activeBtn.classList.add('active');
            gsap.to(poseControls, {
                leftThigh: pose.leftThigh, leftKnee: pose.leftKnee, rightThigh: pose.rightThigh, rightKnee: pose.rightKnee,
                duration: 0.5, onUpdate: updatePose
            });
        }

        function updatePose() {
            if (bones.leftUpLeg) bones.leftUpLeg.rotation.x = THREE.MathUtils.degToRad(poseControls.leftThigh);
            if (bones.leftLeg) bones.leftLeg.rotation.x = THREE.MathUtils.degToRad(poseControls.leftKnee);
            if (bones.rightUpLeg) bones.rightUpLeg.rotation.x = THREE.MathUtils.degToRad(poseControls.rightThigh);
            if (bones.rightLeg) bones.rightLeg.rotation.x = THREE.MathUtils.degToRad(poseControls.rightKnee);
        }

        function onSliderChange() {
            const lThighEl = document.getElementById('range-left-thigh');
            if (!lThighEl) return;
            poseControls.leftThigh = parseFloat(lThighEl.value);
            updatePose();
            safeSetText('val-left-thigh', Math.round(poseControls.leftThigh) + 'Â°');
        }

        function toggleModel() {
            const newType = activeModelType === 'male' ? 'female' : 'male';
            loadModel(newType);
        }

        window.initApp = initApp; window.toggleCameraLock = toggleCameraLock; window.toggleMenu = toggleMenu;
        window.applyPose = applyPose; window.setPhase = setPhase; window.resetCam = resetCam;
        window.toggleModel = toggleModel; window.prevStep = prevStep; window.forceComplete = forceComplete;
        window.onSliderChange = onSliderChange;
    </script>
</body>
</html>
