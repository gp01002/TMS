<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‰¾æŸåœ‹éš›èŠ³ç™‚ - ç‘å…¸å¼è…¿éƒ¨æŒ‰æ‘©VRæ•™å­¸ç³»çµ± (æ··åˆäº’å‹•ç‰ˆ)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        .game-container { width: 100vw; height: 100vh; position: relative; }
        
        /* æ­¡è¿ç•«é¢ */
        .welcome-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.98) 0%, rgba(118, 75, 162, 0.98) 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000; transition: opacity 0.5s;
        }
        .welcome-screen.hidden { opacity: 0; pointer-events: none; }
        .welcome-content { text-align: center; color: white; padding: 40px; }
        .welcome-content h1 { font-size: 48px; margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .welcome-content p { font-size: 18px; margin-bottom: 30px; line-height: 1.8; }
        
        .enter-btn {
            background: white; color: #667eea; border: none; padding: 20px 60px; 
            font-size: 24px; border-radius: 50px; cursor: pointer; font-weight: bold; 
            margin: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); transition: all 0.3s;
        }
        .enter-btn:hover { transform: translateY(-5px) scale(1.05); box-shadow: 0 15px 40px rgba(0,0,0,0.4); }

        /* ä»‹é¢å±¤ */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }

        .status-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(255,255,255,0.95); padding: 15px 40px; border-radius: 50px;
            font-weight: bold; color: #333; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: flex; gap: 20px; align-items: center; pointer-events: auto;
        }

        /* å·¦å´é¢æ¿ */
        .control-panel {
            position: absolute; left: 20px; top: 90px; width: 280px;
            background: rgba(255,255,255,0.98); border-radius: 20px; padding: 20px;
            max-height: calc(100vh - 360px); overflow-y: auto; pointer-events: auto;
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
        }
        
        /* å³å´é¢æ¿ */
        .learning-panel {
            position: absolute; right: 20px; top: 90px; width: 360px;
            background: rgba(255,255,255,0.98); border-radius: 20px; padding: 25px;
            pointer-events: auto; box-shadow: 0 8px 30px rgba(0,0,0,0.3);
            max-height: calc(100vh - 110px); overflow-y: auto;
        }

        .phase-btn {
            display: block; width: 100%; padding: 15px; margin-bottom: 10px;
            border: 2px solid #e0e0e0; background: white; border-radius: 12px; 
            cursor: pointer; text-align: left; font-weight: bold; transition: all 0.3s;
            font-size: 14px;
        }
        .phase-btn:hover { 
            background: linear-gradient(90deg, #f0f0f0, #fafafa); 
            transform: translateX(5px); border-color: #667eea;
        }
        .phase-btn.active { 
            background: linear-gradient(135deg, #667eea, #764ba2); 
            color: white; border: none; 
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .step-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-left: 5px solid #667eea;
            padding: 20px; margin-bottom: 20px; border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .step-number { 
            font-size: 16px; color: #667eea; font-weight: bold; 
            margin-bottom: 8px; display: flex; align-items: center; gap: 8px;
        }
        .step-desc { 
            font-size: 20px; font-weight: bold; margin-bottom: 10px; 
            color: #333; line-height: 1.4;
        }
        .step-note { 
            font-size: 14px; color: #555; line-height: 1.6; 
            background: white; padding: 10px; border-radius: 8px;
            margin-top: 10px;
        }
        
        .technique-tag {
            display: inline-block; background: #667eea; color: white;
            padding: 6px 15px; border-radius: 20px; font-size: 13px;
            margin-top: 10px; font-weight: bold;
        }
        
        .interaction-tag {
            display: inline-block; background: #11998e; color: white;
            padding: 6px 15px; border-radius: 20px; font-size: 13px;
            margin-top: 10px; margin-left: 8px; font-weight: bold;
        }

        .progress-bar {
            width: 100%; height: 8px; background: #e0e0e0; 
            border-radius: 10px; overflow: hidden; margin: 15px 0;
        }
        .progress-fill {
            height: 100%; background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.5s ease; border-radius: 10px;
        }

        .nav-btn {
            background: linear-gradient(135deg, #667eea, #764ba2); 
            color: white; border: none; padding: 12px 25px;
            border-radius: 30px; cursor: pointer; font-size: 16px; 
            font-weight: bold; transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        .nav-btn:disabled { 
            background: #ccc; cursor: not-allowed; 
            box-shadow: none; transform: none;
        }

        /* äº’å‹•å¼•å°è»Œè·¡ */
        .guide-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 150;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .guide-arrow.show { opacity: 1; }
        
        /* æ‹–æ›³æç¤º */
        .drag-hint {
            position: absolute;
            background: rgba(102, 126, 234, 0.95);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 160;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .drag-hint.show { opacity: 1; }
        
        /* æŒ‰å£“é€²åº¦åœˆ */
        .press-circle {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            z-index: 150;
        }
        .press-circle.show { opacity: 1; }
        .press-fill {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 4px solid #11998e;
            border-top-color: transparent;
            border-right-color: transparent;
            transform: rotate(0deg);
            transition: transform 0.1s linear;
        }

        /* Debug é¢æ¿ */
        .debug-panel {
            position: absolute; bottom: 20px; left: 20px; 
            background: rgba(0,0,0,0.9); color: white; 
            padding: 15px; border-radius: 12px; font-size: 12px; 
            pointer-events: auto; width: 260px;
            max-height: 280px; overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .debug-section { 
            margin-bottom: 15px; border-bottom: 1px solid #444; 
            padding-bottom: 10px; 
        }
        .debug-title { 
            font-weight: bold; color: #667eea; margin-bottom: 8px; 
            font-size: 13px; 
        }
        .debug-row { 
            margin-bottom: 8px; display: flex; 
            justify-content: space-between; align-items: center; 
        }
        .debug-row label { width: 55px; font-size: 11px; }
        .debug-row input { flex: 1; margin-left: 8px; }
        .debug-row .value { 
            font-size: 10px; color: #aaa; 
            min-width: 40px; text-align: right; 
        }

        .loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; font-weight: bold; 
            text-shadow: 0 2px 8px rgba(0,0,0,0.8);
            pointer-events: none; display: none;
            background: rgba(0,0,0,0.7); padding: 20px 40px;
            border-radius: 15px;
        }
        .loading.show { display: block; }

        .feedback {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85); color: #fff; padding: 20px 40px; 
            border-radius: 40px; font-size: 24px; opacity: 0; 
            pointer-events: none; transition: opacity 0.3s; z-index: 200;
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
            font-weight: bold;
        }
        
        /* äº’å‹•æ¨¡å¼æŒ‡ç¤º */
        .interaction-mode {
            position: absolute; top: 100px; left: 50%; transform: translateX(-50%);
            background: linear-gradient(135deg, #11998e, #38ef7d);
            color: white; padding: 12px 30px; border-radius: 30px;
            font-weight: bold; font-size: 18px;
            box-shadow: 0 6px 20px rgba(17, 153, 142, 0.4);
            pointer-events: none; opacity: 0;
            transition: all 0.3s; z-index: 150;
        }
        .interaction-mode.show { opacity: 1; }
    </style>
</head>
<body>

    <div class="game-container">
        <div id="canvas-container" style="width:100%; height:100%; background:#000;"></div>

        <!-- æ­¡è¿é  -->
        <div class="welcome-screen" id="welcome-screen">
            <div class="welcome-content">
                <h1>ğŸŒ¿ è‰¾æŸåœ‹éš›èŠ³ç™‚å­¸é™¢</h1>
                <h2 style="font-size: 36px; margin-bottom: 15px;">ç‘å…¸å¼è…¿éƒ¨æŒ‰æ‘© VR æ•™å­¸ç³»çµ±</h2>
                <p style="font-size: 20px; line-height: 1.8;">
                    âœ¨ æ··åˆäº’å‹•æ¨¡å¼ - çœŸå¯¦æ‰‹æ³•é«”é©—<br>
                    ğŸ¯ æ‹–æ›³è»Œè·¡ + æŒ‰å£“è¨ˆæ™‚ + é †åºé»æ“Š<br>
                    ğŸ¥½ åŸ¹é¤Šå°ˆæ¥­è‚Œè‚‰è¨˜æ†¶
                </p>
                <button class="enter-btn" onclick="startGame()">ğŸ“ é–‹å§‹äº’å‹•è¨“ç·´</button>
            </div>
        </div>

        <div class="ui-layer" id="ui-layer" style="display:none;">
            <div class="status-bar">
                <span>ğŸ« VR å°ˆæ¥­æ•™å®¤</span>
                <span id="model-status">ğŸ‘¤ è¼‰å…¥ä¸­...</span>
                <span id="progress-status">ğŸ“Š é€²åº¦: 0%</span>
            </div>
            
            <!-- äº’å‹•æ¨¡å¼æç¤º -->
            <div class="interaction-mode" id="interaction-mode">ğŸ® æº–å‚™äº’å‹•</div>

            <!-- æ‹–æ›³æç¤º -->
            <div class="drag-hint" id="drag-hint">ğŸ‘† æŒ‰ä½ä¸¦æ²¿ç®­é ­æ‹–æ›³</div>
            
            <!-- æŒ‰å£“é€²åº¦åœˆ -->
            <div class="press-circle" id="press-circle">
                <div class="press-fill" id="press-fill"></div>
            </div>

            <!-- å·¦å´é¢æ¿ -->
            <div class="control-panel">
                <h3 style="margin-bottom:18px; color:#667eea; font-size:18px;">ğŸ“‹ ç™‚ç¨‹éšæ®µ</h3>
                
                <button class="phase-btn" onclick="setPhase(1)" id="p1">
                    <div style="font-size:16px;">éšæ®µä¸€</div>
                    <div style="font-size:12px; color:#888; margin-top:4px;">æº–å‚™èˆ‡èµ·å§‹å®‰æ’«</div>
                </button>
                
                <button class="phase-btn" onclick="setPhase(2)" id="p2">
                    <div style="font-size:16px;">éšæ®µäºŒ</div>
                    <div style="font-size:12px; color:#888; margin-top:4px;">å·¦è…¿æŒ‰æ‘©æ“ä½œ</div>
                </button>
                
                <button class="phase-btn" onclick="setPhase(3)" id="p3">
                    <div style="font-size:16px;">éšæ®µä¸‰</div>
                    <div style="font-size:12px; color:#888; margin-top:4px;">å³è…¿æŒ‰æ‘©æ“ä½œ</div>
                </button>
                
                <button class="phase-btn" onclick="setPhase(4)" id="p4">
                    <div style="font-size:16px;">éšæ®µå››</div>
                    <div style="font-size:12px; color:#888; margin-top:4px;">çµå°¾èˆ‡å®‰æ’«</div>
                </button>
                
                <div class="progress-bar" style="margin-top:20px;">
                    <div class="progress-fill" id="progress-fill" style="width:0%;"></div>
                </div>
                <div style="text-align:center; font-size:12px; color:#888; margin-top:8px;">
                    æ•´é«”å®Œæˆåº¦: <span id="completion-percent">0%</span>
                </div>
                
                <hr style="margin: 20px 0; border:0; border-top:2px solid #e0e0e0;">
                
                <div style="font-size:13px; color:#555; font-weight:bold; margin-bottom:8px;">ğŸ”„ åˆ‡æ›æ¨¡ç‰¹å…’</div>
                <div style="display:flex; gap:8px;">
                    <button class="phase-btn" style="padding:10px; text-align:center; flex:1;" onclick="loadModel('male')">
                        ğŸ‘¨<br><span style="font-size:11px;">ç”·æ€§</span>
                    </button>
                    <button class="phase-btn" style="padding:10px; text-align:center; flex:1;" onclick="loadModel('female')">
                        ğŸ‘©<br><span style="font-size:11px;">å¥³æ€§</span>
                    </button>
                </div>
            </div>

            <!-- å³å´é¢æ¿ -->
            <div class="learning-panel">
                <h3 style="margin-bottom:18px; color:#667eea; font-size:18px;">ğŸ“– æ“ä½œæŒ‡å¼•</h3>
                
                <div id="step-display">
                    <div class="step-card">
                        <div class="step-number" id="step-id">
                            <span>ğŸ¯</span>
                            <span>è«‹é¸æ“‡ç™‚ç¨‹éšæ®µ</span>
                        </div>
                        <div class="step-desc" id="step-text">é»é¸å·¦å´éšæ®µé–‹å§‹å°ˆæ¥­è¨“ç·´</div>
                        <div class="step-note" id="step-note">
                            ğŸ’¡ æç¤ºï¼šæ¯å€‹æ­¥é©Ÿéƒ½æœ‰å°ˆå±¬çš„äº’å‹•æ–¹å¼
                        </div>
                        <div id="technique-display"></div>
                    </div>
                </div>

                <div style="display:flex; gap:12px; margin-top:20px;">
                    <button class="nav-btn" style="background:#888; flex:1;" onclick="prevStep()">
                        â¬… ä¸Šä¸€æ­¥
                    </button>
                    <button class="nav-btn" style="flex:1;" onclick="nextStep()">
                        ä¸‹ä¸€æ­¥ â¡
                    </button>
                </div>
                
                <div style="display:flex; gap:12px; margin-top:12px;">
                    <button id="lock-btn-main" class="nav-btn" style="background:#ff6b6b; flex:1; font-size:16px;" onclick="toggleCameraLock()">
                        ğŸ”’ é–å®šç•«é¢
                    </button>
                </div>
                
                <div style="margin-top:20px; padding:15px; background:#f8f9fa; border-radius:10px;">
                    <div style="font-size:13px; color:#555; margin-bottom:8px; font-weight:bold;">
                        ğŸ® äº’å‹•æ¨¡å¼èªªæ˜
                    </div>
                    <div style="font-size:12px; color:#666; line-height:1.8;">
                        <strong>ğŸ–±ï¸ æ‹–æ›³è»Œè·¡</strong>ï¼šé•·æ¨å‹•ä½œ<br>
                        <strong>â±ï¸ æŒ‰å£“è¨ˆæ™‚</strong>ï¼šå®šé»æŒ‰æ‘©<br>
                        <strong>ğŸ‘† é †åºé»æ“Š</strong>ï¼šåˆ†æ®µæ“ä½œ<br>
                        <div style="margin-top:8px; padding:8px; background:#fff3cd; border-radius:6px; border-left:3px solid #ffc107;">
                            <strong>âš ï¸ äº’å‹•å‰å¿…åš</strong>ï¼šå…ˆé»ã€ŒğŸ”’ é–å®šç•«é¢ã€
                        </div>
                    </div>
                </div>
            </div>

            <!-- Debug é¢æ¿ -->
            <div class="debug-panel">
                <div class="debug-section">
                    <div class="debug-title">ğŸ”§ æ¨¡ç‰¹å…’ä½ç½®å¾®èª¿</div>
                    <div class="debug-row">
                        <label>å‰å¾Œ X</label>
                        <input type="range" id="range-x" min="-3" max="3" step="0.05" value="-1.2" oninput="updatePos()">
                        <span class="value" id="val-x">-1.2</span>
                    </div>
                    <div class="debug-row">
                        <label>é«˜åº¦ Y</label>
                        <input type="range" id="range-y" min="0" max="4" step="0.05" value="2.35" oninput="updatePos()">
                        <span class="value" id="val-y">2.35</span>
                    </div>
                    <div class="debug-row">
                        <label>å·¦å³ Z</label>
                        <input type="range" id="range-z" min="-3" max="3" step="0.05" value="0" oninput="updatePos()">
                        <span class="value" id="val-z">0.0</span>
                    </div>
                    <div class="debug-row">
                        <label>å¤§å°</label>
                        <input type="range" id="range-scale" min="0.5" max="2" step="0.1" value="1.0" oninput="updatePos()">
                        <span class="value" id="val-scale">1.0</span>
                    </div>
                </div>

                <div style="text-align: center; margin-top:10px;">
                    <button style="padding:8px 16px; cursor:pointer; border-radius:8px; background:#667eea; color:white; border:none; font-weight:bold; margin:4px;" onclick="resetCam()">
                        ğŸ”„ é‡ç½®è¦–è§’
                    </button>
                </div>
            </div>

            <div class="loading" id="loading-text">â³ è¼‰å…¥æ•™å­¸è³‡æºä¸­...</div>
            <div class="feedback" id="feedback-text"></div>
        </div>
    </div>

    <script>
        const BASE_URL = "https://gp01002.github.io/TMS/";

        // æ··åˆäº’å‹•æ¨¡å¼å­¸ç¿’è³‡æ–™åº«
        const learningData = {
            1: [
                { 
                    id: "1.1", 
                    text: "åœ¨æ¯›å·¾ä¸Šä¿¯é †è‡³å¤§è…¿", 
                    note: "è¼•æŸ”åœ°å°‡é›™æ‰‹æ”¾åœ¨æ¯›å·¾ä¸Šï¼Œå¾è†è“‹è™•å‘ä¸Šä¿¯é †è‡³å¤§è…¿ï¼Œå»ºç«‹åˆæ­¥æ¥è§¸èˆ‡ä¿¡ä»»æ„Ÿã€‚æ‰‹æ³•è¦è¼•æŸ”ã€é€£è²«ï¼Œè®“å®¢æˆ¶æ„Ÿå—åˆ°æº«æš–ã€‚", 
                    target: 'thighs', 
                    technique: "ä¿¯é †æ³• Effleurage",
                    interactionMode: "drag", // æ‹–æ›³è»Œè·¡
                    dragPath: [{x: 0.5, y: -0.25, z: 0}, {x: 0.2, y: -0.25, z: 0}], // å¾è†è“‹åˆ°å¤§è…¿
                    duration: 3 // å»ºè­°3ç§’å®Œæˆ
                },
                { 
                    id: "1.2", 
                    text: "ç”±å…©å´æ»‘ä¸‹è‡³è…³åº•", 
                    note: "é›™æ‰‹æ²¿è‘—è…¿éƒ¨å…©å´ï¼Œä»¥è¼•æŸ”æµæš¢çš„å‹•ä½œå‘ä¸‹æ»‘è‡³è…³åº•ï¼Œä¿æŒé€£çºŒæ¥è§¸ã€‚", 
                    target: 'feet', 
                    technique: "é•·æ¨æ³•",
                    interactionMode: "drag",
                    dragPath: [{x: 0.2, y: -0.25, z: 0}, {x: 1.0, y: -0.35, z: 0}], // å¾å¤§è…¿åˆ°è…³åº•
                    duration: 3
                },
                { 
                    id: "1.3", 
                    text: "å°‡æ¯›å·¾æ²åœ¨é›™è…¿ä¹‹é–“", 
                    note: "å°å¿ƒåœ°å°‡æ¯›å·¾æ²èµ·ä¸¦æ”¾ç½®åœ¨é›™è…¿ä¹‹é–“ï¼Œç¢ºä¿è¦†è“‹éš±ç§éƒ¨ä½ã€‚", 
                    target: 'knees', 
                    technique: "æ¯›å·¾è™•ç†",
                    interactionMode: "click", // å–®é»é»æ“Š
                    clickCount: 1
                },
                { 
                    id: "1.4", 
                    text: "é›™è…¿ç”±é˜¿åŸºé‡Œæ–¯è…±ä¸Šæ¨", 
                    note: "å¾è…³å¾Œè·Ÿçš„é˜¿åŸºé‡Œæ–¯è…±é–‹å§‹ï¼Œé›™æ‰‹åŒæ­¥å‘ä¸Šæ¨æ’«è‡³å¤§è…¿ã€‚", 
                    target: 'legs', 
                    technique: "é›™æ‰‹åŒæ­¥é•·æ¨",
                    interactionMode: "sequence", // é †åºé»æ“Š
                    sequence: ['feet', 'calves', 'thighs'], // è…³â†’å°è…¿â†’å¤§è…¿
                    sequenceCount: 3
                },
                { 
                    id: "1.5", 
                    text: "å°‡å³è…³è¦†è“‹", 
                    note: "ç”¨å¦ä¸€æ¢æ¯›å·¾æˆ–å¸ƒå·¾è¼•æŸ”åœ°è¦†è“‹å³è…¿ï¼Œç¢ºä¿ä¿æš–ã€‚", 
                    target: 'right_leg', 
                    technique: "ä¿æš–è™•ç†",
                    interactionMode: "click",
                    clickCount: 1
                },
                { 
                    id: "1.6", 
                    text: "ä¸Šæ²¹", 
                    note: "å–é©é‡æŒ‰æ‘©æ²¹æ–¼é›™æ‰‹æŒå¿ƒï¼Œæ“ç†±å¾Œæº–å‚™æ–½ä½œã€‚", 
                    target: 'hands', 
                    technique: "æ²¹å“æº–å‚™",
                    interactionMode: "press", // æŒ‰å£“è¨ˆæ™‚
                    pressDuration: 2 // æŒ‰å£“2ç§’
                },
                { 
                    id: "1.7", 
                    text: "å¤§å®‰æ’«", 
                    note: "é›™æ‰‹æ”¾åœ¨è…³åº•ï¼Œåœç•™ç‰‡åˆ»ï¼Œæ·±å‘¼å¸ï¼Œå»ºç«‹èˆ‡å®¢æˆ¶çš„èƒ½é‡é€£çµã€‚", 
                    target: 'feet', 
                    technique: "å®‰æ’«æ¥è§¸æ³•",
                    interactionMode: "press",
                    pressDuration: 3 // æŒ‰å£“3ç§’
                }
            ]
        };

        let scene, camera, renderer, controls, model;
        let currentPhase = 1;
        let currentStepIndex = 0;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let targets = [];
        let isDragging = false;
        let dragStartTime = 0;
        let dragPath = [];
        let currentInteractionMode = null;
        let pressStartTime = 0;
        let isPressing = false;
        let sequenceProgress = 0;
        let targetOffset = {x: 0, y: 0, z: 0}; // å›ºå®šåç§»é‡ï¼Œä¸å†æ‰‹å‹•èª¿æ•´
        let cameraLocked = false; // ç•«é¢é–å®šç‹€æ…‹

        function startGame() {
            document.getElementById('welcome-screen').classList.add('hidden');
            document.getElementById('ui-layer').style.display = 'block';
            setTimeout(initThreeJS, 100);
        }
        
        function toggleCameraLock() {
            cameraLocked = !cameraLocked;
            controls.enabled = !cameraLocked;
            
            const btn = document.getElementById('lock-btn');
            const btnMain = document.getElementById('lock-btn-main');
            
            if (cameraLocked) {
                // é–å®šç‹€æ…‹
                if (btn) {
                    btn.innerText = 'ğŸ”“ è§£é–ç•«é¢';
                    btn.style.background = '#51cf66';
                }
                if (btnMain) {
                    btnMain.innerHTML = 'ğŸ”“ è§£é–ç•«é¢';
                    btnMain.style.background = '#51cf66';
                }
                showFeedback('âœ… ç•«é¢å·²é–å®šï¼Œå¯ä»¥äº’å‹•äº†', true);
                console.log('ğŸ”’ ç•«é¢å·²é–å®š - ç¾åœ¨å¯ä»¥æ‹–æ›³çƒé«”äº†');
            } else {
                // è§£é–ç‹€æ…‹
                if (btn) {
                    btn.innerText = 'ğŸ”’ é–å®šç•«é¢';
                    btn.style.background = '#ff6b6b';
                }
                if (btnMain) {
                    btnMain.innerHTML = 'ğŸ”’ é–å®šç•«é¢';
                    btnMain.style.background = '#ff6b6b';
                }
                showFeedback('âœ… ç•«é¢å·²è§£é–ï¼Œå¯ä»¥èª¿æ•´è¦–è§’', true);
                console.log('ğŸ”“ ç•«é¢å·²è§£é– - ç¾åœ¨å¯ä»¥æ—‹è½‰è¦–è§’äº†');
            }
        }

        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            
            const grid = new THREE.GridHelper(20, 20, 0x888888, 0x444444);
            scene.add(grid);

            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(2, 3, 3);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 2;
            controls.maxDistance = 15;

            const ambient = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-5, 5, -5);
            scene.add(fillLight);

            // å„ªåŒ– raycaster è¨­å®š
            raycaster.params.Points.threshold = 0.3;
            raycaster.params.Line.threshold = 0.3;

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.style.cursor = 'default';
            renderer.setAnimationLoop(animate);

            loadRoom();
            loadModel('male');
            setPhase(1);
        }

        function loadRoom() {
            const loader = new THREE.GLTFLoader();
            loader.load(BASE_URL + 'A01.glb', (gltf) => {
                const room = gltf.scene;
                room.scale.set(20, 20, 20);
                scene.add(room);
            });
        }

        function loadModel(type) {
            if (model) scene.remove(model);
            
            document.getElementById('loading-text').classList.add('show');
            document.getElementById('model-status').innerText = 'ğŸ‘¤ è¼‰å…¥æ¨¡ç‰¹å…’ä¸­...';
            
            const url = BASE_URL + (type === 'male' ? 'B01.glb' : 'B02.glb');

            const loader = new THREE.GLTFLoader();
            loader.load(url, (gltf) => {
                model = gltf.scene;
                
                updatePos(); 
                model.rotation.set(-Math.PI/2, 0, Math.PI/2);
                
                scene.add(model);
                
                document.getElementById('model-status').innerText = 'âœ… æ¨¡ç‰¹å…’å·²å°±ä½';
                document.getElementById('model-status').style.background = '#d4edda';
                document.getElementById('model-status').style.color = '#155724';
                
                updateTargets();
                document.getElementById('loading-text').classList.remove('show');
            });
        }

        function updatePos() {
            if (model) {
                const x = parseFloat(document.getElementById('range-x').value);
                const y = parseFloat(document.getElementById('range-y').value);
                const z = parseFloat(document.getElementById('range-z').value);
                const scale = parseFloat(document.getElementById('range-scale').value);
                
                model.position.set(x, y, z);
                model.scale.set(scale, scale, scale);
                
                document.getElementById('val-x').innerText = x.toFixed(2);
                document.getElementById('val-y').innerText = y.toFixed(2);
                document.getElementById('val-z').innerText = z.toFixed(2);
                document.getElementById('val-scale').innerText = scale.toFixed(1);
                
                updateTargets();
            }
        }

        function updateTargetOffset() {
            targetOffset.x = parseFloat(document.getElementById('target-x').value);
            targetOffset.y = parseFloat(document.getElementById('target-y').value);
            targetOffset.z = parseFloat(document.getElementById('target-z').value);
            
            document.getElementById('val-tx').innerText = targetOffset.x.toFixed(2);
            document.getElementById('val-ty').innerText = targetOffset.y.toFixed(2);
            document.getElementById('val-tz').innerText = targetOffset.z.toFixed(2);
            
            updateTargets();
        }

        function updateTargets() {
            if (!model) return;
            
            if (targets.length > 0) {
                targets.forEach(t => scene.remove(t));
            }
            targets = [];

            const currentStep = learningData[currentPhase]?.[currentStepIndex];
            if (!currentStep) return;
            
            currentInteractionMode = currentStep.interactionMode;
            
            // é¡¯ç¤ºäº’å‹•æ¨¡å¼
            showInteractionMode(currentStep.interactionMode);
            
            // æ ¹æ“šäº’å‹•æ¨¡å¼å‰µå»ºä¸åŒçš„æ¨™è¨˜
            createInteractionTargets(currentStep);
        }

        function createInteractionTargets(step) {
            const basePos = model.position;
            
            if (step.interactionMode === 'drag') {
                // æ‹–æ›³æ¨¡å¼ï¼šå‰µå»ºèµ·é»å’Œçµ‚é»
                const path = step.dragPath;
                path.forEach((p, i) => {
                    const ball = createTargetBall(
                        basePos.x + p.x + targetOffset.x,
                        basePos.y + p.y + targetOffset.y,
                        basePos.z + p.z + targetOffset.z,
                        i === 0 ? 0x00ff00 : 0xffd700 // èµ·é»ç¶ è‰²ï¼Œçµ‚é»é‡‘è‰²
                    );
                    scene.add(ball);
                    targets.push(ball);
                });
                
                // å‰µå»ºè»Œè·¡ç·š
                createPathLine(path, basePos);
                
            } else if (step.interactionMode === 'press') {
                // æŒ‰å£“æ¨¡å¼ï¼šå‰µå»ºå–®å€‹å¤§çƒ
                const pos = getTargetPosition(step.target);
                const ball = createTargetBall(
                    basePos.x + pos.x + targetOffset.x,
                    basePos.y + pos.y + targetOffset.y,
                    basePos.z + pos.z + targetOffset.z,
                    0x11998e,
                    0.22  // æ›´å¤§çš„çƒ
                );
                scene.add(ball);
                targets.push(ball);
                
            } else if (step.interactionMode === 'sequence') {
                // é †åºæ¨¡å¼ï¼šå‰µå»ºå¤šå€‹ç·¨è™Ÿçƒ
                step.sequence.forEach((targetType, i) => {
                    const pos = getSequencePosition(targetType);
                    const ball = createTargetBall(
                        basePos.x + pos.x + targetOffset.x,
                        basePos.y + pos.y + targetOffset.y,
                        basePos.z + pos.z + targetOffset.z,
                        i === sequenceProgress ? 0x00ff00 : 0x888888
                    );
                    scene.add(ball);
                    targets.push(ball);
                });
                
            } else {
                // é»æ“Šæ¨¡å¼ï¼šå‰µå»ºå–®å€‹çƒ
                const pos = getTargetPosition(step.target);
                const ball = createTargetBall(
                    basePos.x + pos.x + targetOffset.x,
                    basePos.y + pos.y + targetOffset.y,
                    basePos.z + pos.z + targetOffset.z,
                    0x00ff00
                );
                scene.add(ball);
                targets.push(ball);
            }
        }

        function createTargetBall(x, y, z, color, size = 0.18) {
            const geo = new THREE.SphereGeometry(size, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.7 
            });
            const ball = new THREE.Mesh(geo, mat);
            ball.position.set(x, y, z);
            
            gsap.to(ball.material, { 
                opacity: 0.3, 
                duration: 0.8, 
                yoyo: true, 
                repeat: -1 
            });
            gsap.to(ball.scale, {
                x: 1.4, y: 1.4, z: 1.4,
                duration: 0.8,
                yoyo: true,
                repeat: -1
            });
            
            return ball;
        }

        function createPathLine(path, basePos) {
            const points = path.map(p => new THREE.Vector3(
                basePos.x + p.x + targetOffset.x,
                basePos.y + p.y + targetOffset.y,
                basePos.z + p.z + targetOffset.z
            ));
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineDashedMaterial({
                color: 0xffff00,
                linewidth: 3,
                scale: 1,
                dashSize: 0.15,
                gapSize: 0.08,
            });
            
            const line = new THREE.Line(geometry, material);
            line.computeLineDistances();
            scene.add(line);
            targets.push(line);
        }

        function getTargetPosition(targetType) {
            const positions = {
                'thighs': {x: 0.2, y: -0.25, z: 0},       // å¤§è…¿
                'feet': {x: 1.0, y: -0.35, z: 0},         // è…³åº•  
                'knees': {x: 0.5, y: -0.25, z: 0},        // è†è“‹
                'legs': {x: 0.4, y: -0.25, z: 0},         // è…¿éƒ¨
                'right_leg': {x: 0.4, y: -0.25, z: -0.25}, // å³è…¿
                'hands': {x: 0.5, y: 0.1, z: 0}           // æ‰‹éƒ¨ï¼ˆèª¿é«˜ä¸€é»ï¼‰
            };
            return positions[targetType] || {x: 0.5, y: -0.25, z: 0};
        }

        function getSequencePosition(targetType) {
            const positions = {
                'feet': {x: 1.0, y: -0.35, z: 0},         // è…³åº•ï¼ˆé˜¿åŸºé‡Œæ–¯è…±ï¼‰
                'calves': {x: 0.65, y: -0.25, z: 0},      // å°è…¿
                'thighs': {x: 0.2, y: -0.25, z: 0}        // å¤§è…¿
            };
            return positions[targetType] || {x: 0.5, y: -0.25, z: 0};
        }

        function showInteractionMode(mode) {
            const modeEl = document.getElementById('interaction-mode');
            const modeText = {
                'drag': 'ğŸ–±ï¸ æ‹–æ›³è»Œè·¡æ¨¡å¼',
                'press': 'â±ï¸ æŒ‰å£“è¨ˆæ™‚æ¨¡å¼',
                'sequence': 'ğŸ‘† é †åºé»æ“Šæ¨¡å¼',
                'click': 'ğŸ‘† é»æ“Šäº’å‹•æ¨¡å¼'
            };
            
            modeEl.innerText = modeText[mode] || 'ğŸ® äº’å‹•æ¨¡å¼';
            modeEl.classList.add('show');
            
            setTimeout(() => {
                modeEl.classList.remove('show');
            }, 3000);
        }

        function setPhase(p) {
            currentPhase = p;
            currentStepIndex = 0;
            sequenceProgress = 0;
            
            document.querySelectorAll('.phase-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('p' + p).classList.add('active');
            
            updateStepDisplay();
        }

        function nextStep() {
            const currentPhaseSteps = learningData[currentPhase];
            if (currentStepIndex < currentPhaseSteps.length - 1) {
                currentStepIndex++;
                sequenceProgress = 0;
                updateStepDisplay();
            } else {
                showFeedback(`éšæ®µ${currentPhase}å®Œæˆï¼`, true);
            }
        }

        function prevStep() {
            if (currentStepIndex > 0) {
                currentStepIndex--;
                sequenceProgress = 0;
                updateStepDisplay();
            }
        }

        function updateStepDisplay() {
            const step = learningData[currentPhase][currentStepIndex];
            if (!step) return;
            
            document.getElementById('step-id').innerHTML = `
                <span>ğŸ¯</span>
                <span>STEP ${step.id}</span>
            `;
            document.getElementById('step-text').innerText = step.text;
            document.getElementById('step-note').innerText = `ğŸ’¡ ${step.note}`;
            
            const modeIcons = {
                'drag': 'ğŸ–±ï¸ æ‹–æ›³è»Œè·¡',
                'press': 'â±ï¸ æŒ‰å£“è¨ˆæ™‚',
                'sequence': 'ğŸ‘† é †åºé»æ“Š',
                'click': 'ğŸ‘† é»æ“Šäº’å‹•'
            };
            
            document.getElementById('technique-display').innerHTML = `
                <div class="technique-tag">âœ¨ ${step.technique}</div>
                <div class="interaction-tag">${modeIcons[step.interactionMode]}</div>
            `;
            
            updateTargets();
        }

        function onMouseDown(e) {
            const step = learningData[currentPhase][currentStepIndex];
            if (!step) return;
            
            // è¨ˆç®—æ»‘é¼ ä½ç½®
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const meshTargets = targets.filter(t => t.isMesh);
            const intersects = raycaster.intersectObjects(meshTargets, true);
            
            console.log('ğŸ–±ï¸ é»æ“Šæª¢æ¸¬:', {
                'ç•«é¢é–å®š': cameraLocked ? 'âœ… æ˜¯' : 'âŒ å¦',
                'æ»‘é¼ ä½ç½®': {x: mouse.x.toFixed(2), y: mouse.y.toFixed(2)},
                'äº’å‹•æ¨¡å¼': step.interactionMode,
                'äº’å‹•é»æ•¸é‡': meshTargets.length,
                'äº’å‹•é»ä½ç½®': meshTargets.map(m => ({
                    x: m.position.x.toFixed(2),
                    y: m.position.y.toFixed(2),
                    z: m.position.z.toFixed(2)
                })),
                'é»æ“Šåˆ°': intersects.length > 0 ? 'âœ… æœ‰' : 'âŒ ç„¡'
            });
            
            // æª¢æŸ¥ç•«é¢æ˜¯å¦é–å®š
            if (!cameraLocked) {
                console.log('ğŸ’¡ æç¤ºï¼šè«‹å…ˆé»æ“Šã€ŒğŸ”’ é–å®šç•«é¢ã€æŒ‰éˆ•ï¼Œæ‰èƒ½é€²è¡Œäº’å‹•');
                showFeedback('ğŸ’¡ è«‹å…ˆé–å®šç•«é¢', false);
                return;
            }
            
            // å¦‚æœç›´æ¥é»æ“Šæ²’ä¸­ï¼Œæª¢æŸ¥è·é›¢æœ€è¿‘çš„çƒ
            let clickedBall = null;
            if (intersects.length > 0) {
                clickedBall = intersects[0].object;
                console.log('âœ… ç›´æ¥é»æ“ŠæˆåŠŸï¼');
            } else {
                // å˜—è©¦æ‰¾æœ€è¿‘çš„çƒï¼ˆå®¹éŒ¯æ©Ÿåˆ¶ï¼‰
                let minDistance = Infinity;
                const mouseWorldPos = new THREE.Vector3(mouse.x, mouse.y, 0).unproject(camera);
                
                meshTargets.forEach(ball => {
                    const screenPos = ball.position.clone().project(camera);
                    const distance = Math.sqrt(
                        Math.pow(screenPos.x - mouse.x, 2) + 
                        Math.pow(screenPos.y - mouse.y, 2)
                    );
                    
                    if (distance < minDistance && distance < 0.2) { // å®¹éŒ¯ç¯„åœ
                        minDistance = distance;
                        clickedBall = ball;
                    }
                });
                
                if (clickedBall) {
                    console.log('âœ… è¿‘ä¼¼é»æ“ŠæˆåŠŸï¼è·é›¢:', minDistance.toFixed(3));
                } else {
                    console.log('âŒ é»æ“Šä½ç½®é›¢çƒå¤ªé ï¼Œè«‹é»æ“Šçƒé«”ä¸­å¿ƒ');
                }
            }
            
            if (clickedBall) {
                // è¦–è¦ºåé¥‹
                clickedBall.material.emissive = new THREE.Color(0xffff00);
                setTimeout(() => {
                    if (clickedBall.material) {
                        clickedBall.material.emissive = new THREE.Color(0x000000);
                    }
                }, 200);
                
                if (step.interactionMode === 'drag') {
                    isDragging = true;
                    dragStartTime = Date.now();
                    dragPath = [clickedBall.position.clone()];
                    document.getElementById('drag-hint').classList.add('show');
                    console.log('ğŸ–±ï¸ é–‹å§‹æ‹–æ›³æ¨¡å¼');
                    showFeedback('é–‹å§‹æ‹–æ›³ï¼', true);
                    
                } else if (step.interactionMode === 'press') {
                    isPressing = true;
                    pressStartTime = Date.now();
                    
                    // é¡¯ç¤ºæŒ‰å£“åœˆåœ¨æ»‘é¼ ä½ç½®
                    const circle = document.getElementById('press-circle');
                    circle.style.left = e.clientX - 40 + 'px';
                    circle.style.top = e.clientY - 40 + 'px';
                    circle.classList.add('show');
                    updatePressCircle();
                    console.log('â±ï¸ é–‹å§‹æŒ‰å£“æ¨¡å¼ï¼Œéœ€è¦æŒ‰ä½', step.pressDuration, 'ç§’');
                    showFeedback(`æŒ‰ä½ ${step.pressDuration} ç§’`, true);
                    
                } else if (step.interactionMode === 'sequence') {
                    console.log('ğŸ‘† é †åºé»æ“Šæ¨¡å¼');
                    handleSequenceClick(clickedBall);
                    
                } else if (step.interactionMode === 'click') {
                    console.log('ğŸ‘† ç°¡å–®é»æ“Šæ¨¡å¼');
                    handleSimpleClick(clickedBall.position);
                }
            } else {
                console.log('âŒ æ²’æœ‰é»åˆ°äº’å‹•é»');
                console.log('ğŸ’¡ æç¤ºï¼šè«‹ç¢ºä¿é»æ“Šç¶ è‰²/é‡‘è‰²/é’ç¶ è‰²çƒé«”');
                console.log('ğŸ’¡ æˆ–ä½¿ç”¨ã€Œå¼·åˆ¶å®Œæˆæ­¤æ­¥é©Ÿã€æŒ‰éˆ•');
                showFeedback('è«‹é»æ“Šå½©è‰²çƒé«”', false);
            }
        }

        function onMouseMove(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            
            // æª¢æ¸¬æ˜¯å¦æ‡¸åœåœ¨äº’å‹•é»ä¸Š
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(targets.filter(t => t.isMesh));
            
            if (intersects.length > 0) {
                renderer.domElement.style.cursor = 'pointer';
                // è®“æ‡¸åœçš„çƒè®Šäº®
                intersects[0].object.material.opacity = 0.9;
            } else {
                renderer.domElement.style.cursor = 'default';
                // æ¢å¾©æ‰€æœ‰çƒçš„é€æ˜åº¦
                targets.forEach(t => {
                    if (t.isMesh && t.material.opacity > 0.7) {
                        t.material.opacity = 0.7;
                    }
                });
            }
            
            if (isDragging) {
                const modelIntersects = raycaster.intersectObjects([model], true);
                if (modelIntersects.length > 0) {
                    dragPath.push(modelIntersects[0].point.clone());
                }
            }
        }

        function onMouseUp(e) {
            const step = learningData[currentPhase][currentStepIndex];
            
            if (isDragging) {
                isDragging = false;
                document.getElementById('drag-hint').classList.remove('show');
                
                const dragDuration = (Date.now() - dragStartTime) / 1000;
                const success = validateDrag(dragPath, step.dragPath, dragDuration, step.duration);
                
                if (success) {
                    playDragEffect(dragPath);
                    showFeedback(`âœ… å®Œæˆ: ${step.text}`, true);
                    setTimeout(() => nextStep(), 1500);
                } else {
                    showFeedback('âŒ è«‹æ²¿è‘—è»Œè·¡æ‹–æ›³', false);
                }
                
                dragPath = [];
            }
            
            if (isPressing) {
                isPressing = false;
                document.getElementById('press-circle').classList.remove('show');
                
                const pressDuration = (Date.now() - pressStartTime) / 1000;
                if (pressDuration >= step.pressDuration) {
                    showFeedback(`âœ… å®Œæˆ: ${step.text}`, true);
                    setTimeout(() => nextStep(), 1500);
                } else {
                    showFeedback(`âŒ è«‹æŒ‰å£“ ${step.pressDuration} ç§’`, false);
                }
            }
        }

        function validateDrag(actualPath, expectedPath, actualDuration, expectedDuration) {
            // ç°¡åŒ–é©—è­‰ï¼šæª¢æŸ¥æ˜¯å¦æœ‰è¶³å¤ çš„é»ä¸”æ™‚é–“åˆç†
            return actualPath.length > 5 && 
                   actualDuration >= expectedDuration * 0.7 && 
                   actualDuration <= expectedDuration * 1.5;
        }

        function playDragEffect(path) {
            path.forEach((point, i) => {
                setTimeout(() => {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true })
                    );
                    particle.position.copy(point);
                    scene.add(particle);
                    
                    gsap.to(particle.material, {
                        opacity: 0,
                        duration: 0.5,
                        onComplete: () => scene.remove(particle)
                    });
                }, i * 20);
            });
        }

        function updatePressCircle() {
            if (!isPressing) return;
            
            const step = learningData[currentPhase][currentStepIndex];
            const elapsed = (Date.now() - pressStartTime) / 1000;
            const progress = Math.min(elapsed / step.pressDuration, 1);
            
            document.getElementById('press-fill').style.transform = `rotate(${progress * 360}deg)`;
            
            if (progress < 1) {
                requestAnimationFrame(updatePressCircle);
            }
        }

        function handleSequenceClick(clickedObject) {
            const step = learningData[currentPhase][currentStepIndex];
            const clickedIndex = targets.filter(t => t.isMesh).indexOf(clickedObject);
            
            if (clickedIndex === sequenceProgress) {
                // æ­£ç¢ºé †åº
                sequenceProgress++;
                
                if (sequenceProgress >= step.sequenceCount) {
                    // å®Œæˆæ‰€æœ‰é †åº
                    showFeedback(`âœ… å®Œæˆ: ${step.text}`, true);
                    setTimeout(() => {
                        sequenceProgress = 0;
                        nextStep();
                    }, 1500);
                } else {
                    // æ›´æ–°é¡¯ç¤ºä¸‹ä¸€å€‹
                    updateTargets();
                    showFeedback(`âœ… æ­¥é©Ÿ ${sequenceProgress}/${step.sequenceCount}`, true);
                }
            } else {
                showFeedback('âŒ è«‹æŒ‰ç…§é †åºé»æ“Š', false);
            }
        }

        function handleSimpleClick(point) {
            const step = learningData[currentPhase][currentStepIndex];
            
            // å‰µå»ºé»æ“Šæ•ˆæœ
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.08, 0.15, 32),
                new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true })
            );
            ring.position.copy(point);
            ring.rotation.x = -Math.PI/2;
            scene.add(ring);
            
            gsap.to(ring.scale, { x: 4, y: 4, duration: 1.2 });
            gsap.to(ring.material, {
                opacity: 0,
                duration: 1.2,
                onComplete: () => scene.remove(ring)
            });
            
            showFeedback(`âœ… å®Œæˆ: ${step.text}`, true);
            setTimeout(() => nextStep(), 1500);
        }

        function showFeedback(msg, isSuccess) {
            const el = document.getElementById('feedback-text');
            el.innerText = msg;
            el.style.opacity = 1;
            el.style.background = isSuccess ? 
                "linear-gradient(135deg, rgba(17, 153, 142, 0.95), rgba(56, 239, 125, 0.95))" : 
                "rgba(220, 53, 69, 0.95)";
            
            clearTimeout(window.fbTimer);
            window.fbTimer = setTimeout(() => { 
                el.style.opacity = 0; 
            }, 2000);
        }
        
        function forceComplete() {
            const step = learningData[currentPhase][currentStepIndex];
            console.log('ğŸ”§ å¼·åˆ¶å®Œæˆæ­¥é©Ÿ:', step.id, step.text);
            showFeedback(`âœ… å¼·åˆ¶å®Œæˆ: ${step.text}`, true);
            setTimeout(() => nextStep(), 1000);
        }
        
        function testInteraction() {
            console.log('ğŸ§ª === äº’å‹•æ¸¬è©¦é–‹å§‹ ===');
            
            const step = learningData[currentPhase][currentStepIndex];
            console.log('ç•¶å‰æ­¥é©Ÿ:', step.id, step.text);
            console.log('äº’å‹•æ¨¡å¼:', step.interactionMode);
            
            const meshTargets = targets.filter(t => t.isMesh);
            console.log('äº’å‹•é»æ•¸é‡:', meshTargets.length);
            
            meshTargets.forEach((ball, i) => {
                console.log(`çƒ ${i}:`, {
                    é¡è‰²: '#' + ball.material.color.getHexString(),
                    ä½ç½®: {
                        x: ball.position.x.toFixed(2),
                        y: ball.position.y.toFixed(2),
                        z: ball.position.z.toFixed(2)
                    },
                    å¤§å°: ball.geometry.parameters.radius.toFixed(2)
                });
                
                // è®“çƒé–ƒçˆ
                ball.material.emissive = new THREE.Color(0xff0000);
                setTimeout(() => {
                    ball.material.emissive = new THREE.Color(0x000000);
                }, 500 * (i + 1));
            });
            
            console.log('æ¨¡ç‰¹å…’ä½ç½®:', {
                x: model.position.x.toFixed(2),
                y: model.position.y.toFixed(2),
                z: model.position.z.toFixed(2)
            });
            
            console.log('äº’å‹•é»åç§»:', {
                x: targetOffset.x.toFixed(2),
                y: targetOffset.y.toFixed(2),
                z: targetOffset.z.toFixed(2)
            });
            
            console.log('ğŸ’¡ æç¤ºï¼šçƒé«”æœƒä¾åºé–ƒç´…å…‰ï¼Œç¢ºèªæ˜¯å¦çœ‹å¾—åˆ°');
            console.log('ğŸ§ª === æ¸¬è©¦çµæŸ ===');
            
            showFeedback('æŸ¥çœ‹æ§åˆ¶å°è¨Šæ¯', true);
        }

        function resetCam() { 
            controls.reset();
            camera.position.set(2, 3, 3);
            camera.lookAt(0, 0, 0);
        }
        
        function onWindowResize() {
            if(camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        function animate() {
            if (controls) controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>        }
        .enter-btn:hover { transform: translateY(-5px) scale(1.05); box-shadow: 0 15px 40px rgba(0,0,0,0.4); }

        /* ä»‹é¢å±¤ */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }

        .status-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(255,255,255,0.95); padding: 15px 40px; border-radius: 50px;
            font-weight: bold; color: #333; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: flex; gap: 20px; align-items: center; pointer-events: auto;
        }

        /* å·¦å´é¢æ¿ */
        .control-panel {
            position: absolute; left: 20px; top: 90px; width: 280px;
            background: rgba(255,255,255,0.98); border-radius: 20px; padding: 20px;
            max-height: calc(100vh - 360px); overflow-y: auto; pointer-events: auto;
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
        }
        
        /* å³å´é¢æ¿ */
        .learning-panel {
            position: absolute; right: 20px; top: 90px; width: 360px;
            background: rgba(255,255,255,0.98); border-radius: 20px; padding: 25px;
            pointer-events: auto; box-shadow: 0 8px 30px rgba(0,0,0,0.3);
            max-height: calc(100vh - 110px); overflow-y: auto;
        }

        .phase-btn {
            display: block; width: 100%; padding: 15px; margin-bottom: 10px;
            border: 2px solid #e0e0e0; background: white; border-radius: 12px; 
            cursor: pointer; text-align: left; font-weight: bold; transition: all 0.3s;
            font-size: 14px;
        }
        .phase-btn:hover { 
            background: linear-gradient(90deg, #f0f0f0, #fafafa); 
            transform: translateX(5px); border-color: #667eea;
        }
        .phase-btn.active { 
            background: linear-gradient(135deg, #667eea, #764ba2); 
            color: white; border: none; 
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .step-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-left: 5px solid #667eea;
            padding: 20px; margin-bottom: 20px; border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .step-number { 
            font-size: 16px; color: #667eea; font-weight: bold; 
            margin-bottom: 8px; display: flex; align-items: center; gap: 8px;
        }
        .step-desc { 
            font-size: 20px; font-weight: bold; margin-bottom: 10px; 
            color: #333; line-height: 1.4;
        }
        .step-note { 
            font-size: 14px; color: #555; line-height: 1.6; 
            background: white; padding: 10px; border-radius: 8px;
            margin-top: 10px;
        }
        
        .technique-tag {
            display: inline-block; background: #667eea; color: white;
            padding: 6px 15px; border-radius: 20px; font-size: 13px;
            margin-top: 10px; font-weight: bold;
        }
        
        .interaction-tag {
            display: inline-block; background: #11998e; color: white;
            padding: 6px 15px; border-radius: 20px; font-size: 13px;
            margin-top: 10px; margin-left: 8px; font-weight: bold;
        }

        .progress-bar {
            width: 100%; height: 8px; background: #e0e0e0; 
            border-radius: 10px; overflow: hidden; margin: 15px 0;
        }
        .progress-fill {
            height: 100%; background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.5s ease; border-radius: 10px;
        }

        .nav-btn {
            background: linear-gradient(135deg, #667eea, #764ba2); 
            color: white; border: none; padding: 12px 25px;
            border-radius: 30px; cursor: pointer; font-size: 16px; 
            font-weight: bold; transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        .nav-btn:disabled { 
            background: #ccc; cursor: not-allowed; 
            box-shadow: none; transform: none;
        }

        /* äº’å‹•å¼•å°è»Œè·¡ */
        .guide-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 150;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .guide-arrow.show { opacity: 1; }
        
        /* æ‹–æ›³æç¤º */
        .drag-hint {
            position: absolute;
            background: rgba(102, 126, 234, 0.95);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 160;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .drag-hint.show { opacity: 1; }
        
        /* æŒ‰å£“é€²åº¦åœˆ */
        .press-circle {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            z-index: 150;
        }
        .press-circle.show { opacity: 1; }
        .press-fill {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 4px solid #11998e;
            border-top-color: transparent;
            border-right-color: transparent;
            transform: rotate(0deg);
            transition: transform 0.1s linear;
        }

        /* Debug é¢æ¿ */
        .debug-panel {
            position: absolute; bottom: 20px; left: 20px; 
            background: rgba(0,0,0,0.9); color: white; 
            padding: 15px; border-radius: 12px; font-size: 12px; 
            pointer-events: auto; width: 260px;
            max-height: 280px; overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .debug-section { 
            margin-bottom: 15px; border-bottom: 1px solid #444; 
            padding-bottom: 10px; 
        }
        .debug-title { 
            font-weight: bold; color: #667eea; margin-bottom: 8px; 
            font-size: 13px; 
        }
        .debug-row { 
            margin-bottom: 8px; display: flex; 
            justify-content: space-between; align-items: center; 
        }
        .debug-row label { width: 55px; font-size: 11px; }
        .debug-row input { flex: 1; margin-left: 8px; }
        .debug-row .value { 
            font-size: 10px; color: #aaa; 
            min-width: 40px; text-align: right; 
        }

        .loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; font-weight: bold; 
            text-shadow: 0 2px 8px rgba(0,0,0,0.8);
            pointer-events: none; display: none;
            background: rgba(0,0,0,0.7); padding: 20px 40px;
            border-radius: 15px;
        }
        .loading.show { display: block; }

        .feedback {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85); color: #fff; padding: 20px 40px; 
            border-radius: 40px; font-size: 24px; opacity: 0; 
            pointer-events: none; transition: opacity 0.3s; z-index: 200;
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
            font-weight: bold;
        }
        
        /* äº’å‹•æ¨¡å¼æŒ‡ç¤º */
        .interaction-mode {
            position: absolute; top: 100px; left: 50%; transform: translateX(-50%);
            background: linear-gradient(135deg, #11998e, #38ef7d);
            color: white; padding: 12px 30px; border-radius: 30px;
            font-weight: bold; font-size: 18px;
            box-shadow: 0 6px 20px rgba(17, 153, 142, 0.4);
            pointer-events: none; opacity: 0;
            transition: all 0.3s; z-index: 150;
        }
        .interaction-mode.show { opacity: 1; }
    </style>
</head>
<body>

    <div class="game-container">
        <div id="canvas-container" style="width:100%; height:100%; background:#000;"></div>

        <!-- æ­¡è¿é  -->
        <div class="welcome-screen" id="welcome-screen">
            <div class="welcome-content">
                <h1>ğŸŒ¿ è‰¾æŸåœ‹éš›èŠ³ç™‚å­¸é™¢</h1>
                <h2 style="font-size: 36px; margin-bottom: 15px;">ç‘å…¸å¼è…¿éƒ¨æŒ‰æ‘© VR æ•™å­¸ç³»çµ±</h2>
                <p style="font-size: 20px; line-height: 1.8;">
                    âœ¨ æ··åˆäº’å‹•æ¨¡å¼ - çœŸå¯¦æ‰‹æ³•é«”é©—<br>
                    ğŸ¯ æ‹–æ›³è»Œè·¡ + æŒ‰å£“è¨ˆæ™‚ + é †åºé»æ“Š<br>
                    ğŸ¥½ åŸ¹é¤Šå°ˆæ¥­è‚Œè‚‰è¨˜æ†¶
                </p>
                <button class="enter-btn" onclick="startGame()">ğŸ“ é–‹å§‹äº’å‹•è¨“ç·´</button>
            </div>
        </div>

        <div class="ui-layer" id="ui-layer" style="display:none;">
            <div class="status-bar">
                <span>ğŸ« VR å°ˆæ¥­æ•™å®¤</span>
                <span id="model-status">ğŸ‘¤ è¼‰å…¥ä¸­...</span>
                <span id="progress-status">ğŸ“Š é€²åº¦: 0%</span>
            </div>
            
            <!-- äº’å‹•æ¨¡å¼æç¤º -->
            <div class="interaction-mode" id="interaction-mode">ğŸ® æº–å‚™äº’å‹•</div>

            <!-- æ‹–æ›³æç¤º -->
            <div class="drag-hint" id="drag-hint">ğŸ‘† æŒ‰ä½ä¸¦æ²¿ç®­é ­æ‹–æ›³</div>
            
            <!-- æŒ‰å£“é€²åº¦åœˆ -->
            <div class="press-circle" id="press-circle">
                <div class="press-fill" id="press-fill"></div>
            </div>

            <!-- å·¦å´é¢æ¿ -->
            <div class="control-panel">
                <h3 style="margin-bottom:18px; color:#667eea; font-size:18px;">ğŸ“‹ ç™‚ç¨‹éšæ®µ</h3>
                
                <button class="phase-btn" onclick="setPhase(1)" id="p1">
                    <div style="font-size:16px;">éšæ®µä¸€</div>
                    <div style="font-size:12px; color:#888; margin-top:4px;">æº–å‚™èˆ‡èµ·å§‹å®‰æ’«</div>
                </button>
                
                <button class="phase-btn" onclick="setPhase(2)" id="p2">
                    <div style="font-size:16px;">éšæ®µäºŒ</div>
                    <div style="font-size:12px; color:#888; margin-top:4px;">å·¦è…¿æŒ‰æ‘©æ“ä½œ</div>
                </button>
                
                <button class="phase-btn" onclick="setPhase(3)" id="p3">
                    <div style="font-size:16px;">éšæ®µä¸‰</div>
                    <div style="font-size:12px; color:#888; margin-top:4px;">å³è…¿æŒ‰æ‘©æ“ä½œ</div>
                </button>
                
                <button class="phase-btn" onclick="setPhase(4)" id="p4">
                    <div style="font-size:16px;">éšæ®µå››</div>
                    <div style="font-size:12px; color:#888; margin-top:4px;">çµå°¾èˆ‡å®‰æ’«</div>
                </button>
                
                <div class="progress-bar" style="margin-top:20px;">
                    <div class="progress-fill" id="progress-fill" style="width:0%;"></div>
                </div>
                <div style="text-align:center; font-size:12px; color:#888; margin-top:8px;">
                    æ•´é«”å®Œæˆåº¦: <span id="completion-percent">0%</span>
                </div>
                
                <hr style="margin: 20px 0; border:0; border-top:2px solid #e0e0e0;">
                
                <div style="font-size:13px; color:#555; font-weight:bold; margin-bottom:8px;">ğŸ”„ åˆ‡æ›æ¨¡ç‰¹å…’</div>
                <div style="display:flex; gap:8px;">
                    <button class="phase-btn" style="padding:10px; text-align:center; flex:1;" onclick="loadModel('male')">
                        ğŸ‘¨<br><span style="font-size:11px;">ç”·æ€§</span>
                    </button>
                    <button class="phase-btn" style="padding:10px; text-align:center; flex:1;" onclick="loadModel('female')">
                        ğŸ‘©<br><span style="font-size:11px;">å¥³æ€§</span>
                    </button>
                </div>
            </div>

            <!-- å³å´é¢æ¿ -->
            <div class="learning-panel">
                <h3 style="margin-bottom:18px; color:#667eea; font-size:18px;">ğŸ“– æ“ä½œæŒ‡å¼•</h3>
                
                <div id="step-display">
                    <div class="step-card">
                        <div class="step-number" id="step-id">
                            <span>ğŸ¯</span>
                            <span>è«‹é¸æ“‡ç™‚ç¨‹éšæ®µ</span>
                        </div>
                        <div class="step-desc" id="step-text">é»é¸å·¦å´éšæ®µé–‹å§‹å°ˆæ¥­è¨“ç·´</div>
                        <div class="step-note" id="step-note">
                            ğŸ’¡ æç¤ºï¼šæ¯å€‹æ­¥é©Ÿéƒ½æœ‰å°ˆå±¬çš„äº’å‹•æ–¹å¼
                        </div>
                        <div id="technique-display"></div>
                    </div>
                </div>

                <div style="display:flex; gap:12px; margin-top:20px;">
                    <button class="nav-btn" style="background:#888; flex:1;" onclick="prevStep()">
                        â¬… ä¸Šä¸€æ­¥
                    </button>
                    <button class="nav-btn" style="flex:1;" onclick="nextStep()">
                        ä¸‹ä¸€æ­¥ â¡
                    </button>
                </div>
                
                <div style="display:flex; gap:12px; margin-top:12px;">
                    <button id="lock-btn-main" class="nav-btn" style="background:#ff6b6b; flex:1; font-size:16px;" onclick="toggleCameraLock()">
                        ğŸ”’ é–å®šç•«é¢
                    </button>
                </div>
                
                <div style="margin-top:20px; padding:15px; background:#f8f9fa; border-radius:10px;">
                    <div style="font-size:13px; color:#555; margin-bottom:8px; font-weight:bold;">
                        ğŸ® äº’å‹•æ¨¡å¼èªªæ˜
                    </div>
                    <div style="font-size:12px; color:#666; line-height:1.8;">
                        <strong>ğŸ–±ï¸ æ‹–æ›³è»Œè·¡</strong>ï¼šé•·æ¨å‹•ä½œ<br>
                        <strong>â±ï¸ æŒ‰å£“è¨ˆæ™‚</strong>ï¼šå®šé»æŒ‰æ‘©<br>
                        <strong>ğŸ‘† é †åºé»æ“Š</strong>ï¼šåˆ†æ®µæ“ä½œ<br>
                        <div style="margin-top:8px; padding:8px; background:#fff3cd; border-radius:6px; border-left:3px solid #ffc107;">
                            <strong>âš ï¸ äº’å‹•å‰å¿…åš</strong>ï¼šå…ˆé»ã€ŒğŸ”’ é–å®šç•«é¢ã€
                        </div>
                    </div>
                </div>
            </div>

            <!-- Debug é¢æ¿ -->
            <div class="debug-panel">
                <div class="debug-section">
                    <div class="debug-title">ğŸ”§ æ¨¡ç‰¹å…’ä½ç½®å¾®èª¿</div>
                    <div class="debug-row">
                        <label>å‰å¾Œ X</label>
                        <input type="range" id="range-x" min="-3" max="3" step="0.05" value="-1.2" oninput="updatePos()">
                        <span class="value" id="val-x">-1.2</span>
                    </div>
                    <div class="debug-row">
                        <label>é«˜åº¦ Y</label>
                        <input type="range" id="range-y" min="0" max="4" step="0.05" value="2.35" oninput="updatePos()">
                        <span class="value" id="val-y">2.35</span>
                    </div>
                    <div class="debug-row">
                        <label>å·¦å³ Z</label>
                        <input type="range" id="range-z" min="-3" max="3" step="0.05" value="0" oninput="updatePos()">
                        <span class="value" id="val-z">0.0</span>
                    </div>
                    <div class="debug-row">
                        <label>å¤§å°</label>
                        <input type="range" id="range-scale" min="0.5" max="2" step="0.1" value="1.0" oninput="updatePos()">
                        <span class="value" id="val-scale">1.0</span>
                    </div>
                </div>

                <div style="text-align: center; margin-top:10px;">
                    <button style="padding:8px 16px; cursor:pointer; border-radius:8px; background:#667eea; color:white; border:none; font-weight:bold; margin:4px;" onclick="resetCam()">
                        ğŸ”„ é‡ç½®è¦–è§’
                    </button>
                </div>
            </div>

            <div class="loading" id="loading-text">â³ è¼‰å…¥æ•™å­¸è³‡æºä¸­...</div>
            <div class="feedback" id="feedback-text"></div>
        </div>
    </div>

    <script>
        const BASE_URL = "https://gp01002.github.io/TMS/";

        // æ··åˆäº’å‹•æ¨¡å¼å­¸ç¿’è³‡æ–™åº«
        const learningData = {
            1: [
                { 
                    id: "1.1", 
                    text: "åœ¨æ¯›å·¾ä¸Šä¿¯é †è‡³å¤§è…¿", 
                    note: "è¼•æŸ”åœ°å°‡é›™æ‰‹æ”¾åœ¨æ¯›å·¾ä¸Šï¼Œå¾è†è“‹è™•å‘ä¸Šä¿¯é †è‡³å¤§è…¿ï¼Œå»ºç«‹åˆæ­¥æ¥è§¸èˆ‡ä¿¡ä»»æ„Ÿã€‚æ‰‹æ³•è¦è¼•æŸ”ã€é€£è²«ï¼Œè®“å®¢æˆ¶æ„Ÿå—åˆ°æº«æš–ã€‚", 
                    target: 'thighs', 
                    technique: "ä¿¯é †æ³• Effleurage",
                    interactionMode: "drag", // æ‹–æ›³è»Œè·¡
                    dragPath: [{x: 0.5, y: -0.25, z: 0}, {x: 0.2, y: -0.25, z: 0}], // å¾è†è“‹åˆ°å¤§è…¿
                    duration: 3 // å»ºè­°3ç§’å®Œæˆ
                },
                { 
                    id: "1.2", 
                    text: "ç”±å…©å´æ»‘ä¸‹è‡³è…³åº•", 
                    note: "é›™æ‰‹æ²¿è‘—è…¿éƒ¨å…©å´ï¼Œä»¥è¼•æŸ”æµæš¢çš„å‹•ä½œå‘ä¸‹æ»‘è‡³è…³åº•ï¼Œä¿æŒé€£çºŒæ¥è§¸ã€‚", 
                    target: 'feet', 
                    technique: "é•·æ¨æ³•",
                    interactionMode: "drag",
                    dragPath: [{x: 0.2, y: -0.25, z: 0}, {x: 1.0, y: -0.35, z: 0}], // å¾å¤§è…¿åˆ°è…³åº•
                    duration: 3
                },
                { 
                    id: "1.3", 
                    text: "å°‡æ¯›å·¾æ²åœ¨é›™è…¿ä¹‹é–“", 
                    note: "å°å¿ƒåœ°å°‡æ¯›å·¾æ²èµ·ä¸¦æ”¾ç½®åœ¨é›™è…¿ä¹‹é–“ï¼Œç¢ºä¿è¦†è“‹éš±ç§éƒ¨ä½ã€‚", 
                    target: 'knees', 
                    technique: "æ¯›å·¾è™•ç†",
                    interactionMode: "click", // å–®é»é»æ“Š
                    clickCount: 1
                },
                { 
                    id: "1.4", 
                    text: "é›™è…¿ç”±é˜¿åŸºé‡Œæ–¯è…±ä¸Šæ¨", 
                    note: "å¾è…³å¾Œè·Ÿçš„é˜¿åŸºé‡Œæ–¯è…±é–‹å§‹ï¼Œé›™æ‰‹åŒæ­¥å‘ä¸Šæ¨æ’«è‡³å¤§è…¿ã€‚", 
                    target: 'legs', 
                    technique: "é›™æ‰‹åŒæ­¥é•·æ¨",
                    interactionMode: "sequence", // é †åºé»æ“Š
                    sequence: ['feet', 'calves', 'thighs'], // è…³â†’å°è…¿â†’å¤§è…¿
                    sequenceCount: 3
                },
                { 
                    id: "1.5", 
                    text: "å°‡å³è…³è¦†è“‹", 
                    note: "ç”¨å¦ä¸€æ¢æ¯›å·¾æˆ–å¸ƒå·¾è¼•æŸ”åœ°è¦†è“‹å³è…¿ï¼Œç¢ºä¿ä¿æš–ã€‚", 
                    target: 'right_leg', 
                    technique: "ä¿æš–è™•ç†",
                    interactionMode: "click",
                    clickCount: 1
                },
                { 
                    id: "1.6", 
                    text: "ä¸Šæ²¹", 
                    note: "å–é©é‡æŒ‰æ‘©æ²¹æ–¼é›™æ‰‹æŒå¿ƒï¼Œæ“ç†±å¾Œæº–å‚™æ–½ä½œã€‚", 
                    target: 'hands', 
                    technique: "æ²¹å“æº–å‚™",
                    interactionMode: "press", // æŒ‰å£“è¨ˆæ™‚
                    pressDuration: 2 // æŒ‰å£“2ç§’
                },
                { 
                    id: "1.7", 
                    text: "å¤§å®‰æ’«", 
                    note: "é›™æ‰‹æ”¾åœ¨è…³åº•ï¼Œåœç•™ç‰‡åˆ»ï¼Œæ·±å‘¼å¸ï¼Œå»ºç«‹èˆ‡å®¢æˆ¶çš„èƒ½é‡é€£çµã€‚", 
                    target: 'feet', 
                    technique: "å®‰æ’«æ¥è§¸æ³•",
                    interactionMode: "press",
                    pressDuration: 3 // æŒ‰å£“3ç§’
                }
            ]
        };

        let scene, camera, renderer, controls, model;
        let currentPhase = 1;
        let currentStepIndex = 0;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let targets = [];
        let isDragging = false;
        let dragStartTime = 0;
        let dragPath = [];
        let currentInteractionMode = null;
        let pressStartTime = 0;
        let isPressing = false;
        let sequenceProgress = 0;
        let targetOffset = {x: 0, y: 0, z: 0}; // å›ºå®šåç§»é‡ï¼Œä¸å†æ‰‹å‹•èª¿æ•´
        let cameraLocked = false; // ç•«é¢é–å®šç‹€æ…‹

        function startGame() {
            document.getElementById('welcome-screen').classList.add('hidden');
            document.getElementById('ui-layer').style.display = 'block';
            setTimeout(initThreeJS, 100);
        }
        
        function toggleCameraLock() {
            cameraLocked = !cameraLocked;
            controls.enabled = !cameraLocked;
            
            const btn = document.getElementById('lock-btn');
            const btnMain = document.getElementById('lock-btn-main');
            
            if (cameraLocked) {
                // é–å®šç‹€æ…‹
                if (btn) {
                    btn.innerText = 'ğŸ”“ è§£é–ç•«é¢';
                    btn.style.background = '#51cf66';
                }
                if (btnMain) {
                    btnMain.innerHTML = 'ğŸ”“ è§£é–ç•«é¢';
                    btnMain.style.background = '#51cf66';
                }
                showFeedback('âœ… ç•«é¢å·²é–å®šï¼Œå¯ä»¥äº’å‹•äº†', true);
                console.log('ğŸ”’ ç•«é¢å·²é–å®š - ç¾åœ¨å¯ä»¥æ‹–æ›³çƒé«”äº†');
            } else {
                // è§£é–ç‹€æ…‹
                if (btn) {
                    btn.innerText = 'ğŸ”’ é–å®šç•«é¢';
                    btn.style.background = '#ff6b6b';
                }
                if (btnMain) {
                    btnMain.innerHTML = 'ğŸ”’ é–å®šç•«é¢';
                    btnMain.style.background = '#ff6b6b';
                }
                showFeedback('âœ… ç•«é¢å·²è§£é–ï¼Œå¯ä»¥èª¿æ•´è¦–è§’', true);
                console.log('ğŸ”“ ç•«é¢å·²è§£é– - ç¾åœ¨å¯ä»¥æ—‹è½‰è¦–è§’äº†');
            }
        }

        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            
            const grid = new THREE.GridHelper(20, 20, 0x888888, 0x444444);
            scene.add(grid);

            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(2, 3, 3);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 2;
            controls.maxDistance = 15;

            const ambient = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-5, 5, -5);
            scene.add(fillLight);

            // å„ªåŒ– raycaster è¨­å®š
            raycaster.params.Points.threshold = 0.3;
            raycaster.params.Line.threshold = 0.3;

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.style.cursor = 'default';
            renderer.setAnimationLoop(animate);

            loadRoom();
            loadModel('male');
            setPhase(1);
        }

        function loadRoom() {
            const loader = new THREE.GLTFLoader();
            loader.load(BASE_URL + 'A01.glb', (gltf) => {
                const room = gltf.scene;
                room.scale.set(20, 20, 20);
                scene.add(room);
            });
        }

        function loadModel(type) {
            if (model) scene.remove(model);
            
            document.getElementById('loading-text').classList.add('show');
            document.getElementById('model-status').innerText = 'ğŸ‘¤ è¼‰å…¥æ¨¡ç‰¹å…’ä¸­...';
            
            const url = BASE_URL + (type === 'male' ? 'B01.glb' : 'B02.glb');

            const loader = new THREE.GLTFLoader();
            loader.load(url, (gltf) => {
                model = gltf.scene;
                
                updatePos(); 
                model.rotation.set(-Math.PI/2, 0, Math.PI/2);
                
                scene.add(model);
                
                document.getElementById('model-status').innerText = 'âœ… æ¨¡ç‰¹å…’å·²å°±ä½';
                document.getElementById('model-status').style.background = '#d4edda';
                document.getElementById('model-status').style.color = '#155724';
                
                updateTargets();
                document.getElementById('loading-text').classList.remove('show');
            });
        }

        function updatePos() {
            if (model) {
                const x = parseFloat(document.getElementById('range-x').value);
                const y = parseFloat(document.getElementById('range-y').value);
                const z = parseFloat(document.getElementById('range-z').value);
                const scale = parseFloat(document.getElementById('range-scale').value);
                
                model.position.set(x, y, z);
                model.scale.set(scale, scale, scale);
                
                document.getElementById('val-x').innerText = x.toFixed(2);
                document.getElementById('val-y').innerText = y.toFixed(2);
                document.getElementById('val-z').innerText = z.toFixed(2);
                document.getElementById('val-scale').innerText = scale.toFixed(1);
                
                updateTargets();
            }
        }

        function updateTargetOffset() {
            targetOffset.x = parseFloat(document.getElementById('target-x').value);
            targetOffset.y = parseFloat(document.getElementById('target-y').value);
            targetOffset.z = parseFloat(document.getElementById('target-z').value);
            
            document.getElementById('val-tx').innerText = targetOffset.x.toFixed(2);
            document.getElementById('val-ty').innerText = targetOffset.y.toFixed(2);
            document.getElementById('val-tz').innerText = targetOffset.z.toFixed(2);
            
            updateTargets();
        }

        function updateTargets() {
            if (!model) return;
            
            if (targets.length > 0) {
                targets.forEach(t => scene.remove(t));
            }
            targets = [];

            const currentStep = learningData[currentPhase]?.[currentStepIndex];
            if (!currentStep) return;
            
            currentInteractionMode = currentStep.interactionMode;
            
            // é¡¯ç¤ºäº’å‹•æ¨¡å¼
            showInteractionMode(currentStep.interactionMode);
            
            // æ ¹æ“šäº’å‹•æ¨¡å¼å‰µå»ºä¸åŒçš„æ¨™è¨˜
            createInteractionTargets(currentStep);
        }

        function createInteractionTargets(step) {
            const basePos = model.position;
            
            if (step.interactionMode === 'drag') {
                // æ‹–æ›³æ¨¡å¼ï¼šå‰µå»ºèµ·é»å’Œçµ‚é»
                const path = step.dragPath;
                path.forEach((p, i) => {
                    const ball = createTargetBall(
                        basePos.x + p.x + targetOffset.x,
                        basePos.y + p.y + targetOffset.y,
                        basePos.z + p.z + targetOffset.z,
                        i === 0 ? 0x00ff00 : 0xffd700 // èµ·é»ç¶ è‰²ï¼Œçµ‚é»é‡‘è‰²
                    );
                    scene.add(ball);
                    targets.push(ball);
                });
                
                // å‰µå»ºè»Œè·¡ç·š
                createPathLine(path, basePos);
                
            } else if (step.interactionMode === 'press') {
                // æŒ‰å£“æ¨¡å¼ï¼šå‰µå»ºå–®å€‹å¤§çƒ
                const pos = getTargetPosition(step.target);
                const ball = createTargetBall(
                    basePos.x + pos.x + targetOffset.x,
                    basePos.y + pos.y + targetOffset.y,
                    basePos.z + pos.z + targetOffset.z,
                    0x11998e,
                    0.22  // æ›´å¤§çš„çƒ
                );
                scene.add(ball);
                targets.push(ball);
                
            } else if (step.interactionMode === 'sequence') {
                // é †åºæ¨¡å¼ï¼šå‰µå»ºå¤šå€‹ç·¨è™Ÿçƒ
                step.sequence.forEach((targetType, i) => {
                    const pos = getSequencePosition(targetType);
                    const ball = createTargetBall(
                        basePos.x + pos.x + targetOffset.x,
                        basePos.y + pos.y + targetOffset.y,
                        basePos.z + pos.z + targetOffset.z,
                        i === sequenceProgress ? 0x00ff00 : 0x888888
                    );
                    scene.add(ball);
                    targets.push(ball);
                });
                
            } else {
                // é»æ“Šæ¨¡å¼ï¼šå‰µå»ºå–®å€‹çƒ
                const pos = getTargetPosition(step.target);
                const ball = createTargetBall(
                    basePos.x + pos.x + targetOffset.x,
                    basePos.y + pos.y + targetOffset.y,
                    basePos.z + pos.z + targetOffset.z,
                    0x00ff00
                );
                scene.add(ball);
                targets.push(ball);
            }
        }

        function createTargetBall(x, y, z, color, size = 0.18) {
            const geo = new THREE.SphereGeometry(size, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.7 
            });
            const ball = new THREE.Mesh(geo, mat);
            ball.position.set(x, y, z);
            
            gsap.to(ball.material, { 
                opacity: 0.3, 
                duration: 0.8, 
                yoyo: true, 
                repeat: -1 
            });
            gsap.to(ball.scale, {
                x: 1.4, y: 1.4, z: 1.4,
                duration: 0.8,
                yoyo: true,
                repeat: -1
            });
            
            return ball;
        }

        function createPathLine(path, basePos) {
            const points = path.map(p => new THREE.Vector3(
                basePos.x + p.x + targetOffset.x,
                basePos.y + p.y + targetOffset.y,
                basePos.z + p.z + targetOffset.z
            ));
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineDashedMaterial({
                color: 0xffff00,
                linewidth: 3,
                scale: 1,
                dashSize: 0.15,
                gapSize: 0.08,
            });
            
            const line = new THREE.Line(geometry, material);
            line.computeLineDistances();
            scene.add(line);
            targets.push(line);
        }

        function getTargetPosition(targetType) {
            const positions = {
                'thighs': {x: 0.2, y: -0.25, z: 0},       // å¤§è…¿
                'feet': {x: 1.0, y: -0.35, z: 0},         // è…³åº•  
                'knees': {x: 0.5, y: -0.25, z: 0},        // è†è“‹
                'legs': {x: 0.4, y: -0.25, z: 0},         // è…¿éƒ¨
                'right_leg': {x: 0.4, y: -0.25, z: -0.25}, // å³è…¿
                'hands': {x: 0.5, y: 0.1, z: 0}           // æ‰‹éƒ¨ï¼ˆèª¿é«˜ä¸€é»ï¼‰
            };
            return positions[targetType] || {x: 0.5, y: -0.25, z: 0};
        }

        function getSequencePosition(targetType) {
            const positions = {
                'feet': {x: 1.0, y: -0.35, z: 0},         // è…³åº•ï¼ˆé˜¿åŸºé‡Œæ–¯è…±ï¼‰
                'calves': {x: 0.65, y: -0.25, z: 0},      // å°è…¿
                'thighs': {x: 0.2, y: -0.25, z: 0}        // å¤§è…¿
            };
            return positions[targetType] || {x: 0.5, y: -0.25, z: 0};
        }

        function showInteractionMode(mode) {
            const modeEl = document.getElementById('interaction-mode');
            const modeText = {
                'drag': 'ğŸ–±ï¸ æ‹–æ›³è»Œè·¡æ¨¡å¼',
                'press': 'â±ï¸ æŒ‰å£“è¨ˆæ™‚æ¨¡å¼',
                'sequence': 'ğŸ‘† é †åºé»æ“Šæ¨¡å¼',
                'click': 'ğŸ‘† é»æ“Šäº’å‹•æ¨¡å¼'
            };
            
            modeEl.innerText = modeText[mode] || 'ğŸ® äº’å‹•æ¨¡å¼';
            modeEl.classList.add('show');
            
            setTimeout(() => {
                modeEl.classList.remove('show');
            }, 3000);
        }

        function setPhase(p) {
            currentPhase = p;
            currentStepIndex = 0;
            sequenceProgress = 0;
            
            document.querySelectorAll('.phase-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('p' + p).classList.add('active');
            
            updateStepDisplay();
        }

        function nextStep() {
            const currentPhaseSteps = learningData[currentPhase];
            if (currentStepIndex < currentPhaseSteps.length - 1) {
                currentStepIndex++;
                sequenceProgress = 0;
                updateStepDisplay();
            } else {
                showFeedback(`éšæ®µ${currentPhase}å®Œæˆï¼`, true);
            }
        }

        function prevStep() {
            if (currentStepIndex > 0) {
                currentStepIndex--;
                sequenceProgress = 0;
                updateStepDisplay();
            }
        }

        function updateStepDisplay() {
            const step = learningData[currentPhase][currentStepIndex];
            if (!step) return;
            
            document.getElementById('step-id').innerHTML = `
                <span>ğŸ¯</span>
                <span>STEP ${step.id}</span>
            `;
            document.getElementById('step-text').innerText = step.text;
            document.getElementById('step-note').innerText = `ğŸ’¡ ${step.note}`;
            
            const modeIcons = {
                'drag': 'ğŸ–±ï¸ æ‹–æ›³è»Œè·¡',
                'press': 'â±ï¸ æŒ‰å£“è¨ˆæ™‚',
                'sequence': 'ğŸ‘† é †åºé»æ“Š',
                'click': 'ğŸ‘† é»æ“Šäº’å‹•'
            };
            
            document.getElementById('technique-display').innerHTML = `
                <div class="technique-tag">âœ¨ ${step.technique}</div>
                <div class="interaction-tag">${modeIcons[step.interactionMode]}</div>
            `;
            
            updateTargets();
        }

        function onMouseDown(e) {
            const step = learningData[currentPhase][currentStepIndex];
            if (!step) return;
            
            // è¨ˆç®—æ»‘é¼ ä½ç½®
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const meshTargets = targets.filter(t => t.isMesh);
            const intersects = raycaster.intersectObjects(meshTargets, true);
            
            console.log('ğŸ–±ï¸ é»æ“Šæª¢æ¸¬:', {
                'ç•«é¢é–å®š': cameraLocked ? 'âœ… æ˜¯' : 'âŒ å¦',
                'æ»‘é¼ ä½ç½®': {x: mouse.x.toFixed(2), y: mouse.y.toFixed(2)},
                'äº’å‹•æ¨¡å¼': step.interactionMode,
                'äº’å‹•é»æ•¸é‡': meshTargets.length,
                'äº’å‹•é»ä½ç½®': meshTargets.map(m => ({
                    x: m.position.x.toFixed(2),
                    y: m.position.y.toFixed(2),
                    z: m.position.z.toFixed(2)
                })),
                'é»æ“Šåˆ°': intersects.length > 0 ? 'âœ… æœ‰' : 'âŒ ç„¡'
            });
            
            // æª¢æŸ¥ç•«é¢æ˜¯å¦é–å®š
            if (!cameraLocked) {
                console.log('ğŸ’¡ æç¤ºï¼šè«‹å…ˆé»æ“Šã€ŒğŸ”’ é–å®šç•«é¢ã€æŒ‰éˆ•ï¼Œæ‰èƒ½é€²è¡Œäº’å‹•');
                showFeedback('ğŸ’¡ è«‹å…ˆé–å®šç•«é¢', false);
                return;
            }
            
            // å¦‚æœç›´æ¥é»æ“Šæ²’ä¸­ï¼Œæª¢æŸ¥è·é›¢æœ€è¿‘çš„çƒ
            let clickedBall = null;
            if (intersects.length > 0) {
                clickedBall = intersects[0].object;
                console.log('âœ… ç›´æ¥é»æ“ŠæˆåŠŸï¼');
            } else {
                // å˜—è©¦æ‰¾æœ€è¿‘çš„çƒï¼ˆå®¹éŒ¯æ©Ÿåˆ¶ï¼‰
                let minDistance = Infinity;
                const mouseWorldPos = new THREE.Vector3(mouse.x, mouse.y, 0).unproject(camera);
                
                meshTargets.forEach(ball => {
                    const screenPos = ball.position.clone().project(camera);
                    const distance = Math.sqrt(
                        Math.pow(screenPos.x - mouse.x, 2) + 
                        Math.pow(screenPos.y - mouse.y, 2)
                    );
                    
                    if (distance < minDistance && distance < 0.2) { // å®¹éŒ¯ç¯„åœ
                        minDistance = distance;
                        clickedBall = ball;
                    }
                });
                
                if (clickedBall) {
                    console.log('âœ… è¿‘ä¼¼é»æ“ŠæˆåŠŸï¼è·é›¢:', minDistance.toFixed(3));
                } else {
                    console.log('âŒ é»æ“Šä½ç½®é›¢çƒå¤ªé ï¼Œè«‹é»æ“Šçƒé«”ä¸­å¿ƒ');
                }
            }
            
            if (clickedBall) {
                // è¦–è¦ºåé¥‹
                clickedBall.material.emissive = new THREE.Color(0xffff00);
                setTimeout(() => {
                    if (clickedBall.material) {
                        clickedBall.material.emissive = new THREE.Color(0x000000);
                    }
                }, 200);
                
                if (step.interactionMode === 'drag') {
                    isDragging = true;
                    dragStartTime = Date.now();
                    dragPath = [clickedBall.position.clone()];
                    document.getElementById('drag-hint').classList.add('show');
                    console.log('ğŸ–±ï¸ é–‹å§‹æ‹–æ›³æ¨¡å¼');
                    showFeedback('é–‹å§‹æ‹–æ›³ï¼', true);
                    
                } else if (step.interactionMode === 'press') {
                    isPressing = true;
                    pressStartTime = Date.now();
                    
                    // é¡¯ç¤ºæŒ‰å£“åœˆåœ¨æ»‘é¼ ä½ç½®
                    const circle = document.getElementById('press-circle');
                    circle.style.left = e.clientX - 40 + 'px';
                    circle.style.top = e.clientY - 40 + 'px';
                    circle.classList.add('show');
                    updatePressCircle();
                    console.log('â±ï¸ é–‹å§‹æŒ‰å£“æ¨¡å¼ï¼Œéœ€è¦æŒ‰ä½', step.pressDuration, 'ç§’');
                    showFeedback(`æŒ‰ä½ ${step.pressDuration} ç§’`, true);
                    
                } else if (step.interactionMode === 'sequence') {
                    console.log('ğŸ‘† é †åºé»æ“Šæ¨¡å¼');
                    handleSequenceClick(clickedBall);
                    
                } else if (step.interactionMode === 'click') {
                    console.log('ğŸ‘† ç°¡å–®é»æ“Šæ¨¡å¼');
                    handleSimpleClick(clickedBall.position);
                }
            } else {
                console.log('âŒ æ²’æœ‰é»åˆ°äº’å‹•é»');
                console.log('ğŸ’¡ æç¤ºï¼šè«‹ç¢ºä¿é»æ“Šç¶ è‰²/é‡‘è‰²/é’ç¶ è‰²çƒé«”');
                console.log('ğŸ’¡ æˆ–ä½¿ç”¨ã€Œå¼·åˆ¶å®Œæˆæ­¤æ­¥é©Ÿã€æŒ‰éˆ•');
                showFeedback('è«‹é»æ“Šå½©è‰²çƒé«”', false);
            }
        }

        function onMouseMove(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            
            // æª¢æ¸¬æ˜¯å¦æ‡¸åœåœ¨äº’å‹•é»ä¸Š
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(targets.filter(t => t.isMesh));
            
            if (intersects.length > 0) {
                renderer.domElement.style.cursor = 'pointer';
                // è®“æ‡¸åœçš„çƒè®Šäº®
                intersects[0].object.material.opacity = 0.9;
            } else {
                renderer.domElement.style.cursor = 'default';
                // æ¢å¾©æ‰€æœ‰çƒçš„é€æ˜åº¦
                targets.forEach(t => {
                    if (t.isMesh && t.material.opacity > 0.7) {
                        t.material.opacity = 0.7;
                    }
                });
            }
            
            if (isDragging) {
                const modelIntersects = raycaster.intersectObjects([model], true);
                if (modelIntersects.length > 0) {
                    dragPath.push(modelIntersects[0].point.clone());
                }
            }
        }

        function onMouseUp(e) {
            const step = learningData[currentPhase][currentStepIndex];
            
            if (isDragging) {
                isDragging = false;
                document.getElementById('drag-hint').classList.remove('show');
                
                const dragDuration = (Date.now() - dragStartTime) / 1000;
                const success = validateDrag(dragPath, step.dragPath, dragDuration, step.duration);
                
                if (success) {
                    playDragEffect(dragPath);
                    showFeedback(`âœ… å®Œæˆ: ${step.text}`, true);
                    setTimeout(() => nextStep(), 1500);
                } else {
                    showFeedback('âŒ è«‹æ²¿è‘—è»Œè·¡æ‹–æ›³', false);
                }
                
                dragPath = [];
            }
            
            if (isPressing) {
                isPressing = false;
                document.getElementById('press-circle').classList.remove('show');
                
                const pressDuration = (Date.now() - pressStartTime) / 1000;
                if (pressDuration >= step.pressDuration) {
                    showFeedback(`âœ… å®Œæˆ: ${step.text}`, true);
                    setTimeout(() => nextStep(), 1500);
                } else {
                    showFeedback(`âŒ è«‹æŒ‰å£“ ${step.pressDuration} ç§’`, false);
                }
            }
        }

        function validateDrag(actualPath, expectedPath, actualDuration, expectedDuration) {
            // ç°¡åŒ–é©—è­‰ï¼šæª¢æŸ¥æ˜¯å¦æœ‰è¶³å¤ çš„é»ä¸”æ™‚é–“åˆç†
            return actualPath.length > 5 && 
                   actualDuration >= expectedDuration * 0.7 && 
                   actualDuration <= expectedDuration * 1.5;
        }

        function playDragEffect(path) {
            path.forEach((point, i) => {
                setTimeout(() => {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true })
                    );
                    particle.position.copy(point);
                    scene.add(particle);
                    
                    gsap.to(particle.material, {
                        opacity: 0,
                        duration: 0.5,
                        onComplete: () => scene.remove(particle)
                    });
                }, i * 20);
            });
        }

        function updatePressCircle() {
            if (!isPressing) return;
            
            const step = learningData[currentPhase][currentStepIndex];
            const elapsed = (Date.now() - pressStartTime) / 1000;
            const progress = Math.min(elapsed / step.pressDuration, 1);
            
            document.getElementById('press-fill').style.transform = `rotate(${progress * 360}deg)`;
            
            if (progress < 1) {
                requestAnimationFrame(updatePressCircle);
            }
        }

        function handleSequenceClick(clickedObject) {
            const step = learningData[currentPhase][currentStepIndex];
            const clickedIndex = targets.filter(t => t.isMesh).indexOf(clickedObject);
            
            if (clickedIndex === sequenceProgress) {
                // æ­£ç¢ºé †åº
                sequenceProgress++;
                
                if (sequenceProgress >= step.sequenceCount) {
                    // å®Œæˆæ‰€æœ‰é †åº
                    showFeedback(`âœ… å®Œæˆ: ${step.text}`, true);
                    setTimeout(() => {
                        sequenceProgress = 0;
                        nextStep();
                    }, 1500);
                } else {
                    // æ›´æ–°é¡¯ç¤ºä¸‹ä¸€å€‹
                    updateTargets();
                    showFeedback(`âœ… æ­¥é©Ÿ ${sequenceProgress}/${step.sequenceCount}`, true);
                }
            } else {
                showFeedback('âŒ è«‹æŒ‰ç…§é †åºé»æ“Š', false);
            }
        }

        function handleSimpleClick(point) {
            const step = learningData[currentPhase][currentStepIndex];
            
            // å‰µå»ºé»æ“Šæ•ˆæœ
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.08, 0.15, 32),
                new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true })
            );
            ring.position.copy(point);
            ring.rotation.x = -Math.PI/2;
            scene.add(ring);
            
            gsap.to(ring.scale, { x: 4, y: 4, duration: 1.2 });
            gsap.to(ring.material, {
                opacity: 0,
                duration: 1.2,
                onComplete: () => scene.remove(ring)
            });
            
            showFeedback(`âœ… å®Œæˆ: ${step.text}`, true);
            setTimeout(() => nextStep(), 1500);
        }

        function showFeedback(msg, isSuccess) {
            const el = document.getElementById('feedback-text');
            el.innerText = msg;
            el.style.opacity = 1;
            el.style.background = isSuccess ? 
                "linear-gradient(135deg, rgba(17, 153, 142, 0.95), rgba(56, 239, 125, 0.95))" : 
                "rgba(220, 53, 69, 0.95)";
            
            clearTimeout(window.fbTimer);
            window.fbTimer = setTimeout(() => { 
                el.style.opacity = 0; 
            }, 2000);
        }
        
        function forceComplete() {
            const step = learningData[currentPhase][currentStepIndex];
            console.log('ğŸ”§ å¼·åˆ¶å®Œæˆæ­¥é©Ÿ:', step.id, step.text);
            showFeedback(`âœ… å¼·åˆ¶å®Œæˆ: ${step.text}`, true);
            setTimeout(() => nextStep(), 1000);
        }
        
        function testInteraction() {
            console.log('ğŸ§ª === äº’å‹•æ¸¬è©¦é–‹å§‹ ===');
            
            const step = learningData[currentPhase][currentStepIndex];
            console.log('ç•¶å‰æ­¥é©Ÿ:', step.id, step.text);
            console.log('äº’å‹•æ¨¡å¼:', step.interactionMode);
            
            const meshTargets = targets.filter(t => t.isMesh);
            console.log('äº’å‹•é»æ•¸é‡:', meshTargets.length);
            
            meshTargets.forEach((ball, i) => {
                console.log(`çƒ ${i}:`, {
                    é¡è‰²: '#' + ball.material.color.getHexString(),
                    ä½ç½®: {
                        x: ball.position.x.toFixed(2),
                        y: ball.position.y.toFixed(2),
                        z: ball.position.z.toFixed(2)
                    },
                    å¤§å°: ball.geometry.parameters.radius.toFixed(2)
                });
                
                // è®“çƒé–ƒçˆ
                ball.material.emissive = new THREE.Color(0xff0000);
                setTimeout(() => {
                    ball.material.emissive = new THREE.Color(0x000000);
                }, 500 * (i + 1));
            });
            
            console.log('æ¨¡ç‰¹å…’ä½ç½®:', {
                x: model.position.x.toFixed(2),
                y: model.position.y.toFixed(2),
                z: model.position.z.toFixed(2)
            });
            
            console.log('äº’å‹•é»åç§»:', {
                x: targetOffset.x.toFixed(2),
                y: targetOffset.y.toFixed(2),
                z: targetOffset.z.toFixed(2)
            });
            
            console.log('ğŸ’¡ æç¤ºï¼šçƒé«”æœƒä¾åºé–ƒç´…å…‰ï¼Œç¢ºèªæ˜¯å¦çœ‹å¾—åˆ°');
            console.log('ğŸ§ª === æ¸¬è©¦çµæŸ ===');
            
            showFeedback('æŸ¥çœ‹æ§åˆ¶å°è¨Šæ¯', true);
        }

        function resetCam() { 
            controls.reset();
            camera.position.set(2, 3, 3);
            camera.lookAt(0, 0, 0);
        }
        
        function onWindowResize() {
            if(camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        function animate() {
            if (controls) controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
